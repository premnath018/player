import "../../shims/install-safe.js";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/fscreen@1.2.0/node_modules/fscreen/dist/fscreen.cjs.production.js
var require_fscreen_cjs_production = __commonJS({
  "../../node_modules/.pnpm/fscreen@1.2.0/node_modules/fscreen/dist/fscreen.cjs.production.js"(exports, module) {
    "use strict";
    var e2 = { fullscreenEnabled: 0, fullscreenElement: 1, requestFullscreen: 2, exitFullscreen: 3, fullscreenchange: 4, fullscreenerror: 5, fullscreen: 6 };
    var n2 = ["webkitFullscreenEnabled", "webkitFullscreenElement", "webkitRequestFullscreen", "webkitExitFullscreen", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen"];
    var l3 = ["mozFullScreenEnabled", "mozFullScreenElement", "mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozfullscreenerror", "-moz-full-screen"];
    var r2 = ["msFullscreenEnabled", "msFullscreenElement", "msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "MSFullscreenError", "-ms-fullscreen"];
    var u2 = "undefined" != typeof window && void 0 !== (typeof window !== "undefined" ? window : null)?.document ? (typeof window !== "undefined" ? window : null)?.document : {};
    var s3 = "fullscreenEnabled" in u2 && Object.keys(e2) || n2[0] in u2 && n2 || l3[0] in u2 && l3 || r2[0] in u2 && r2 || [];
    var t2 = { requestFullscreen: function(n3) {
      return n3[s3[e2.requestFullscreen]]();
    }, requestFullscreenFunction: function(n3) {
      return n3[s3[e2.requestFullscreen]];
    }, get exitFullscreen() {
      return u2[s3[e2.exitFullscreen]].bind(u2);
    }, get fullscreenPseudoClass() {
      return ":" + s3[e2.fullscreen];
    }, addEventListener: function(n3, l4, r3) {
      return u2.addEventListener(s3[e2[n3]], l4, r3);
    }, removeEventListener: function(n3, l4, r3) {
      return u2.removeEventListener(s3[e2[n3]], l4, r3);
    }, get fullscreenEnabled() {
      return Boolean(u2[s3[e2.fullscreenEnabled]]);
    }, set fullscreenEnabled(e3) {
    }, get fullscreenElement() {
      return u2[s3[e2.fullscreenElement]];
    }, set fullscreenElement(e3) {
    }, get onfullscreenchange() {
      return u2[("on" + s3[e2.fullscreenchange]).toLowerCase()];
    }, set onfullscreenchange(n3) {
      return u2[("on" + s3[e2.fullscreenchange]).toLowerCase()] = n3;
    }, get onfullscreenerror() {
      return u2[("on" + s3[e2.fullscreenerror]).toLowerCase()];
    }, set onfullscreenerror(n3) {
      return u2[("on" + s3[e2.fullscreenerror]).toLowerCase()] = n3;
    } };
    module.exports = t2;
  }
});

// ../../node_modules/.pnpm/fscreen@1.2.0/node_modules/fscreen/dist/fscreen.cjs.development.js
var require_fscreen_cjs_development = __commonJS({
  "../../node_modules/.pnpm/fscreen@1.2.0/node_modules/fscreen/dist/fscreen.cjs.development.js"(exports, module) {
    "use strict";
    var key = {
      fullscreenEnabled: 0,
      fullscreenElement: 1,
      requestFullscreen: 2,
      exitFullscreen: 3,
      fullscreenchange: 4,
      fullscreenerror: 5,
      fullscreen: 6
    };
    var webkit = [
      "webkitFullscreenEnabled",
      "webkitFullscreenElement",
      "webkitRequestFullscreen",
      "webkitExitFullscreen",
      "webkitfullscreenchange",
      "webkitfullscreenerror",
      "-webkit-full-screen"
    ];
    var moz = [
      "mozFullScreenEnabled",
      "mozFullScreenElement",
      "mozRequestFullScreen",
      "mozCancelFullScreen",
      "mozfullscreenchange",
      "mozfullscreenerror",
      "-moz-full-screen"
    ];
    var ms2 = [
      "msFullscreenEnabled",
      "msFullscreenElement",
      "msRequestFullscreen",
      "msExitFullscreen",
      "MSFullscreenChange",
      "MSFullscreenError",
      "-ms-fullscreen"
    ];
    var document2 = typeof window !== "undefined" && typeof (typeof window !== "undefined" ? window : null)?.document !== "undefined" ? (typeof window !== "undefined" ? window : null)?.document : {};
    var vendor = "fullscreenEnabled" in document2 && Object.keys(key) || webkit[0] in document2 && webkit || moz[0] in document2 && moz || ms2[0] in document2 && ms2 || [];
    var fscreen2 = {
      requestFullscreen: function(element) {
        return element[vendor[key.requestFullscreen]]();
      },
      requestFullscreenFunction: function(element) {
        return element[vendor[key.requestFullscreen]];
      },
      get exitFullscreen() {
        return document2[vendor[key.exitFullscreen]].bind(document2);
      },
      get fullscreenPseudoClass() {
        return ":" + vendor[key.fullscreen];
      },
      addEventListener: function(type, handler, options) {
        return document2.addEventListener(vendor[key[type]], handler, options);
      },
      removeEventListener: function(type, handler, options) {
        return document2.removeEventListener(vendor[key[type]], handler, options);
      },
      get fullscreenEnabled() {
        return Boolean(document2[vendor[key.fullscreenEnabled]]);
      },
      set fullscreenEnabled(val) {
      },
      get fullscreenElement() {
        return document2[vendor[key.fullscreenElement]];
      },
      set fullscreenElement(val) {
      },
      get onfullscreenchange() {
        return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()];
      },
      set onfullscreenchange(handler) {
        return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()] = handler;
      },
      get onfullscreenerror() {
        return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()];
      },
      set onfullscreenerror(handler) {
        return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()] = handler;
      }
    };
    module.exports = fscreen2;
  }
});

// ../../node_modules/.pnpm/fscreen@1.2.0/node_modules/fscreen/dist/fscreen.cjs.js
var require_fscreen_cjs = __commonJS({
  "../../node_modules/.pnpm/fscreen@1.2.0/node_modules/fscreen/dist/fscreen.cjs.js"(exports, module) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module.exports = require_fscreen_cjs_production();
    } else {
      module.exports = require_fscreen_cjs_development();
    }
  }
});

// shims/dom.js
function getWindow() {
  const attributes = /* @__PURE__ */ new WeakMap();
  const attributesForElement = (element) => {
    let attrs = attributes.get(element);
    if (!attrs) {
      attributes.set(element, attrs = /* @__PURE__ */ new Map());
    }
    return attrs;
  };
  class Element {
  }
  class HTMLElement extends Element {
    get attributes() {
      return Array.from(attributesForElement(this)).map(([name, value]) => ({
        name,
        value
      }));
    }
    get style() {
      return {
        setProperty(name, value) {
          const attrs = attributesForElement(this);
          let styles = attrs.get("style") ?? "";
          styles += `${name}: ${value};`;
          attrs.set("style", styles);
        }
      };
    }
    addEventListener() {
    }
    removeEventListener() {
    }
    setAttribute(name, value) {
      attributesForElement(this).set(name, value);
    }
    removeAttribute(name) {
      attributesForElement(this).delete(name);
    }
    hasAttribute(name) {
      return attributesForElement(this).has(name);
    }
    attachShadow() {
      return { host: this };
    }
    getAttribute(name) {
      const value = attributesForElement(this).get(name);
      return value === void 0 ? null : value;
    }
  }
  class ShadowRoot {
  }
  class Document {
    get adoptedStyleSheets() {
      return [];
    }
    addEventListener() {
    }
    removeEventListener() {
    }
    createTreeWalker() {
      return {};
    }
    createTextNode() {
      return {};
    }
    createElement() {
      return {};
    }
  }
  class CSSStyleSheet {
    replace() {
    }
  }
  class CustomElementRegistry {
    constructor() {
      this.__definitions = /* @__PURE__ */ new Map();
    }
    define(name, ctor) {
      this.__definitions.set(name, {
        ctor,
        observedAttributes: ctor.observedAttributes ?? []
      });
    }
    get(name) {
      const definition = this.__definitions.get(name);
      return definition && definition.ctor;
    }
  }
  class CustomEvent2 {
    constructor(type) {
      this.type = type;
    }
  }
  const window2 = {
    Element,
    HTMLElement,
    Document,
    document: new Document(),
    CSSStyleSheet,
    ShadowRoot,
    CustomElementRegistry,
    customElements: new CustomElementRegistry(),
    CustomEvent: CustomEvent2,
    btoa(s3) {
      return Buffer.from(s3, "binary").toString("base64");
    },
    location: new URL("http://localhost"),
    MutationObserver: class {
      observe() {
      }
    },
    addEventListener() {
    },
    removeEventListener() {
    },
    requestAnimationFrame() {
    }
  };
  return window2;
}

// shims/install-safe.js
if (typeof window === "undefined" && globalThis.document === void 0) {
  const window2 = getWindow();
  Object.assign(globalThis, window2);
}

// src/utils/events.ts
function listen(target, type, listener, options) {
  target.addEventListener(type, listener, options);
  return () => {
    target.removeEventListener(type, listener, options);
  };
}
function eventTypeIncludes(event, types) {
  return types.some((type) => (event == null ? void 0 : event.type.includes(type)) ?? false);
}
function isPointerEvent(event) {
  return eventTypeIncludes(event, ["pointer"]);
}
function isTouchEvent(event) {
  return eventTypeIncludes(event, ["touch"]);
}
function isMouseEvent(event) {
  return eventTypeIncludes(event, ["click", "mouse"]);
}
async function waitForEvent(target, type, options) {
  return new Promise((resolve, reject) => {
    const timerId = (typeof window !== "undefined" ? window : null)?.setTimeout(() => {
      reject(`Timed out waiting for event \`${type}\`.`);
    }, (options == null ? void 0 : options.timeout) ?? 1e3);
    listen(
      target,
      type,
      (event) => {
        (typeof window !== "undefined" ? window : null)?.clearTimeout(timerId);
        resolve(event);
      },
      options
    );
  });
}
var DisposalBin = class {
  constructor() {
    this._disposal = this._disposal ?? [];
  }
  add(...callbacks) {
    if (callbacks) {
      callbacks.forEach((cb) => {
        this._disposal.push(cb);
      });
    }
  }
  empty() {
    this._disposal.forEach((fn) => fn());
    this._disposal = [];
  }
};

// src/events/event-listener.ts
function eventListener(host, type, listener, options) {
  let off;
  function attach() {
    if (!off) {
      off = listen((options == null ? void 0 : options.target) ?? host, type, listener, options);
    }
  }
  attach();
  host.addController({
    hostConnected() {
      attach();
    },
    hostDisconnected() {
      off == null ? void 0 : off();
      off = void 0;
    }
  });
}

// src/events/VdsEvent.ts
var VdsEvent = class extends CustomEvent {
  constructor(type, eventInit = {}) {
    super(type, eventInit);
    this.triggerEvent = eventInit.triggerEvent;
    if (!this.hasOwnProperty("originEvent")) {
      Object.defineProperties(this, {
        originEvent: {
          get() {
            return getOriginEvent(this) ?? this;
          }
        },
        isOriginTrusted: {
          get() {
            var _a3;
            return ((_a3 = getOriginEvent(this)) == null ? void 0 : _a3.isTrusted) ?? false;
          }
        }
      });
    }
  }
  get originEvent() {
    return getOriginEvent(this) ?? this;
  }
  get isOriginTrusted() {
    var _a3;
    return ((_a3 = this.originEvent) == null ? void 0 : _a3.isTrusted) ?? false;
  }
};
function vdsEvent(type, eventInit = {}) {
  return new VdsEvent(type, eventInit);
}
function isVdsEvent(event) {
  return (event == null ? void 0 : event.hasOwnProperty("triggerEvent")) ?? false;
}
function getOriginEvent(event) {
  let triggerEvent = event.triggerEvent;
  while (triggerEvent && triggerEvent.triggerEvent) {
    triggerEvent = triggerEvent.triggerEvent;
  }
  return triggerEvent;
}
function walkTriggerEventChain(event, callback) {
  if (!isVdsEvent(event))
    return;
  let triggerEvent = event.triggerEvent;
  while (triggerEvent && triggerEvent.triggerEvent) {
    const returnValue = callback(triggerEvent);
    if (returnValue)
      return [triggerEvent, returnValue];
    triggerEvent = triggerEvent.triggerEvent;
  }
  return;
}
function findTriggerEvent(event, eventType) {
  var _a3;
  return (_a3 = walkTriggerEventChain(event, (e2) => e2.type === eventType)) == null ? void 0 : _a3[0];
}
function hasTriggerEvent(event, eventType) {
  return !!findTriggerEvent(event, eventType);
}
function appendTriggerEvent(event, triggerEvent) {
  (getOriginEvent(event) ?? event).triggerEvent = triggerEvent;
}

// src/events/redispatch.ts
function redispatchEvent(target, event) {
  if (event.bubbles && event.composed)
    return;
  const newEvent = new VdsEvent(event.type, {
    triggerEvent: event.triggerEvent ?? event,
    detail: event.detail,
    bubbles: event.bubbles,
    cancelable: event.cancelable,
    composed: event.composed
  });
  target.dispatchEvent(newEvent);
}

// src/context/ContextConsumerController.ts
var orphanConsumers = /* @__PURE__ */ new Map();
var ContextConsumerController = class {
  constructor(_host, initialValue, _options) {
    this._host = _host;
    this.initialValue = initialValue;
    this._options = _options;
    this._registrationCallbacks = [];
    _host.addController({
      hostConnected: () => {
        this._connect();
      },
      hostDisconnected: () => {
        delete this._host[this.id];
      }
    });
  }
  get id() {
    return this._options.id;
  }
  get value() {
    return this._host[this.id] ?? this.initialValue;
  }
  get registered() {
    return this.id in this._host;
  }
  _connect() {
    if (this.id in this._host)
      return;
    const setValue = (value) => {
      var _a3;
      this._host[this.id] = value;
      (_a3 = this._registrationCallbacks) == null ? void 0 : _a3.forEach((fn) => fn(value));
      this._registrationCallbacks = void 0;
    };
    this._host.dispatchEvent(
      vdsEvent("vds-context-consumer-connect", {
        bubbles: true,
        composed: true,
        detail: {
          id: this.id,
          setValue
        }
      })
    );
    if (!this.registered) {
      const orphans = orphanConsumers.get(this.id) ?? [];
      orphans.push({ host: this._host, setValue });
      orphanConsumers.set(this.id, orphans);
    }
  }
  whenRegistered(callback) {
    var _a3;
    if (this.registered) {
      callback(this.value);
      return;
    }
    (_a3 = this._registrationCallbacks) == null ? void 0 : _a3.push(callback);
  }
};
function adoptOrphans(id, provider) {
  const orphans = orphanConsumers.get(id) ?? [];
  const adoptees = orphans.filter(({ host }) => provider.contains(host));
  orphanConsumers.set(
    id,
    orphans.filter(({ host }) => !provider.contains(host))
  );
  return adoptees;
}

// src/context/ContextProviderController.ts
var ContextProviderController = class {
  constructor(_host, _initValue, _options) {
    this._host = _host;
    this._initValue = _initValue;
    this._options = _options;
    this._stopDisposal = new DisposalBin();
    this._value = _initValue();
    _host.addController({
      hostConnected: this.start.bind(this),
      hostDisconnected: this.stop.bind(this)
    });
  }
  get id() {
    return this._options.id;
  }
  get value() {
    return this._value;
  }
  start() {
    const dispose = listen(
      this._host,
      "vds-context-consumer-connect",
      this._handleConsumerConnect.bind(this)
    );
    for (const orphan of adoptOrphans(this.id, this._host)) {
      orphan.setValue(this._value);
    }
    this._stopDisposal.add(dispose);
  }
  stop() {
    this._stopDisposal.empty();
  }
  _handleConsumerConnect(event) {
    const consumer = event.detail;
    if (consumer.id !== this.id)
      return;
    event.stopImmediatePropagation();
    consumer.setValue(this._value);
  }
};

// src/context/context.ts
function createContext(initValue) {
  const id = Symbol("@vidstack/context");
  return {
    id,
    consume(host) {
      return new ContextConsumerController(host, initValue(), { id });
    },
    provide(host) {
      return new ContextProviderController(host, initValue, { id });
    }
  };
}
function isContext(context) {
  return typeof (context == null ? void 0 : context.id) === "symbol" && context.id.description === "@vidstack/context";
}

// ../../node_modules/.pnpm/lit-html@2.3.1/node_modules/lit-html/node/lit-html.js
var t;
var i = globalThis;
var s = i.trustedTypes;
var e = s ? s.createPolicy("lit-html", { createHTML: (t2) => t2 }) : void 0;
var o = `lit$${(Math.random() + "").slice(9)}$`;
var n = "?" + o;
var l = `<${n}>`;
var h = void 0 === i.document ? { createTreeWalker: () => ({}) } : document;
var r = (t2 = "") => h.createComment(t2);
var d = (t2) => null === t2 || "object" != typeof t2 && "function" != typeof t2;
var u = Array.isArray;
var c = (t2) => u(t2) || "function" == typeof (null == t2 ? void 0 : t2[Symbol.iterator]);
var v = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var a = /-->/g;
var f = />/g;
var _ = RegExp(`>|[ 	
\f\r](?:([^\\s"'>=/]+)([ 	
\f\r]*=[ 	
\f\r]*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var m = /'/g;
var p = /"/g;
var g = /^(?:script|style|textarea|title)$/i;
var $ = (t2) => (i2, ...s3) => ({ _$litType$: t2, strings: i2, values: s3 });
var y = $(1);
var x = $(2);
var T = Symbol.for("lit-noChange");
var b = Symbol.for("lit-nothing");
var w = /* @__PURE__ */ new WeakMap();
var E = h.createTreeWalker(h, 129, null, false);
var C = (t2, i2) => {
  const s3 = t2.length - 1, n2 = [];
  let h3, r2 = 2 === i2 ? "<svg>" : "", d3 = v;
  for (let i3 = 0; i3 < s3; i3++) {
    const s4 = t2[i3];
    let e2, u3, c2 = -1, $2 = 0;
    for (; $2 < s4.length && (d3.lastIndex = $2, u3 = d3.exec(s4), null !== u3); )
      $2 = d3.lastIndex, d3 === v ? "!--" === u3[1] ? d3 = a : void 0 !== u3[1] ? d3 = f : void 0 !== u3[2] ? (g.test(u3[2]) && (h3 = RegExp("</" + u3[2], "g")), d3 = _) : void 0 !== u3[3] && (d3 = _) : d3 === _ ? ">" === u3[0] ? (d3 = null != h3 ? h3 : v, c2 = -1) : void 0 === u3[1] ? c2 = -2 : (c2 = d3.lastIndex - u3[2].length, e2 = u3[1], d3 = void 0 === u3[3] ? _ : '"' === u3[3] ? p : m) : d3 === p || d3 === m ? d3 = _ : d3 === a || d3 === f ? d3 = v : (d3 = _, h3 = void 0);
    const y2 = d3 === _ && t2[i3 + 1].startsWith("/>") ? " " : "";
    r2 += d3 === v ? s4 + l : c2 >= 0 ? (n2.push(e2), s4.slice(0, c2) + "$lit$" + s4.slice(c2) + o + y2) : s4 + o + (-2 === c2 ? (n2.push(void 0), i3) : y2);
  }
  const u2 = r2 + (t2[s3] || "<?>") + (2 === i2 ? "</svg>" : "");
  if (!Array.isArray(t2) || !t2.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return [void 0 !== e ? e.createHTML(u2) : u2, n2];
};
var P = class {
  constructor({ strings: t2, _$litType$: i2 }, e2) {
    let l3;
    this.parts = [];
    let h3 = 0, d3 = 0;
    const u2 = t2.length - 1, c2 = this.parts, [v2, a2] = C(t2, i2);
    if (this.el = P.createElement(v2, e2), E.currentNode = this.el.content, 2 === i2) {
      const t3 = this.el.content, i3 = t3.firstChild;
      i3.remove(), t3.append(...i3.childNodes);
    }
    for (; null !== (l3 = E.nextNode()) && c2.length < u2; ) {
      if (1 === l3.nodeType) {
        if (l3.hasAttributes()) {
          const t3 = [];
          for (const i3 of l3.getAttributeNames())
            if (i3.endsWith("$lit$") || i3.startsWith(o)) {
              const s3 = a2[d3++];
              if (t3.push(i3), void 0 !== s3) {
                const t4 = l3.getAttribute(s3.toLowerCase() + "$lit$").split(o), i4 = /([.?@])?(.*)/.exec(s3);
                c2.push({ type: 1, index: h3, name: i4[2], strings: t4, ctor: "." === i4[1] ? k : "?" === i4[1] ? H : "@" === i4[1] ? I : M });
              } else
                c2.push({ type: 6, index: h3 });
            }
          for (const i3 of t3)
            l3.removeAttribute(i3);
        }
        if (g.test(l3.tagName)) {
          const t3 = l3.textContent.split(o), i3 = t3.length - 1;
          if (i3 > 0) {
            l3.textContent = s ? s.emptyScript : "";
            for (let s3 = 0; s3 < i3; s3++)
              l3.append(t3[s3], r()), E.nextNode(), c2.push({ type: 2, index: ++h3 });
            l3.append(t3[i3], r());
          }
        }
      } else if (8 === l3.nodeType)
        if (l3.data === n)
          c2.push({ type: 2, index: h3 });
        else {
          let t3 = -1;
          for (; -1 !== (t3 = l3.data.indexOf(o, t3 + 1)); )
            c2.push({ type: 7, index: h3 }), t3 += o.length - 1;
        }
      h3++;
    }
  }
  static createElement(t2, i2) {
    const s3 = h.createElement("template");
    return s3.innerHTML = t2, s3;
  }
};
function V(t2, i2, s3 = t2, e2) {
  var o2, n2, l3, h3;
  if (i2 === T)
    return i2;
  let r2 = void 0 !== e2 ? null === (o2 = s3._$Cl) || void 0 === o2 ? void 0 : o2[e2] : s3._$Cu;
  const u2 = d(i2) ? void 0 : i2._$litDirective$;
  return (null == r2 ? void 0 : r2.constructor) !== u2 && (null === (n2 = null == r2 ? void 0 : r2._$AO) || void 0 === n2 || n2.call(r2, false), void 0 === u2 ? r2 = void 0 : (r2 = new u2(t2), r2._$AT(t2, s3, e2)), void 0 !== e2 ? (null !== (l3 = (h3 = s3)._$Cl) && void 0 !== l3 ? l3 : h3._$Cl = [])[e2] = r2 : s3._$Cu = r2), void 0 !== r2 && (i2 = V(t2, r2._$AS(t2, i2.values), r2, e2)), i2;
}
var N = class {
  constructor(t2, i2) {
    this.v = [], this._$AN = void 0, this._$AD = t2, this._$AM = i2;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  p(t2) {
    var i2;
    const { el: { content: s3 }, parts: e2 } = this._$AD, o2 = (null !== (i2 = null == t2 ? void 0 : t2.creationScope) && void 0 !== i2 ? i2 : h).importNode(s3, true);
    E.currentNode = o2;
    let n2 = E.nextNode(), l3 = 0, r2 = 0, d3 = e2[0];
    for (; void 0 !== d3; ) {
      if (l3 === d3.index) {
        let i3;
        2 === d3.type ? i3 = new S(n2, n2.nextSibling, this, t2) : 1 === d3.type ? i3 = new d3.ctor(n2, d3.name, d3.strings, this, t2) : 6 === d3.type && (i3 = new L(n2, this, t2)), this.v.push(i3), d3 = e2[++r2];
      }
      l3 !== (null == d3 ? void 0 : d3.index) && (n2 = E.nextNode(), l3++);
    }
    return o2;
  }
  m(t2) {
    let i2 = 0;
    for (const s3 of this.v)
      void 0 !== s3 && (void 0 !== s3.strings ? (s3._$AI(t2, s3, i2), i2 += s3.strings.length - 2) : s3._$AI(t2[i2])), i2++;
  }
};
var S = class {
  constructor(t2, i2, s3, e2) {
    var o2;
    this.type = 2, this._$AH = b, this._$AN = void 0, this._$AA = t2, this._$AB = i2, this._$AM = s3, this.options = e2, this._$C_ = null === (o2 = null == e2 ? void 0 : e2.isConnected) || void 0 === o2 || o2;
  }
  get _$AU() {
    var t2, i2;
    return null !== (i2 = null === (t2 = this._$AM) || void 0 === t2 ? void 0 : t2._$AU) && void 0 !== i2 ? i2 : this._$C_;
  }
  get parentNode() {
    let t2 = this._$AA.parentNode;
    const i2 = this._$AM;
    return void 0 !== i2 && 11 === t2.nodeType && (t2 = i2.parentNode), t2;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t2, i2 = this) {
    t2 = V(this, t2, i2), d(t2) ? t2 === b || null == t2 || "" === t2 ? (this._$AH !== b && this._$AR(), this._$AH = b) : t2 !== this._$AH && t2 !== T && this.$(t2) : void 0 !== t2._$litType$ ? this.T(t2) : void 0 !== t2.nodeType ? this.k(t2) : c(t2) ? this.O(t2) : this.$(t2);
  }
  S(t2, i2 = this._$AB) {
    return this._$AA.parentNode.insertBefore(t2, i2);
  }
  k(t2) {
    this._$AH !== t2 && (this._$AR(), this._$AH = this.S(t2));
  }
  $(t2) {
    this._$AH !== b && d(this._$AH) ? this._$AA.nextSibling.data = t2 : this.k(h.createTextNode(t2)), this._$AH = t2;
  }
  T(t2) {
    var i2;
    const { values: s3, _$litType$: e2 } = t2, o2 = "number" == typeof e2 ? this._$AC(t2) : (void 0 === e2.el && (e2.el = P.createElement(e2.h, this.options)), e2);
    if ((null === (i2 = this._$AH) || void 0 === i2 ? void 0 : i2._$AD) === o2)
      this._$AH.m(s3);
    else {
      const t3 = new N(o2, this), i3 = t3.p(this.options);
      t3.m(s3), this.k(i3), this._$AH = t3;
    }
  }
  _$AC(t2) {
    let i2 = w.get(t2.strings);
    return void 0 === i2 && w.set(t2.strings, i2 = new P(t2)), i2;
  }
  O(t2) {
    u(this._$AH) || (this._$AH = [], this._$AR());
    const i2 = this._$AH;
    let s3, e2 = 0;
    for (const o2 of t2)
      e2 === i2.length ? i2.push(s3 = new S(this.S(r()), this.S(r()), this, this.options)) : s3 = i2[e2], s3._$AI(o2), e2++;
    e2 < i2.length && (this._$AR(s3 && s3._$AB.nextSibling, e2), i2.length = e2);
  }
  _$AR(t2 = this._$AA.nextSibling, i2) {
    var s3;
    for (null === (s3 = this._$AP) || void 0 === s3 || s3.call(this, false, true, i2); t2 && t2 !== this._$AB; ) {
      const i3 = t2.nextSibling;
      t2.remove(), t2 = i3;
    }
  }
  setConnected(t2) {
    var i2;
    void 0 === this._$AM && (this._$C_ = t2, null === (i2 = this._$AP) || void 0 === i2 || i2.call(this, t2));
  }
};
var M = class {
  constructor(t2, i2, s3, e2, o2) {
    this.type = 1, this._$AH = b, this._$AN = void 0, this.element = t2, this.name = i2, this._$AM = e2, this.options = o2, s3.length > 2 || "" !== s3[0] || "" !== s3[1] ? (this._$AH = Array(s3.length - 1).fill(new String()), this.strings = s3) : this._$AH = b;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2, i2 = this, s3, e2) {
    const o2 = this.strings;
    let n2 = false;
    if (void 0 === o2)
      t2 = V(this, t2, i2, 0), n2 = !d(t2) || t2 !== this._$AH && t2 !== T, n2 && (this._$AH = t2);
    else {
      const e3 = t2;
      let l3, h3;
      for (t2 = o2[0], l3 = 0; l3 < o2.length - 1; l3++)
        h3 = V(this, e3[s3 + l3], i2, l3), h3 === T && (h3 = this._$AH[l3]), n2 || (n2 = !d(h3) || h3 !== this._$AH[l3]), h3 === b ? t2 = b : t2 !== b && (t2 += (null != h3 ? h3 : "") + o2[l3 + 1]), this._$AH[l3] = h3;
    }
    n2 && !e2 && this.P(t2);
  }
  P(t2) {
    t2 === b ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t2 ? t2 : "");
  }
};
var k = class extends M {
  constructor() {
    super(...arguments), this.type = 3;
  }
  P(t2) {
    this.element[this.name] = t2 === b ? void 0 : t2;
  }
};
var R = s ? s.emptyScript : "";
var H = class extends M {
  constructor() {
    super(...arguments), this.type = 4;
  }
  P(t2) {
    t2 && t2 !== b ? this.element.setAttribute(this.name, R) : this.element.removeAttribute(this.name);
  }
};
var I = class extends M {
  constructor(t2, i2, s3, e2, o2) {
    super(t2, i2, s3, e2, o2), this.type = 5;
  }
  _$AI(t2, i2 = this) {
    var s3;
    if ((t2 = null !== (s3 = V(this, t2, i2, 0)) && void 0 !== s3 ? s3 : b) === T)
      return;
    const e2 = this._$AH, o2 = t2 === b && e2 !== b || t2.capture !== e2.capture || t2.once !== e2.once || t2.passive !== e2.passive, n2 = t2 !== b && (e2 === b || o2);
    o2 && this.element.removeEventListener(this.name, this, e2), n2 && this.element.addEventListener(this.name, this, t2), this._$AH = t2;
  }
  handleEvent(t2) {
    var i2, s3;
    "function" == typeof this._$AH ? this._$AH.call(null !== (s3 = null === (i2 = this.options) || void 0 === i2 ? void 0 : i2.host) && void 0 !== s3 ? s3 : this.element, t2) : this._$AH.handleEvent(t2);
  }
};
var L = class {
  constructor(t2, i2, s3) {
    this.element = t2, this.type = 6, this._$AN = void 0, this._$AM = i2, this.options = s3;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2) {
    V(this, t2);
  }
};
var W = i.litHtmlPolyfillSupport;
null == W || W(P, S), (null !== (t = i.litHtmlVersions) && void 0 !== t ? t : i.litHtmlVersions = []).push("2.3.1");

// ../../node_modules/.pnpm/lit-html@2.3.1/node_modules/lit-html/node/directives/if-defined.js
var l2 = (l3) => null != l3 ? l3 : b;

// src/directives/if-non-empty.ts
function ifNonEmpty(value) {
  return l2(value === "" || value === "undefined" ? void 0 : value);
}

// src/utils/unit.ts
function noop(...args) {
}
function notEqual(valueA, valueB) {
  return valueB !== valueA && (valueB === valueB || valueA === valueA);
}
function safeNotEqual(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || a2 && typeof a2 === "object" || typeof a2 === "function";
}
function equal(valueA, valueB) {
  return !notEqual(valueA, valueB);
}
function isNull(value) {
  return value === null;
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isNil(value) {
  return isNull(value) || isUndefined(value);
}
function isObject(value) {
  return (value == null ? void 0 : value.constructor) === Object;
}
function isNumber(value) {
  return typeof value === "number" && !Number.isNaN(value);
}
function isString(value) {
  return typeof value === "string";
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isFunction(value) {
  return typeof value === "function";
}
function isArray(value) {
  return Array.isArray(value);
}
function createRegex(regex) {
  return isString(regex) ? new RegExp(regex) : regex;
}
function isWindow(value) {
  return value === window;
}

// src/directives/if-number.ts
function ifNumber(value) {
  return l2(isNumber(value) ? value : void 0);
}

// src/elements/discovery/discover.ts
var discoverers = /* @__PURE__ */ new Map();
var discoverables = /* @__PURE__ */ new Map();
function connect(discoverable2, id, onDisconnect) {
  for (const { host, callback } of Array.from(discoverers.get(id) ?? [])) {
    if (host !== discoverable2 && host.contains(discoverable2)) {
      callback(discoverable2, onDisconnect);
    }
  }
}
function find(host, id) {
  return Array.from(discoverables.get(id) ?? []).filter(
    ({ element }) => host !== element && host.contains(element)
  );
}
function discover(host, id, callback) {
  const discoverer = { host, callback };
  host.addController({
    hostConnected: () => {
      for (const { element, onDisconnect } of find(host, id)) {
        callback(element, onDisconnect);
      }
      discoverers.set(id, (discoverers.get(id) ?? /* @__PURE__ */ new Set()).add(discoverer));
    },
    hostDisconnected: () => {
      var _a3;
      (_a3 = discoverers.get(id)) == null ? void 0 : _a3.delete(discoverer);
    }
  });
}
function discoverable(host, eventType, options = {}) {
  const id = options.register;
  const disconnectDisposal = new DisposalBin();
  const onDisconnect = (callback) => {
    disconnectDisposal.add(callback);
  };
  const discoverable2 = {
    element: host,
    onDisconnect
  };
  host.addController({
    hostConnected() {
      const event = vdsEvent(eventType, {
        bubbles: true,
        composed: true,
        detail: discoverable2
      });
      host.dispatchEvent(event);
      if (id) {
        discoverables.set(id, (discoverables.get(id) ?? /* @__PURE__ */ new Set()).add(discoverable2));
        connect(host, id, onDisconnect);
      }
    },
    hostDisconnected() {
      var _a3;
      disconnectDisposal.empty();
      if (id) {
        (_a3 = discoverables.get(id)) == null ? void 0 : _a3.delete(discoverable2);
      }
    }
  });
}

// src/utils/support.ts
var IS_CLIENT = typeof window !== "undefined";
var _a;
var UA = IS_CLIENT ? (_a = (typeof window !== "undefined" ? window : null)?.navigator) == null ? void 0 : _a.userAgent.toLowerCase() : "";
var IS_IOS = /iphone|ipad|ipod|ios|CriOS|FxiOS/.test(UA);
var IS_ANDROID = /android/.test(UA);
var IS_MOBILE = IS_CLIENT && (IS_IOS || IS_ANDROID);
var _a2;
var IS_IPHONE = IS_CLIENT && /(iPhone|iPod)/gi.test((_a2 = (typeof window !== "undefined" ? window : null)?.navigator) == null ? void 0 : _a2.platform);
var IS_FIREFOX = /firefox/.test(UA);
var IS_CHROME = IS_CLIENT && !!(typeof window !== "undefined" ? window : null)?.chrome;
var IS_SAFARI = IS_CLIENT && !IS_CHROME && ((typeof window !== "undefined" ? window : null)?.safari || IS_IOS || /(apple|safari)/.test(UA));
var ORIGIN = IS_CLIENT && (typeof window !== "undefined" ? window : null)?.location.protocol !== "file:" ? `${(typeof window !== "undefined" ? window : null)?.location.protocol}//${(typeof window !== "undefined" ? window : null)?.location.hostname}` : void 0;
function currentSafariVersion() {
  return IS_CLIENT ? Number((/Safari\/(\d+)/.exec(navigator.userAgent) ?? ["", 0])[1]) : 0;
}
function canFullscreenVideo() {
  if (!IS_CLIENT)
    return false;
  const video = document.createElement("video");
  return isFunction(video.webkitEnterFullscreen);
}
function canObserveIntersection() {
  return IS_CLIENT && !isUndefined((typeof window !== "undefined" ? window : null)?.IntersectionObserver);
}
function canOrientScreen() {
  return IS_CLIENT && !isUndefined(screen.orientation) && isFunction(screen.orientation.lock) && isFunction(screen.orientation.unlock);
}
function canRotateScreen() {
  return IS_CLIENT && !isUndefined((typeof window !== "undefined" ? window : null)?.screen.orientation) && !isUndefined((typeof window !== "undefined" ? window : null)?.screen.orientation.lock);
}
function isReducedMotionPreferred() {
  return IS_CLIENT && "matchMedia" in window && (typeof window !== "undefined" ? window : null)?.matchMedia("(prefers-reduced-motion)").matches;
}
function canPlayHLSNatively() {
  if (!IS_CLIENT)
    return false;
  const video = document.createElement("video");
  return video.canPlayType("application/vnd.apple.mpegurl").length > 0;
}
function canUsePiPInChrome() {
  if (!IS_CLIENT)
    return false;
  const video = document.createElement("video");
  return !!document.pictureInPictureEnabled && !video.disablePictureInPicture;
}
function canUsePiPInSafari() {
  if (!IS_CLIENT)
    return false;
  const video = document.createElement("video");
  return isFunction(video.webkitSupportsPresentationMode) && isFunction(video.webkitSetPresentationMode) && !IS_IPHONE;
}
function canUsePiP() {
  return canUsePiPInChrome() || canUsePiPInSafari();
}
function canAutoplay(muted = true, playsinline = true) {
  if (!IS_CLIENT)
    return Promise.resolve(false);
  const video = document.createElement("video");
  if (muted) {
    video.setAttribute("muted", "");
    video.muted = true;
  }
  if (playsinline) {
    video.setAttribute("playsinline", "");
    video.setAttribute("webkit-playsinline", "");
  }
  video.setAttribute("height", "0");
  video.setAttribute("width", "0");
  video.style.position = "fixed";
  video.style.top = "0";
  video.style.width = "0";
  video.style.height = "0";
  video.style.opacity = "0";
  new Promise((resolve) => resolve(video.play())).catch(noop);
  return Promise.resolve(!video.paused);
}
function getMediaSource() {
  return (window == null ? void 0 : (typeof window !== "undefined" ? window : null)?.MediaSource) ?? (window == null ? void 0 : (typeof window !== "undefined" ? window : null)?.WebKitMediaSource);
}
function getSourceBuffer() {
  return (window == null ? void 0 : (typeof window !== "undefined" ? window : null)?.SourceBuffer) ?? (window == null ? void 0 : (typeof window !== "undefined" ? window : null)?.WebKitSourceBuffer);
}
function isHlsjsSupported() {
  const mediaSource = getMediaSource();
  if (isUndefined(mediaSource)) {
    return false;
  }
  const isTypeSupported = mediaSource && isFunction(mediaSource.isTypeSupported) && mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
  const sourceBuffer = getSourceBuffer();
  const isSourceBufferValid = isUndefined(sourceBuffer) || !isUndefined(sourceBuffer.prototype) && isFunction(sourceBuffer.prototype.appendBuffer) && isFunction(sourceBuffer.prototype.remove);
  return !!isTypeSupported && !!isSourceBufferValid;
}

// src/elements/WithFocus.ts
var focusableSelector = `
  ${[
  "a[href]",
  "area[href]",
  `input:not([disabled]):not([tabindex='-1'])`,
  `button:not([disabled]):not([tabindex='-1'])`,
  `select:not([disabled]):not([tabindex='-1'])`,
  `textarea:not([disabled]):not([tabindex='-1'])`,
  "iframe",
  "object",
  "embed",
  `*[tabindex]:not([tabindex='-1'])`,
  "*[contenteditable=true]",
  "vds-fullscreen-button",
  "vds-mute-button",
  "vds-play-button",
  "vds-slider",
  "vds-time-slider",
  "vds-volume-slider"
].join(", ")}
`;
function WithFocus(Base) {
  return class WithFocusMixin extends Base {
    static get shadowRootOptions() {
      return {
        ...Base.shadowRootOptions,
        delegatesFocus: currentSafariVersion() <= 537
      };
    }
    focus() {
      var _a3, _b;
      if ((_a3 = this.shadowRoot) == null ? void 0 : _a3.delegatesFocus) {
        super.focus();
      } else {
        const delegateTarget = ((_b = this.shadowRoot) == null ? void 0 : _b.querySelector(focusableSelector)) || this.querySelector(focusableSelector);
        if (delegateTarget) {
          delegateTarget.focus();
        } else {
          super.focus();
        }
      }
    }
  };
}

// src/fullscreen/FullscreenController.ts
var import_fscreen = __toESM(require_fscreen_cjs(), 1);

// src/logger/events.ts
function logEvent(level, ...data) {
  return vdsEvent("vds-log", {
    bubbles: true,
    composed: true,
    detail: {
      level,
      data
    }
  });
}

// src/logger/grouped-log.ts
var GROUPED_LOG_ID = Symbol("@vidstack/grouped-log");
function isGroupedLog(data) {
  return isObject(data) && data[GROUPED_LOG_ID] === true;
}
function groupedLog(title, parent) {
  const logs = [];
  const group = {
    [GROUPED_LOG_ID]: true,
    title,
    logs,
    log(...data) {
      logs.push({ data });
      return group;
    },
    labelledLog(label, ...data) {
      logs.push({ label, data });
      return group;
    },
    groupStart(title2) {
      return groupedLog(title2, group);
    },
    groupEnd() {
      parent == null ? void 0 : parent.logs.push(group);
      return parent ?? group;
    }
  };
  return group;
}

// src/logger/LogDispatcher.ts
var LogDispatcher = class {
  constructor(_host) {
    this._host = _host;
  }
  error(...data) {
    this._dispatch("error", ...data);
  }
  warn(...data) {
    this._dispatch("warn", ...data);
  }
  info(...data) {
    this._dispatch("info", ...data);
  }
  debug(...data) {
    this._dispatch("debug", ...data);
  }
  errorGroup(title) {
    return this._groupDispatcher("error", title);
  }
  warnGroup(title) {
    return this._groupDispatcher("warn", title);
  }
  infoGroup(title) {
    return this._groupDispatcher("info", title);
  }
  debugGroup(title) {
    return this._groupDispatcher("debug", title);
  }
  _dispatch(level, ...data) {
    this._host.dispatchEvent(logEvent(level, ...data));
  }
  _groupDispatcher(level, title, rootGroup, parentGroup) {
    const group = groupedLog(title, parentGroup);
    group.dispatch = () => {
      this._dispatch(level, rootGroup ?? group);
    };
    return {
      ...group,
      groupStart: (title2) => {
        return this._groupDispatcher(level, title2, rootGroup ?? group, group);
      }
    };
  }
};

// src/logger/log-lifecycle.ts
function logElementLifecycle(_host) {
  const logger = new LogDispatcher(_host);
  _host.addController({
    hostConnected() {
      logger.debug("\u{1F517} connected");
    },
    hostUpdated() {
      logger.debug("\u{1F504} updated");
    },
    hostDisconnected() {
      logger.debug("\u{1F5D1}\uFE0F disconnected");
    }
  });
}

// src/logger/colors.ts
var LOCAL_STORAGE_KEY = "@vidstack/log-colors";
var colors = getSavedColors();
function getSavedColors() {
  if (IS_CLIENT && !isUndefined((typeof window !== "undefined" ? window : null)?.localStorage)) {
    let colors2 = {};
    try {
      colors2 = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) ?? "");
    } catch {
    }
    return new Map(Object.entries(colors2));
  }
  return /* @__PURE__ */ new Map();
}
function getColor(key) {
  return colors.get(key);
}
function saveColor(key, { color = generateColor(), overwrite = false } = {}) {
  if (!colors.has(key) || overwrite) {
    colors.set(key, color);
    saveColors();
  }
}
function generateColor() {
  return `hsl(${Math.random() * 360}, 55%, 70%)`;
}
function saveColors() {
  if (IS_CLIENT && !isUndefined((typeof window !== "undefined" ? window : null)?.localStorage)) {
    const map = {};
    colors.forEach(function(value, key) {
      map[key] = value;
    });
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(map));
  }
}

// src/logger/LogLevel.ts
var LogLevelValue = Object.freeze({
  silent: 0,
  error: 1,
  warn: 2,
  info: 3,
  debug: 4
});
var LogLevelColor = Object.freeze({
  silent: "white",
  error: "hsl(6, 58%, 50%)",
  warn: "hsl(51, 58%, 50%)",
  info: "hsl(219, 58%, 50%)",
  debug: "hsl(280, 58%, 50%)"
});

// src/utils/number.ts
function round(num, decimalPlaces = 2) {
  return Number(num.toFixed(decimalPlaces));
}
function clampNumber(min, value, max) {
  return Math.max(min, Math.min(max, value));
}
function getNumberOfDecimalPlaces(num) {
  var _a3;
  return ((_a3 = String(num).split(".")[1]) == null ? void 0 : _a3.length) ?? 0;
}

// src/logger/ms.ts
var s2 = 1e3;
var m2 = s2 * 60;
var h2 = m2 * 60;
var d2 = h2 * 24;
function ms(val) {
  const msAbs = Math.abs(val);
  if (msAbs >= d2) {
    return Math.round(val / d2) + "d";
  }
  if (msAbs >= h2) {
    return Math.round(val / h2) + "h";
  }
  if (msAbs >= m2) {
    return Math.round(val / m2) + "m";
  }
  if (msAbs >= s2) {
    return Math.round(val / s2) + "s";
  }
  return round(val, 2) + "ms";
}

// src/logger/LogController.ts
var LogController = class {
  constructor(_host) {
    this._host = _host;
    this.logLevel = false ? "warn" : "silent";
    this._disposal = new DisposalBin();
    _host.addController({
      hostConnected: this._start.bind(this),
      hostDisconnected: this._stop.bind(this)
    });
  }
  _start() {
    this._disposal.add(
      listen(this._host, "vds-log", (event) => {
        var _a3;
        event.stopPropagation();
        const eventTargetName = (((_a3 = event.path) == null ? void 0 : _a3[0]) ?? event.target).tagName.toLowerCase();
        const { level = "warn", data } = event.detail;
        if (LogLevelValue[this.logLevel] < LogLevelValue[level]) {
          return;
        }
        saveColor(eventTargetName);
        const hint = (data == null ? void 0 : data.length) === 1 && isGroupedLog(data[0]) ? data[0].title : isString(data == null ? void 0 : data[0]) ? data[0] : "";
        console.groupCollapsed(
          `%c${level.toUpperCase()}%c ${eventTargetName}%c ${hint.slice(0, 50)}${hint.length > 50 ? "..." : ""}`,
          `background: ${LogLevelColor[level]}; color: white; padding: 1.5px 2.2px; border-radius: 2px; font-size: 11px;`,
          `color: ${getColor(eventTargetName)}; padding: 4px 0px; font-size: 11px;`,
          "color: gray; font-size: 11px; padding-left: 4px;"
        );
        if ((data == null ? void 0 : data.length) === 1 && isGroupedLog(data[0])) {
          this._logGroup(level, data[0]);
        } else if (data) {
          this._log(level, ...data);
        }
        this._logTimeDiff();
        this._logStackTrace();
        console.groupEnd();
      })
    );
  }
  _stop() {
    this._lastLogTimestamp = void 0;
    this._disposal.empty();
  }
  _logGroup(level, groupedLog2) {
    console.groupCollapsed(groupedLog2.title);
    for (const log of groupedLog2.logs) {
      if (isGroupedLog(log)) {
        this._logGroup(level, log);
      } else if ("label" in log && !isUndefined(log.label)) {
        this._labelledLog(log.label, ...log.data);
      } else {
        this._log(level, ...log.data);
      }
    }
    console.groupEnd();
  }
  _log(level, ...data) {
    console[level](...data);
  }
  _labelledLog(label, ...data) {
    console.log(`%c${label}:`, "color: gray", ...data);
  }
  _logStackTrace() {
    console.groupCollapsed("%cStack Trace", "color: gray");
    console.trace();
    console.groupEnd();
  }
  _logTimeDiff() {
    this._labelledLog("Time since last log", this._getLastLogTimeDiff());
  }
  _getLastLogTimeDiff() {
    const time = performance.now();
    const diff = time - (this._lastLogTimestamp || (this._lastLogTimestamp = performance.now()));
    this._lastLogTimestamp = time;
    return ms(diff);
  }
};

// src/fullscreen/FullscreenController.ts
var FullscreenController = class {
  constructor(_host, _screenOrientationController) {
    this._host = _host;
    this._screenOrientationController = _screenOrientationController;
    this._logger = false ? new LogDispatcher(this._host) : void 0;
    this._listenerDisposal = new DisposalBin();
    _host.addController({
      hostDisconnected: this._handleHostDisconnected.bind(this)
    });
  }
  async _handleHostDisconnected() {
    if (this.isFullscreen)
      await this.exitFullscreen();
    this._listenerDisposal.empty();
  }
  get isSupported() {
    return this.isSupportedNatively;
  }
  get isSupportedNatively() {
    return import_fscreen.default.fullscreenEnabled;
  }
  get isFullscreen() {
    return this.isNativeFullscreen;
  }
  get isNativeFullscreen() {
    if (import_fscreen.default.fullscreenElement === this._host)
      return true;
    try {
      return this._host.matches(
        import_fscreen.default.fullscreenPseudoClass
      );
    } catch (error) {
      return false;
    }
  }
  _addFullscreenChangeEventListener(listener) {
    if (!this.isSupported)
      return noop;
    if (false) {
      (_a3 = this._logger) == null ? void 0 : _a3.debug("adding `fullscreenchange` listener");
    }
    const dispose = listen(import_fscreen.default, "fullscreenchange", listener);
    return () => {
      if (false) {
        (_a4 = this._logger) == null ? void 0 : _a4.debug("removing `fullscreenchange` listener");
      }
      dispose();
    };
  }
  _addFullscreenErrorEventListener(listener) {
    if (!this.isSupported)
      return noop;
    if (false) {
      (_a3 = this._logger) == null ? void 0 : _a3.debug("adding `fullscreenerror` listener");
    }
    const dispose = listen(import_fscreen.default, "fullscreenerror", listener);
    return () => {
      if (false) {
        (_a4 = this._logger) == null ? void 0 : _a4.debug("removing `fullscreenerror` listener");
      }
      dispose();
    };
  }
  async enterFullscreen() {
    if (this.isFullscreen)
      return;
    this._throwIfNoFullscreenSupport();
    if (false) {
      (_a3 = this._logger) == null ? void 0 : _a3.debug("requesting fullscreen");
    }
    this._listenerDisposal.add(
      this._addFullscreenChangeEventListener(this._handleFullscreenChange.bind(this))
    );
    this._listenerDisposal.add(
      this._addFullscreenErrorEventListener(this._handleFullscreenError.bind(this))
    );
    const response = await this._makeEnterFullscreenRequest();
    await this._lockScreenOrientation();
    return response;
  }
  async _makeEnterFullscreenRequest() {
    return import_fscreen.default.requestFullscreen(this._host);
  }
  _handleFullscreenChange(event) {
    if (!this.isFullscreen)
      this._listenerDisposal.empty();
    this._host.dispatchEvent(
      vdsEvent("vds-fullscreen-change", {
        bubbles: true,
        composed: true,
        detail: this.isFullscreen,
        triggerEvent: event
      })
    );
  }
  _handleFullscreenError(event) {
    this._host.dispatchEvent(
      vdsEvent("vds-fullscreen-error", {
        bubbles: true,
        composed: true,
        triggerEvent: event
      })
    );
  }
  async exitFullscreen() {
    if (!this.isFullscreen)
      return;
    this._throwIfNoFullscreenSupport();
    if (false) {
      (_a3 = this._logger) == null ? void 0 : _a3.debug("exiting fullscreen");
    }
    const response = await this._makeExitFullscreenRequest();
    await this._unlockScreenOrientation();
    return response;
  }
  async _makeExitFullscreenRequest() {
    return import_fscreen.default.exitFullscreen();
  }
  _shouldOrientScreen() {
    return this._screenOrientationController.canOrient && !isUndefined(this.screenOrientationLock);
  }
  async _lockScreenOrientation() {
    if (isUndefined(this.screenOrientationLock) || !this._shouldOrientScreen()) {
      return;
    }
    await this._screenOrientationController.lock(this.screenOrientationLock);
  }
  async _unlockScreenOrientation() {
    if (!this._shouldOrientScreen())
      return;
    await this._screenOrientationController.unlock();
  }
  _throwIfNoFullscreenSupport() {
    if (this.isSupported)
      return;
    throw Error("Fullscreen API is not enabled or supported in this environment.");
  }
};

// src/observers/FocusVisibleController.ts
var FocusVisibleController = class {
  constructor(_host) {
    this._host = _host;
    const disposal = new DisposalBin();
    let hadKeyboardEvent = false;
    disposal.add(
      listen(document, "pointerdown", () => {
        hadKeyboardEvent = false;
      })
    );
    eventListener(_host, "keydown", (e2) => {
      if (e2.metaKey || e2.altKey || e2.ctrlKey) {
        return;
      }
      hadKeyboardEvent = true;
    });
    eventListener(_host, "focus", (e2) => {
      if (hadKeyboardEvent) {
        _host.classList.add("focus-visible");
      }
    });
    eventListener(_host, "blur", (e2) => {
      _host.classList.remove("focus-visible");
    });
    _host.addController({
      hostDisconnected: () => {
        disposal.empty();
      }
    });
  }
};
function focusVisiblePolyfill(host) {
  return new FocusVisibleController(host);
}

// src/observers/IntersectionController.ts
var IntersectionController = class {
  constructor(_host, config = {}, _callback = () => true, _logger = false ? new LogDispatcher(_host) : void 0) {
    this._host = _host;
    this._callback = _callback;
    this._logger = _logger;
    this._skipInitial = false;
    this._unobservedUpdate = false;
    const { target, skipInitial, ...intersectionObserverInit } = config;
    this._target = target ?? void 0;
    this._skipInitial = skipInitial ?? this._skipInitial;
    if (!(typeof window !== "undefined" ? window : null)?.IntersectionObserver) {
      if (false) {
        _logger == null ? void 0 : _logger.warn(`Browser does not support \`IntersectionObserver\`.`);
      }
      return;
    }
    this._observer = new IntersectionObserver((entries) => {
      const unobservedUpdate = this._unobservedUpdate;
      this._unobservedUpdate = false;
      if (this._skipInitial && unobservedUpdate)
        return;
      this.handleChanges(entries);
      this._host.requestUpdate();
    }, intersectionObserverInit);
    _host.addController(this);
  }
  handleChanges(entries) {
    this.value = this._callback(entries, this._observer);
  }
  hostConnected() {
    if (this._target) {
      this.observe(this._target);
    }
  }
  hostDisconnected() {
    this._disconnect();
  }
  async hostUpdated() {
    const pendingRecords = this._observer.takeRecords();
    if (pendingRecords.length) {
      this.handleChanges(pendingRecords);
    }
  }
  observe(target) {
    this._observer.observe(target);
    this._unobservedUpdate = true;
    return () => {
      this._observer.unobserve(target);
    };
  }
  _disconnect() {
    this._observer.disconnect();
  }
};
function createIntersectionController(...params) {
  return new IntersectionController(...params);
}

// src/observers/PageController.ts
var IS_SAFARI2 = typeof window !== "undefined" && typeof (typeof window !== "undefined" ? window : null)?.safari === "object" && (window == null ? void 0 : (typeof window !== "undefined" ? window : null)?.safari.pushNotification);
var PageController = class {
  constructor(_host, _callback, _logger = false ? new LogDispatcher(_host) : void 0) {
    this._host = _host;
    this._callback = _callback;
    this._logger = _logger;
    this._state = this._determinePageState();
    this._visibility = document.visibilityState;
    this._disposal = new DisposalBin();
    _host.addController(this);
  }
  get state() {
    return this._state;
  }
  get visibility() {
    return this._visibility;
  }
  hostConnected() {
    const pageEvents = ["focus", "blur", "visibilitychange", "pageshow", "pagehide"];
    this._state = this._determinePageState();
    this._visibility = document.visibilityState;
    pageEvents.forEach((pageEvent) => {
      const off = listen(window, pageEvent, this._handlePageEvent.bind(this));
      this._disposal.add(off);
    });
    if (IS_SAFARI2) {
      this._disposal.add(
        listen(window, "beforeunload", (event) => {
          this._safariBeforeUnloadTimeout = setTimeout(() => {
            if (!(event.defaultPrevented || event.returnValue.length > 0)) {
              this._state = "hidden";
              this._visibility = "hidden";
              this._triggerCallback();
            }
          }, 0);
        })
      );
    }
  }
  hostDisconnected() {
    this._disposal.empty();
  }
  _handlePageEvent(event) {
    if (IS_SAFARI2) {
      (typeof window !== "undefined" ? window : null)?.clearTimeout(this._safariBeforeUnloadTimeout);
    }
    const prevState = this._state;
    const prevVisibility = this._visibility;
    if (event.type !== "blur" || this.state === "active") {
      this._state = this._determinePageState(event);
      this._visibility = document.visibilityState == "hidden" ? "hidden" : "visible";
    }
    if (this.state !== prevState || this.visibility !== prevVisibility) {
      this._triggerCallback();
    }
  }
  _triggerCallback() {
    this._callback({ state: this.state, visibility: this.visibility });
  }
  _determinePageState(event) {
    if (true)
      return "hidden";
    if ((event == null ? void 0 : event.type) === "blur" || document.visibilityState === "hidden") {
      return "hidden";
    }
    if (document.hasFocus()) {
      return "active";
    }
    return "passive";
  }
};

// src/utils/promise.ts
function deferredPromise() {
  let resolve = noop;
  let reject = noop;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
function timedPromise(promise, timeout, timeoutMsg) {
  const timer = new Promise((_2, reject) => {
    const timerId = (typeof window !== "undefined" ? window : null)?.setTimeout(() => {
      (typeof window !== "undefined" ? window : null)?.clearTimeout(timerId);
      reject(timeoutMsg);
    }, timeout);
  });
  return Promise.race([promise, timer]);
}

// src/queue/RequestQueue.ts
var RequestQueue = class {
  constructor() {
    this._requestQueue = /* @__PURE__ */ new Map();
    this._requestKeys = [];
    this._pendingFlush = deferredPromise();
    this._isServing = false;
  }
  get isServing() {
    return this._isServing;
  }
  get size() {
    return this._requestQueue.size;
  }
  async waitForFlush() {
    if (this._isServing)
      return;
    await this._pendingFlush.promise;
  }
  queue(key, callback) {
    if (this._isServing) {
      callback();
      return;
    }
    this._requestKeys = [...this._requestKeys.filter((k2) => k2 !== key), key];
    this._requestQueue.set(key, callback);
  }
  serve(key) {
    var _a3;
    (_a3 = this._requestQueue.get(key)) == null ? void 0 : _a3();
    this._requestQueue.delete(key);
  }
  start() {
    this._flush();
    this._isServing = true;
    if (this._requestQueue.size > 0) {
      this._flush();
    }
  }
  _flush() {
    for (const requestKey of this._requestKeys) {
      this.serve(requestKey);
    }
    this._requestKeys = [];
    this._release();
  }
  _empty() {
    this._requestQueue.clear();
  }
  _release() {
    this._pendingFlush.resolve();
    this._pendingFlush = deferredPromise();
  }
  stop() {
    this._isServing = false;
  }
  destroy() {
    this.stop();
    this._empty();
    this._release();
  }
};

// src/queue/host-request-queue.ts
function hostRequestQueue(host) {
  const q = new RequestQueue();
  host.addController({
    hostConnected: q.start.bind(q),
    hostDisconnected: q.destroy.bind(q)
  });
  return q;
}

// src/screen-orientation/ScreenOrientationController.ts
var ScreenOrientationController = class {
  constructor(_host) {
    this._host = _host;
    this._isScreenOrientationLocked = false;
    this._logger = false ? new LogDispatcher(this._host) : void 0;
    this._updateScreenOrientation();
    this._listenerDisposal = new DisposalBin();
    _host.addController({
      hostConnected: this._handleHostConnected.bind(this),
      hostDisconnected: this._handleHostDisconnected.bind(this)
    });
  }
  async _handleHostConnected() {
    this._updateScreenOrientation();
    this._addScreenOrientationEventListeners();
  }
  async _handleHostDisconnected() {
    if (this.canOrient && this._isScreenOrientationLocked)
      await this.unlock();
    this._listenerDisposal.empty();
  }
  get currentOrientation() {
    return this._screenOrientation;
  }
  get canOrient() {
    return canOrientScreen();
  }
  get isLocked() {
    return this._isScreenOrientationLocked;
  }
  async lock(lockType) {
    this._throwIfScreenOrientationUnavailable();
    if (false) {
      (_a3 = this._logger) == null ? void 0 : _a3.debug("locking screen orientation to", lockType);
    }
    await screen.orientation.lock(lockType);
    this._isScreenOrientationLocked = true;
    this._host.dispatchEvent(
      vdsEvent("vds-screen-orientation-lock-change", {
        bubbles: true,
        composed: true,
        detail: lockType
      })
    );
  }
  async unlock() {
    this._throwIfScreenOrientationUnavailable();
    if (false) {
      (_a3 = this._logger) == null ? void 0 : _a3.debug("unlocking screen orientation");
    }
    await screen.orientation.unlock();
    this._isScreenOrientationLocked = false;
    this._host.dispatchEvent(
      vdsEvent("vds-screen-orientation-lock-change", {
        bubbles: true,
        composed: true,
        detail: screen.orientation.type
      })
    );
  }
  _addScreenOrientationEventListeners() {
    if (!this.canOrient)
      return;
    this._listenerDisposal.add(this._addScreenOrientationChangeEventListener());
  }
  _addScreenOrientationChangeEventListener() {
    return listen(screen.orientation, "change", this._handleOrientationChange.bind(this));
  }
  _handleOrientationChange(event) {
    this._screenOrientation = (typeof window !== "undefined" ? window : null)?.screen.orientation.type;
    if (false) {
      (_a3 = this._logger) == null ? void 0 : _a3.debug("screen orientation changed to", this._screenOrientation);
    }
    this._host.dispatchEvent(
      vdsEvent("vds-screen-orientation-change", {
        bubbles: true,
        composed: true,
        detail: this._screenOrientation,
        triggerEvent: event
      })
    );
  }
  _updateScreenOrientation() {
    var _a3, _b;
    this._screenOrientation = IS_CLIENT ? (_b = (_a3 = (typeof window !== "undefined" ? window : null)?.screen) == null ? void 0 : _a3.orientation) == null ? void 0 : _b.type : void 0;
  }
  _throwIfScreenOrientationUnavailable() {
    if (this.canOrient)
      return;
    throw Error("Screen orientation API is not available.");
  }
};

// src/utils/object.ts
function keysOf(obj) {
  return Object.keys(obj);
}
function pick(obj, keys) {
  return keys.reduce(
    (newObj, key) => ({
      ...newObj,
      [key]: obj[key]
    }),
    {}
  );
}
function omit(obj, keys) {
  return keysOf(obj).filter((key) => keys.indexOf(key) < 0).reduce(
    (newObj, key) => ({
      ...newObj,
      [key]: obj[key]
    }),
    {}
  );
}
var hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var sortObjectsBy = (objects, sortKey) => objects.sort((a2, b2) => {
  if (a2[sortKey] === b2[sortKey])
    return 0;
  return a2[sortKey] < b2[sortKey] ? -1 : 1;
});

// src/stores/store-subscription.ts
function storeSubscription(host, store, onChange) {
  let consumer;
  let unsubscribe;
  const subscribe = () => {
    unsubscribe = ((consumer == null ? void 0 : consumer.value) ?? store).subscribe(onChange);
  };
  if (isContext(store)) {
    consumer = store.consume(host);
  }
  host.addController({
    hostConnected() {
      if (isContext(store)) {
        consumer.whenRegistered(subscribe);
      } else {
        subscribe();
      }
    },
    hostDisconnected() {
      unsubscribe == null ? void 0 : unsubscribe();
    }
  });
}

// src/stores/stores.ts
var subscriberQueue = [];
function readable(value, start) {
  return {
    initialValue: value,
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(newValue) {
    if (safeNotEqual(value, newValue)) {
      value = newValue;
      if (stop) {
        const runQueue = !subscriberQueue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriberQueue.push(subscriber, value);
        }
        if (runQueue) {
          for (let i2 = 0; i2 < subscriberQueue.length; i2 += 2) {
            subscriberQueue[i2][0](subscriberQueue[i2 + 1]);
          }
          subscriberQueue.length = 0;
        }
      }
    }
  }
  function update(updater) {
    set(updater(value));
  }
  function subscribe(run, invalidate = noop) {
    const subscriber = [run, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop == null ? void 0 : stop();
        stop = null;
      }
    };
  }
  return { initialValue: value, set, update, subscribe };
}
function derived(stores, fn, initialValue) {
  const single = !Array.isArray(stores);
  const storesArray = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initialValue, (set) => {
    let initialized = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = isFunction(result) ? result : noop;
      }
    };
    const unsubscribers = storesArray.map(
      (store, i2) => store.subscribe(
        (value) => {
          values[i2] = value;
          pending &= ~(1 << i2);
          if (initialized) {
            sync();
          }
        },
        () => {
          pending |= 1 << i2;
        }
      )
    );
    initialized = true;
    sync();
    return function stop() {
      unsubscribers.forEach((fn2) => fn2());
      cleanup();
    };
  });
}
function getStoreValue(store) {
  let value;
  store.subscribe((_2) => value = _2)();
  return value;
}

// src/stores/store-record.ts
function storeRecordSubscription(host, store, key, onChange) {
  if (isContext(store)) {
    const consumer = store.consume(host);
    let unsubscribe;
    const subscribe = () => {
      unsubscribe = consumer.value[key].subscribe(onChange);
    };
    host.addController({
      hostConnected: () => {
        consumer.whenRegistered(subscribe);
      },
      hostDisconnected: () => {
        unsubscribe == null ? void 0 : unsubscribe();
      }
    });
  } else {
    return storeSubscription(host, store[key], onChange);
  }
}
function copyStoreRecords(storeRecordA, storeRecordB) {
  for (const key of keysOf(storeRecordA)) {
    const storeA = storeRecordA[key];
    const storeB = storeRecordB[key];
    if (!storeA || !storeB)
      continue;
    const valA = getStoreValue(storeA);
    const valB = getStoreValue(storeB);
    if (valA !== valB)
      storeB.set(valA);
  }
}
function unwrapStoreRecord(store) {
  return new Proxy(store, {
    get(target, key) {
      return getStoreValue(target[key]);
    },
    has(target, key) {
      return Reflect.has(target, key);
    },
    ownKeys(target) {
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(target, key) {
      return Reflect.getOwnPropertyDescriptor(target, key);
    }
  });
}

// src/utils/aria.ts
function ariaBool(value) {
  return value ? "true" : "false";
}

// src/utils/array.ts
function isScalarArrayEqual(arrayA, arrayB) {
  return arrayA.length === arrayB.length && arrayA.every((value, i2) => value === arrayB[i2]);
}
function filterUnique(items, key, options = {}) {
  const seen = /* @__PURE__ */ new Set();
  return items.filter((item) => {
    var _a3;
    if (options.removeNull && isNull(item[key]))
      return false;
    if (options.removeUndefined && isUndefined(item[key]))
      return false;
    const isUnique = !seen.has(item[key]);
    if (!isUnique) {
      (_a3 = options.onDuplicateFound) == null ? void 0 : _a3.call(options, item);
    }
    seen.add(item[key]);
    return isUnique;
  });
}

// src/utils/dom.ts
function raf(callback) {
  return new Promise((resolve) => {
    const rafId = (typeof window !== "undefined" ? window : null)?.requestAnimationFrame(async () => {
      await (callback == null ? void 0 : callback());
      resolve(rafId);
    });
  });
}
function walkUpDOMTree(node, onDiscover) {
  let parent = node.parentElement;
  while (parent) {
    const skip = onDiscover(parent);
    parent = skip ? null : parent.parentElement;
  }
}
function buildExportPartsAttr(parts, prefix) {
  return parts.map(
    (part) => `${part}: ${!isFunction(prefix) ? prefix ? `${prefix}-` : "" : prefix(part)}${part}`
  ).join(", ");
}
function safelyDefineCustomElement(name, constructor, isClient = IS_CLIENT) {
  const isElementRegistered = isClient && !isUndefined((typeof window !== "undefined" ? window : null)?.customElements.get(name));
  if (!isClient || isElementRegistered)
    return;
  (typeof window !== "undefined" ? window : null)?.customElements.define(name, constructor);
}
function setAttribute(element, attrName, attrValue) {
  if (isNil(attrValue) || attrValue === false) {
    element.removeAttribute(attrName);
  } else {
    const value = isString(attrValue) ? attrValue : "";
    element.setAttribute(attrName, value);
  }
}
function setAttributeIfEmpty(element, attrName, attrValue) {
  if (!element.hasAttribute(attrName)) {
    element.setAttribute(attrName, attrValue);
  }
}
function setCSSProperty(element, name, value, prefix = "vds") {
  element.style.setProperty(`--${prefix}-${name}`, value ? value : null);
}
function getSlottedChildren(el, name) {
  var _a3;
  const selector = name ? `slot[name="${name}"]` : "slot:not([name])";
  const slot = (_a3 = el.shadowRoot) == null ? void 0 : _a3.querySelector(selector);
  const childNodes = (slot == null ? void 0 : slot.assignedNodes({ flatten: true })) ?? [];
  return Array.prototype.filter.call(childNodes, (node) => node.nodeType == Node.ELEMENT_NODE);
}
function getElementAttributes(elementCtor) {
  return new Set(elementCtor.observedAttributes);
}
function observeAttributes(element, attributes, onChange, { skipInitial = false } = {}) {
  const callback = (attrName) => {
    const attrValue = element.getAttribute(attrName);
    onChange == null ? void 0 : onChange(attrName, attrValue);
  };
  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type === "attributes") {
        callback(mutation.attributeName);
      }
    }
  });
  if (!skipInitial) {
    for (const attrName of attributes) {
      callback(attrName);
    }
  }
  observer.observe(element, {
    attributeFilter: Array.from(attributes)
  });
  return observer;
}
function requestIdleCallback(callback) {
  if (true) {
    callback();
    return;
  }
  const idle = (typeof window !== "undefined" ? window : null)?.requestIdleCallback ?? ((fn) => fn());
  if (document.readyState === "complete") {
    idle(callback);
  } else {
    (typeof window !== "undefined" ? window : null)?.addEventListener(
      "load",
      () => {
        idle(callback);
      },
      { once: true }
    );
  }
}

// src/utils/keyboard.ts
function isKeyboardEvent(event) {
  return (event == null ? void 0 : event.type.startsWith("key")) ?? false;
}
function wasEnterKeyPressed(event) {
  return isKeyboardEvent(event) && event.key === "Enter";
}
function wasEscapeKeyPressed(event) {
  return isKeyboardEvent(event) && event.key === "Escape";
}
function isKeyboardClick(event) {
  return isKeyboardEvent(event) && (event.key === "Enter" || event.key === " ");
}

// src/utils/network.ts
function tryParseJSON(json) {
  if (!isString(json))
    return void 0;
  try {
    return JSON.parse(json);
  } catch (error) {
    return void 0;
  }
}
function isObjOrJSON(value) {
  return isString(value) && value.startsWith("{") || isObject(value);
}
function objOrParseJSON(value) {
  return isObject(value) ? value : tryParseJSON(value);
}
function loadImage(src, minWidth = 1) {
  return new Promise((resolve, reject) => {
    const image = new Image();
    const handler = () => {
      image.naturalWidth >= minWidth ? resolve(image) : reject(image);
    };
    Object.assign(image, { onload: handler, onerror: handler, src });
  });
}
async function loadScript(src) {
  const hasLoaded = document.querySelector(`script[src="${src}"]`);
  if (!isNull(hasLoaded))
    return;
  const script = document.createElement("script");
  const load = deferredPromise();
  script.src = src;
  script.onload = load.resolve;
  script.onerror = load.reject;
  const firstScriptTag = document.getElementsByTagName("script")[0];
  if (!isNil(firstScriptTag.parentNode)) {
    firstScriptTag.parentNode.insertBefore(script, firstScriptTag);
  }
  return load.promise;
}
function decodeJSON(data) {
  if (!isObjOrJSON(data))
    return void 0;
  return objOrParseJSON(data);
}
function tryDecodeURIComponent(component, fallback = "", isClient = IS_CLIENT) {
  if (!isClient)
    return fallback;
  try {
    return (typeof window !== "undefined" ? window : null)?.decodeURIComponent(component);
  } catch (error) {
    return fallback;
  }
}
var QUERY_STRING_REGEX = /(?:^[#?]?|&)([^=&]+)(?:=([^&]*))?/g;
function parseQueryString(qs) {
  const params = /* @__PURE__ */ Object.create(null);
  if (isUndefined(qs))
    return params;
  let match;
  while (match = QUERY_STRING_REGEX.exec(qs)) {
    const name = tryDecodeURIComponent(match[1], match[1]).replace("[]", "");
    const value = isString(match[2]) ? tryDecodeURIComponent(match[2].replace(/\+/g, " "), match[2]) : "";
    const currValue = params[name];
    if (currValue && !isArray(currValue))
      params[name] = [currValue];
    currValue ? params[name].push(value) : params[name] = value;
  }
  return params;
}
function serializeQueryString(params) {
  const qs = [];
  const appendQueryParam = (param, v2) => {
    qs.push(`${encodeURIComponent(param)}=${encodeURIComponent(v2)}`);
  };
  Object.keys(params).forEach((param) => {
    const value = params[param];
    if (isNil(value))
      return;
    if (isArray(value)) {
      value.forEach((v2) => appendQueryParam(param, v2));
    } else {
      appendQueryParam(param, value);
    }
  });
  return qs.join("&");
}
function preconnect(url, rel = "preconnect", isClient = IS_CLIENT) {
  if (!isClient)
    return false;
  const hasLink = document.querySelector(`link[href="${url}"]`);
  if (!isNull(hasLink))
    return true;
  const link = document.createElement("link");
  link.rel = rel;
  link.href = url;
  link.crossOrigin = "true";
  document.head.append(link);
  return true;
}
function appendQueryStringToURL(url, qs) {
  if (isUndefined(qs) || qs.length === 0)
    return url;
  const mainAndQuery = url.split("?", 2);
  return mainAndQuery[0] + (!isUndefined(mainAndQuery[1]) ? `?${mainAndQuery[1]}&${qs}` : `?${qs}`);
}
function appendParamsToURL(url, params) {
  return appendQueryStringToURL(url, isObject(params) ? serializeQueryString(params) : params);
}
function decodeQueryString(qs) {
  if (!isString(qs))
    return void 0;
  return parseQueryString(qs);
}
var ScriptLoader = class {
  static async load(src) {
    return new Promise((resolve, reject) => {
      if (this.pendingRequests[src]) {
        this.pendingRequests[src].push({ resolve, reject });
        return;
      }
      this.pendingRequests[src] = [{ resolve, reject }];
      loadScript(src).then(() => {
        this.pendingRequests[src].forEach((request) => request.resolve());
        delete this.pendingRequests[src];
      }).catch((err) => {
        this.pendingRequests[src].forEach((request) => request.reject(err));
        delete this.pendingRequests[src];
      });
    });
  }
};
ScriptLoader.pendingRequests = {};

// src/utils/scroll.ts
function hideDocumentScrollbar(hidden) {
  (typeof window !== "undefined" ? window : null)?.requestAnimationFrame(() => {
    document.documentElement.classList[hidden ? "add" : "remove"]("overflow-hidden");
    document.documentElement.classList[!hidden ? "add" : "remove"]("overflow-x-hidden");
  });
}
function scrollIntoCenter(scroll, element, options = {}) {
  const scrollTop = isWindow(scroll) ? (typeof window !== "undefined" ? window : null)?.pageYOffset : scroll.scrollTop;
  const scrollHeight = isWindow(scroll) ? (typeof window !== "undefined" ? window : null)?.innerHeight : scroll.getBoundingClientRect().height;
  const elementRect = element.getBoundingClientRect();
  const center = elementRect.top + scrollTop - scrollHeight / 2;
  scroll.scrollTo({
    top: center + ((options == null ? void 0 : options.offset) ?? 0),
    behavior: options.behaviour
  });
}

// src/utils/string.ts
var escapeQuotes = (str) => str.replace(/^"+|"+$/g, "").replace(/^'+|'+$/g, "");
var normalizeLineBreaks = (str) => str.replace(/\\r/g, "\n");
function splitLineBreaks(str) {
  if (typeof str !== "string")
    return [];
  return normalizeLineBreaks(str).split("\n");
}
function uppercaseFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function lowercaseFirstLetter(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
function kebabToTitleCase(str) {
  return uppercaseFirstLetter(str.replace(/-./g, (x2) => " " + x2[1].toUpperCase()));
}
function camelToKebabCase(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function kebabToCamelCase(str) {
  return str.replace(/-./g, (x2) => x2[1].toUpperCase());
}
function kebabToPascalCase(str) {
  return kebabToTitleCase(str).replace(/\s/g, "");
}
function camelToTitleCase(str) {
  return uppercaseFirstLetter(str.replace(/([A-Z])/g, " $1"));
}

// src/utils/time.ts
function padNumberWithZeroes(num, expectedLength) {
  const str = String(num);
  const actualLength = str.length;
  const shouldPad = actualLength < expectedLength;
  if (shouldPad) {
    const padLength = expectedLength - actualLength;
    const padding = `0`.repeat(padLength);
    return `${padding}${num}`;
  }
  return str;
}
var TimeUnit = /* @__PURE__ */ ((TimeUnit2) => {
  TimeUnit2["Hours"] = "hours";
  TimeUnit2["Minutes"] = "minutes";
  TimeUnit2["Seconds"] = "seconds";
  TimeUnit2["Fraction"] = "fraction";
  return TimeUnit2;
})(TimeUnit || {});
function parseTime(duration) {
  const hours = Math.trunc(duration / 3600);
  const minutes = Math.trunc(duration % 3600 / 60);
  const seconds = Math.trunc(duration % 60);
  const fraction = Number((duration - Math.trunc(duration)).toPrecision(3));
  return {
    ["hours" /* Hours */]: hours,
    ["minutes" /* Minutes */]: minutes,
    ["seconds" /* Seconds */]: seconds,
    ["fraction" /* Fraction */]: fraction
  };
}
function formatTime(duration, shouldPadHours = false, shouldAlwaysShowHours = false) {
  const { hours, minutes, seconds } = parseTime(duration);
  const paddedHours = shouldPadHours ? padNumberWithZeroes(hours, 2) : hours;
  const paddedMinutes = padNumberWithZeroes(minutes, 2);
  const paddedSeconds = padNumberWithZeroes(seconds, 2);
  if (hours > 0 || shouldAlwaysShowHours) {
    return `${paddedHours}:${paddedMinutes}:${paddedSeconds}`;
  }
  return `${minutes}:${paddedSeconds}`;
}
function formatSpokenTime(duration) {
  const spokenParts = [];
  const { hours, minutes, seconds } = parseTime(duration);
  const pluralize = (num, word) => num === 1 ? word : `${word}s`;
  if (hours > 0) {
    spokenParts.push(`${hours} ${pluralize(hours, "hour")}`);
  }
  if (minutes > 0) {
    spokenParts.push(`${minutes} ${pluralize(minutes, "minute")}`);
  }
  if (seconds > 0 || spokenParts.length === 0) {
    spokenParts.push(`${seconds} ${pluralize(seconds, "second")}`);
  }
  return spokenParts.join(", ");
}
function formatHtml5Duration(duration) {
  const { hours, minutes, seconds, fraction } = parseTime(duration);
  return `PT${hours}H${minutes}M${seconds + fraction}S`;
}

// ../../node_modules/.pnpm/just-debounce-it@3.1.1/node_modules/just-debounce-it/index.mjs
var functionDebounce = debounce;
function debounce(fn, wait2, callFirst) {
  var timeout = null;
  var debouncedFn = null;
  var clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      debouncedFn = null;
      timeout = null;
    }
  };
  var flush = function() {
    var call = debouncedFn;
    clear();
    if (call) {
      call();
    }
  };
  var debounceWrapper = function() {
    if (!wait2) {
      return fn.apply(this, arguments);
    }
    var context = this;
    var args = arguments;
    var callNow = callFirst && !timeout;
    clear();
    debouncedFn = function() {
      fn.apply(context, args);
    };
    timeout = setTimeout(function() {
      timeout = null;
      if (!callNow) {
        var call = debouncedFn;
        debouncedFn = null;
        return call();
      }
    }, wait2);
    if (callNow) {
      return debouncedFn();
    }
  };
  debounceWrapper.cancel = clear;
  debounceWrapper.flush = flush;
  return debounceWrapper;
}

// ../../node_modules/.pnpm/just-throttle@4.1.1/node_modules/just-throttle/index.mjs
var functionThrottle = throttle;
function throttle(fn, interval, options) {
  var timeoutId = null;
  var throttledFn = null;
  var leading = options && options.leading;
  var trailing = options && options.trailing;
  if (leading == null) {
    leading = true;
  }
  if (trailing == null) {
    trailing = !leading;
  }
  if (leading == true) {
    trailing = false;
  }
  var cancel = function() {
    if (timeoutId) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  var flush = function() {
    var call = throttledFn;
    cancel();
    if (call) {
      call();
    }
  };
  var throttleWrapper = function() {
    var callNow = leading && !timeoutId;
    var context = this;
    var args = arguments;
    throttledFn = function() {
      return fn.apply(context, args);
    };
    if (!timeoutId) {
      timeoutId = setTimeout(function() {
        timeoutId = null;
        if (trailing) {
          return throttledFn();
        }
      }, interval);
    }
    if (callNow) {
      callNow = false;
      return throttledFn();
    }
  };
  throttleWrapper.cancel = cancel;
  throttleWrapper.flush = flush;
  return throttleWrapper;
}

// src/utils/timing.ts
function wait(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
function rafThrottle(func) {
  let rafId;
  const pending = () => !isUndefined(rafId);
  const cancel = () => {
    if (isUndefined(rafId))
      return;
    (typeof window !== "undefined" ? window : null)?.cancelAnimationFrame(rafId);
    rafId = void 0;
  };
  function throttled(...args) {
    if (pending())
      return;
    rafId = (typeof window !== "undefined" ? window : null)?.requestAnimationFrame(() => {
      func.apply(this, args);
      rafId = void 0;
    });
  }
  throttled.cancel = cancel;
  throttled.pending = pending;
  return throttled;
}
export {
  ContextConsumerController,
  ContextProviderController,
  DisposalBin,
  FocusVisibleController,
  FullscreenController,
  GROUPED_LOG_ID,
  IS_ANDROID,
  IS_CHROME,
  IS_CLIENT,
  IS_FIREFOX,
  IS_IOS,
  IS_IPHONE,
  IS_MOBILE,
  IS_SAFARI,
  IntersectionController,
  LogController,
  LogDispatcher,
  LogLevelColor,
  LogLevelValue,
  ORIGIN,
  PageController,
  RequestQueue,
  ScreenOrientationController,
  ScriptLoader,
  TimeUnit,
  UA,
  VdsEvent,
  WithFocus,
  adoptOrphans,
  appendParamsToURL,
  appendQueryStringToURL,
  appendTriggerEvent,
  ariaBool,
  buildExportPartsAttr,
  camelToKebabCase,
  camelToTitleCase,
  canAutoplay,
  canFullscreenVideo,
  canObserveIntersection,
  canOrientScreen,
  canPlayHLSNatively,
  canRotateScreen,
  canUsePiP,
  canUsePiPInChrome,
  canUsePiPInSafari,
  clampNumber,
  copyStoreRecords,
  createContext,
  createIntersectionController,
  createRegex,
  currentSafariVersion,
  functionDebounce as debounce,
  decodeJSON,
  decodeQueryString,
  deferredPromise,
  derived,
  discover,
  discoverable,
  equal,
  escapeQuotes,
  eventListener,
  filterUnique,
  findTriggerEvent,
  focusVisiblePolyfill,
  focusableSelector,
  formatHtml5Duration,
  formatSpokenTime,
  formatTime,
  getStoreValue as get,
  getElementAttributes,
  getMediaSource,
  getNumberOfDecimalPlaces,
  getOriginEvent,
  getSlottedChildren,
  getSourceBuffer,
  groupedLog,
  hasOwnProperty,
  hasTriggerEvent,
  hideDocumentScrollbar,
  hostRequestQueue,
  ifNonEmpty,
  ifNumber,
  isArray,
  isBoolean,
  isContext,
  isFunction,
  isGroupedLog,
  isHlsjsSupported,
  isKeyboardClick,
  isKeyboardEvent,
  isMouseEvent,
  isNil,
  isNull,
  isNumber,
  isObjOrJSON,
  isObject,
  isPointerEvent,
  isReducedMotionPreferred,
  isScalarArrayEqual,
  isString,
  isTouchEvent,
  isUndefined,
  isVdsEvent,
  isWindow,
  kebabToCamelCase,
  kebabToPascalCase,
  kebabToTitleCase,
  keysOf,
  listen,
  loadImage,
  loadScript,
  logElementLifecycle,
  logEvent,
  lowercaseFirstLetter,
  noop,
  normalizeLineBreaks,
  notEqual,
  objOrParseJSON,
  observeAttributes,
  omit,
  padNumberWithZeroes,
  parseQueryString,
  parseTime,
  pick,
  preconnect,
  raf,
  rafThrottle,
  readable,
  redispatchEvent,
  requestIdleCallback,
  round,
  safeNotEqual,
  safelyDefineCustomElement,
  scrollIntoCenter,
  serializeQueryString,
  setAttribute,
  setAttributeIfEmpty,
  setCSSProperty,
  sortObjectsBy,
  splitLineBreaks,
  storeRecordSubscription,
  storeSubscription,
  functionThrottle as throttle,
  timedPromise,
  tryDecodeURIComponent,
  tryParseJSON,
  unwrapStoreRecord,
  uppercaseFirstLetter,
  vdsEvent,
  wait,
  waitForEvent,
  walkTriggerEventChain,
  walkUpDOMTree,
  wasEnterKeyPressed,
  wasEscapeKeyPressed,
  writable
};
