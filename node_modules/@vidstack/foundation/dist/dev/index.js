// src/utils/events.ts
function listen(target, type, listener, options) {
  target.addEventListener(type, listener, options);
  return () => {
    target.removeEventListener(type, listener, options);
  };
}
function eventTypeIncludes(event, types) {
  return types.some((type) => event?.type.includes(type) ?? false);
}
function isPointerEvent(event) {
  return eventTypeIncludes(event, ["pointer"]);
}
function isTouchEvent(event) {
  return eventTypeIncludes(event, ["touch"]);
}
function isMouseEvent(event) {
  return eventTypeIncludes(event, ["click", "mouse"]);
}
async function waitForEvent(target, type, options) {
  return new Promise((resolve, reject) => {
    const timerId = window.setTimeout(() => {
      reject(`Timed out waiting for event \`${type}\`.`);
    }, options?.timeout ?? 1e3);
    listen(
      target,
      type,
      (event) => {
        window.clearTimeout(timerId);
        resolve(event);
      },
      options
    );
  });
}
var DisposalBin = class {
  constructor() {
    this._disposal = this._disposal ?? [];
  }
  add(...callbacks) {
    if (callbacks) {
      callbacks.forEach((cb) => {
        this._disposal.push(cb);
      });
    }
  }
  empty() {
    this._disposal.forEach((fn) => fn());
    this._disposal = [];
  }
};

// src/events/event-listener.ts
function eventListener(host, type, listener, options) {
  let off;
  function attach() {
    if (!off) {
      off = listen(options?.target ?? host, type, listener, options);
    }
  }
  attach();
  host.addController({
    hostConnected() {
      attach();
    },
    hostDisconnected() {
      off?.();
      off = void 0;
    }
  });
}

// src/events/VdsEvent.ts
var VdsEvent = class extends CustomEvent {
  constructor(type, eventInit = {}) {
    super(type, eventInit);
    this.triggerEvent = eventInit.triggerEvent;
    if (!this.hasOwnProperty("originEvent")) {
      Object.defineProperties(this, {
        originEvent: {
          get() {
            return getOriginEvent(this) ?? this;
          }
        },
        isOriginTrusted: {
          get() {
            return getOriginEvent(this)?.isTrusted ?? false;
          }
        }
      });
    }
  }
  get originEvent() {
    return getOriginEvent(this) ?? this;
  }
  get isOriginTrusted() {
    return this.originEvent?.isTrusted ?? false;
  }
};
function vdsEvent(type, eventInit = {}) {
  return new VdsEvent(type, eventInit);
}
function isVdsEvent(event) {
  return event?.hasOwnProperty("triggerEvent") ?? false;
}
function getOriginEvent(event) {
  let triggerEvent = event.triggerEvent;
  while (triggerEvent && triggerEvent.triggerEvent) {
    triggerEvent = triggerEvent.triggerEvent;
  }
  return triggerEvent;
}
function walkTriggerEventChain(event, callback) {
  if (!isVdsEvent(event))
    return;
  let triggerEvent = event.triggerEvent;
  while (triggerEvent && triggerEvent.triggerEvent) {
    const returnValue = callback(triggerEvent);
    if (returnValue)
      return [triggerEvent, returnValue];
    triggerEvent = triggerEvent.triggerEvent;
  }
  return;
}
function findTriggerEvent(event, eventType) {
  return walkTriggerEventChain(event, (e) => e.type === eventType)?.[0];
}
function hasTriggerEvent(event, eventType) {
  return !!findTriggerEvent(event, eventType);
}
function appendTriggerEvent(event, triggerEvent) {
  (getOriginEvent(event) ?? event).triggerEvent = triggerEvent;
}

// src/events/redispatch.ts
function redispatchEvent(target, event) {
  if (event.bubbles && event.composed)
    return;
  const newEvent = new VdsEvent(event.type, {
    triggerEvent: event.triggerEvent ?? event,
    detail: event.detail,
    bubbles: event.bubbles,
    cancelable: event.cancelable,
    composed: event.composed
  });
  target.dispatchEvent(newEvent);
}

// src/context/ContextConsumerController.ts
var orphanConsumers = /* @__PURE__ */ new Map();
var ContextConsumerController = class {
  constructor(_host, initialValue, _options) {
    this._host = _host;
    this.initialValue = initialValue;
    this._options = _options;
    this._registrationCallbacks = [];
    _host.addController({
      hostConnected: () => {
        this._connect();
      },
      hostDisconnected: () => {
        delete this._host[this.id];
      }
    });
  }
  get id() {
    return this._options.id;
  }
  get value() {
    return this._host[this.id] ?? this.initialValue;
  }
  get registered() {
    return this.id in this._host;
  }
  _connect() {
    if (this.id in this._host)
      return;
    const setValue = (value) => {
      this._host[this.id] = value;
      this._registrationCallbacks?.forEach((fn) => fn(value));
      this._registrationCallbacks = void 0;
    };
    this._host.dispatchEvent(
      vdsEvent("vds-context-consumer-connect", {
        bubbles: true,
        composed: true,
        detail: {
          id: this.id,
          setValue
        }
      })
    );
    if (!this.registered) {
      const orphans = orphanConsumers.get(this.id) ?? [];
      orphans.push({ host: this._host, setValue });
      orphanConsumers.set(this.id, orphans);
    }
  }
  whenRegistered(callback) {
    if (this.registered) {
      callback(this.value);
      return;
    }
    this._registrationCallbacks?.push(callback);
  }
};
function adoptOrphans(id, provider) {
  const orphans = orphanConsumers.get(id) ?? [];
  const adoptees = orphans.filter(({ host }) => provider.contains(host));
  orphanConsumers.set(
    id,
    orphans.filter(({ host }) => !provider.contains(host))
  );
  return adoptees;
}

// src/context/ContextProviderController.ts
var ContextProviderController = class {
  constructor(_host, _initValue, _options) {
    this._host = _host;
    this._initValue = _initValue;
    this._options = _options;
    this._stopDisposal = new DisposalBin();
    this._value = _initValue();
    _host.addController({
      hostConnected: this.start.bind(this),
      hostDisconnected: this.stop.bind(this)
    });
  }
  get id() {
    return this._options.id;
  }
  get value() {
    return this._value;
  }
  start() {
    const dispose = listen(
      this._host,
      "vds-context-consumer-connect",
      this._handleConsumerConnect.bind(this)
    );
    for (const orphan of adoptOrphans(this.id, this._host)) {
      orphan.setValue(this._value);
    }
    this._stopDisposal.add(dispose);
  }
  stop() {
    this._stopDisposal.empty();
  }
  _handleConsumerConnect(event) {
    const consumer = event.detail;
    if (consumer.id !== this.id)
      return;
    event.stopImmediatePropagation();
    consumer.setValue(this._value);
  }
};

// src/context/context.ts
function createContext(initValue) {
  const id = Symbol("@vidstack/context");
  return {
    id,
    consume(host) {
      return new ContextConsumerController(host, initValue(), { id });
    },
    provide(host) {
      return new ContextProviderController(host, initValue, { id });
    }
  };
}
function isContext(context) {
  return typeof context?.id === "symbol" && context.id.description === "@vidstack/context";
}

// src/directives/if-non-empty.ts
import { ifDefined } from "lit/directives/if-defined.js";
function ifNonEmpty(value) {
  return ifDefined(value === "" || value === "undefined" ? void 0 : value);
}

// src/directives/if-number.ts
import { ifDefined as ifDefined2 } from "lit/directives/if-defined.js";

// src/utils/unit.ts
function noop(...args) {
}
function notEqual(valueA, valueB) {
  return valueB !== valueA && (valueB === valueB || valueA === valueA);
}
function safeNotEqual(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function equal(valueA, valueB) {
  return !notEqual(valueA, valueB);
}
function isNull(value) {
  return value === null;
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isNil(value) {
  return isNull(value) || isUndefined(value);
}
function isObject(value) {
  return value?.constructor === Object;
}
function isNumber(value) {
  return typeof value === "number" && !Number.isNaN(value);
}
function isString(value) {
  return typeof value === "string";
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isFunction(value) {
  return typeof value === "function";
}
function isArray(value) {
  return Array.isArray(value);
}
function createRegex(regex) {
  return isString(regex) ? new RegExp(regex) : regex;
}
function isWindow(value) {
  return value === window;
}

// src/directives/if-number.ts
function ifNumber(value) {
  return ifDefined2(isNumber(value) ? value : void 0);
}

// src/elements/discovery/discover.ts
var discoverers = /* @__PURE__ */ new Map();
var discoverables = /* @__PURE__ */ new Map();
function connect(discoverable2, id, onDisconnect) {
  for (const { host, callback } of Array.from(discoverers.get(id) ?? [])) {
    if (host !== discoverable2 && host.contains(discoverable2)) {
      callback(discoverable2, onDisconnect);
    }
  }
}
function find(host, id) {
  return Array.from(discoverables.get(id) ?? []).filter(
    ({ element }) => host !== element && host.contains(element)
  );
}
function discover(host, id, callback) {
  const discoverer = { host, callback };
  host.addController({
    hostConnected: () => {
      for (const { element, onDisconnect } of find(host, id)) {
        callback(element, onDisconnect);
      }
      discoverers.set(id, (discoverers.get(id) ?? /* @__PURE__ */ new Set()).add(discoverer));
    },
    hostDisconnected: () => {
      discoverers.get(id)?.delete(discoverer);
    }
  });
}
function discoverable(host, eventType, options = {}) {
  const id = options.register;
  const disconnectDisposal = new DisposalBin();
  const onDisconnect = (callback) => {
    disconnectDisposal.add(callback);
  };
  const discoverable2 = {
    element: host,
    onDisconnect
  };
  host.addController({
    hostConnected() {
      const event = vdsEvent(eventType, {
        bubbles: true,
        composed: true,
        detail: discoverable2
      });
      host.dispatchEvent(event);
      if (id) {
        discoverables.set(id, (discoverables.get(id) ?? /* @__PURE__ */ new Set()).add(discoverable2));
        connect(host, id, onDisconnect);
      }
    },
    hostDisconnected() {
      disconnectDisposal.empty();
      if (id) {
        discoverables.get(id)?.delete(discoverable2);
      }
    }
  });
}

// src/utils/support.ts
var IS_CLIENT = typeof window !== "undefined";
var UA = IS_CLIENT ? window.navigator?.userAgent.toLowerCase() : "";
var IS_IOS = /iphone|ipad|ipod|ios|CriOS|FxiOS/.test(UA);
var IS_ANDROID = /android/.test(UA);
var IS_MOBILE = IS_CLIENT && (IS_IOS || IS_ANDROID);
var IS_IPHONE = IS_CLIENT && /(iPhone|iPod)/gi.test(window.navigator?.platform);
var IS_FIREFOX = /firefox/.test(UA);
var IS_CHROME = IS_CLIENT && !!window.chrome;
var IS_SAFARI = IS_CLIENT && !IS_CHROME && (window.safari || IS_IOS || /(apple|safari)/.test(UA));
var ORIGIN = IS_CLIENT && window.location.protocol !== "file:" ? `${window.location.protocol}//${window.location.hostname}` : void 0;
function currentSafariVersion() {
  return IS_CLIENT ? Number((/Safari\/(\d+)/.exec(navigator.userAgent) ?? ["", 0])[1]) : 0;
}
function canFullscreenVideo() {
  if (!IS_CLIENT)
    return false;
  const video = document.createElement("video");
  return isFunction(video.webkitEnterFullscreen);
}
function canObserveIntersection() {
  return IS_CLIENT && !isUndefined(window.IntersectionObserver);
}
function canOrientScreen() {
  return IS_CLIENT && !isUndefined(screen.orientation) && isFunction(screen.orientation.lock) && isFunction(screen.orientation.unlock);
}
function canRotateScreen() {
  return IS_CLIENT && !isUndefined(window.screen.orientation) && !isUndefined(window.screen.orientation.lock);
}
function isReducedMotionPreferred() {
  return IS_CLIENT && "matchMedia" in window && window.matchMedia("(prefers-reduced-motion)").matches;
}
function canPlayHLSNatively() {
  if (!IS_CLIENT)
    return false;
  const video = document.createElement("video");
  return video.canPlayType("application/vnd.apple.mpegurl").length > 0;
}
function canUsePiPInChrome() {
  if (!IS_CLIENT)
    return false;
  const video = document.createElement("video");
  return !!document.pictureInPictureEnabled && !video.disablePictureInPicture;
}
function canUsePiPInSafari() {
  if (!IS_CLIENT)
    return false;
  const video = document.createElement("video");
  return isFunction(video.webkitSupportsPresentationMode) && isFunction(video.webkitSetPresentationMode) && !IS_IPHONE;
}
function canUsePiP() {
  return canUsePiPInChrome() || canUsePiPInSafari();
}
function canAutoplay(muted = true, playsinline = true) {
  if (!IS_CLIENT)
    return Promise.resolve(false);
  const video = document.createElement("video");
  if (muted) {
    video.setAttribute("muted", "");
    video.muted = true;
  }
  if (playsinline) {
    video.setAttribute("playsinline", "");
    video.setAttribute("webkit-playsinline", "");
  }
  video.setAttribute("height", "0");
  video.setAttribute("width", "0");
  video.style.position = "fixed";
  video.style.top = "0";
  video.style.width = "0";
  video.style.height = "0";
  video.style.opacity = "0";
  new Promise((resolve) => resolve(video.play())).catch(noop);
  return Promise.resolve(!video.paused);
}
function getMediaSource() {
  return window?.MediaSource ?? window?.WebKitMediaSource;
}
function getSourceBuffer() {
  return window?.SourceBuffer ?? window?.WebKitSourceBuffer;
}
function isHlsjsSupported() {
  const mediaSource = getMediaSource();
  if (isUndefined(mediaSource)) {
    return false;
  }
  const isTypeSupported = mediaSource && isFunction(mediaSource.isTypeSupported) && mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
  const sourceBuffer = getSourceBuffer();
  const isSourceBufferValid = isUndefined(sourceBuffer) || !isUndefined(sourceBuffer.prototype) && isFunction(sourceBuffer.prototype.appendBuffer) && isFunction(sourceBuffer.prototype.remove);
  return !!isTypeSupported && !!isSourceBufferValid;
}

// src/elements/WithFocus.ts
var focusableSelector = `
  ${[
  "a[href]",
  "area[href]",
  `input:not([disabled]):not([tabindex='-1'])`,
  `button:not([disabled]):not([tabindex='-1'])`,
  `select:not([disabled]):not([tabindex='-1'])`,
  `textarea:not([disabled]):not([tabindex='-1'])`,
  "iframe",
  "object",
  "embed",
  `*[tabindex]:not([tabindex='-1'])`,
  "*[contenteditable=true]",
  "vds-fullscreen-button",
  "vds-mute-button",
  "vds-play-button",
  "vds-slider",
  "vds-time-slider",
  "vds-volume-slider"
].join(", ")}
`;
function WithFocus(Base) {
  return class WithFocusMixin extends Base {
    static get shadowRootOptions() {
      return {
        ...Base.shadowRootOptions,
        delegatesFocus: currentSafariVersion() <= 537
      };
    }
    focus() {
      if (this.shadowRoot?.delegatesFocus) {
        super.focus();
      } else {
        const delegateTarget = this.shadowRoot?.querySelector(focusableSelector) || this.querySelector(focusableSelector);
        if (delegateTarget) {
          delegateTarget.focus();
        } else {
          super.focus();
        }
      }
    }
  };
}

// ../../node_modules/.pnpm/fscreen@1.2.0/node_modules/fscreen/dist/fscreen.esm.js
var key = {
  fullscreenEnabled: 0,
  fullscreenElement: 1,
  requestFullscreen: 2,
  exitFullscreen: 3,
  fullscreenchange: 4,
  fullscreenerror: 5,
  fullscreen: 6
};
var webkit = [
  "webkitFullscreenEnabled",
  "webkitFullscreenElement",
  "webkitRequestFullscreen",
  "webkitExitFullscreen",
  "webkitfullscreenchange",
  "webkitfullscreenerror",
  "-webkit-full-screen"
];
var moz = [
  "mozFullScreenEnabled",
  "mozFullScreenElement",
  "mozRequestFullScreen",
  "mozCancelFullScreen",
  "mozfullscreenchange",
  "mozfullscreenerror",
  "-moz-full-screen"
];
var ms = [
  "msFullscreenEnabled",
  "msFullscreenElement",
  "msRequestFullscreen",
  "msExitFullscreen",
  "MSFullscreenChange",
  "MSFullscreenError",
  "-ms-fullscreen"
];
var document2 = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
var vendor = "fullscreenEnabled" in document2 && Object.keys(key) || webkit[0] in document2 && webkit || moz[0] in document2 && moz || ms[0] in document2 && ms || [];
var fscreen = {
  requestFullscreen: function(element) {
    return element[vendor[key.requestFullscreen]]();
  },
  requestFullscreenFunction: function(element) {
    return element[vendor[key.requestFullscreen]];
  },
  get exitFullscreen() {
    return document2[vendor[key.exitFullscreen]].bind(document2);
  },
  get fullscreenPseudoClass() {
    return ":" + vendor[key.fullscreen];
  },
  addEventListener: function(type, handler, options) {
    return document2.addEventListener(vendor[key[type]], handler, options);
  },
  removeEventListener: function(type, handler, options) {
    return document2.removeEventListener(vendor[key[type]], handler, options);
  },
  get fullscreenEnabled() {
    return Boolean(document2[vendor[key.fullscreenEnabled]]);
  },
  set fullscreenEnabled(val) {
  },
  get fullscreenElement() {
    return document2[vendor[key.fullscreenElement]];
  },
  set fullscreenElement(val) {
  },
  get onfullscreenchange() {
    return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()];
  },
  set onfullscreenchange(handler) {
    return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()] = handler;
  },
  get onfullscreenerror() {
    return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()];
  },
  set onfullscreenerror(handler) {
    return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()] = handler;
  }
};
var fscreen_esm_default = fscreen;

// src/logger/events.ts
function logEvent(level, ...data) {
  return vdsEvent("vds-log", {
    bubbles: true,
    composed: true,
    detail: {
      level,
      data
    }
  });
}

// src/logger/grouped-log.ts
var GROUPED_LOG_ID = Symbol("@vidstack/grouped-log");
function isGroupedLog(data) {
  return isObject(data) && data[GROUPED_LOG_ID] === true;
}
function groupedLog(title, parent) {
  const logs = [];
  const group = {
    [GROUPED_LOG_ID]: true,
    title,
    logs,
    log(...data) {
      logs.push({ data });
      return group;
    },
    labelledLog(label, ...data) {
      logs.push({ label, data });
      return group;
    },
    groupStart(title2) {
      return groupedLog(title2, group);
    },
    groupEnd() {
      parent?.logs.push(group);
      return parent ?? group;
    }
  };
  return group;
}

// src/logger/LogDispatcher.ts
var LogDispatcher = class {
  constructor(_host) {
    this._host = _host;
  }
  error(...data) {
    this._dispatch("error", ...data);
  }
  warn(...data) {
    this._dispatch("warn", ...data);
  }
  info(...data) {
    this._dispatch("info", ...data);
  }
  debug(...data) {
    this._dispatch("debug", ...data);
  }
  errorGroup(title) {
    return this._groupDispatcher("error", title);
  }
  warnGroup(title) {
    return this._groupDispatcher("warn", title);
  }
  infoGroup(title) {
    return this._groupDispatcher("info", title);
  }
  debugGroup(title) {
    return this._groupDispatcher("debug", title);
  }
  _dispatch(level, ...data) {
    this._host.dispatchEvent(logEvent(level, ...data));
  }
  _groupDispatcher(level, title, rootGroup, parentGroup) {
    const group = groupedLog(title, parentGroup);
    group.dispatch = () => {
      this._dispatch(level, rootGroup ?? group);
    };
    return {
      ...group,
      groupStart: (title2) => {
        return this._groupDispatcher(level, title2, rootGroup ?? group, group);
      }
    };
  }
};

// src/logger/log-lifecycle.ts
function logElementLifecycle(_host) {
  const logger = new LogDispatcher(_host);
  _host.addController({
    hostConnected() {
      logger.debug("\u{1F517} connected");
    },
    hostUpdated() {
      logger.debug("\u{1F504} updated");
    },
    hostDisconnected() {
      logger.debug("\u{1F5D1}\uFE0F disconnected");
    }
  });
}

// src/logger/colors.ts
var LOCAL_STORAGE_KEY = "@vidstack/log-colors";
var colors = getSavedColors();
function getSavedColors() {
  if (IS_CLIENT && !isUndefined(window.localStorage)) {
    let colors2 = {};
    try {
      colors2 = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) ?? "");
    } catch {
    }
    return new Map(Object.entries(colors2));
  }
  return /* @__PURE__ */ new Map();
}
function getColor(key2) {
  return colors.get(key2);
}
function saveColor(key2, { color = generateColor(), overwrite = false } = {}) {
  if (!colors.has(key2) || overwrite) {
    colors.set(key2, color);
    saveColors();
  }
}
function generateColor() {
  return `hsl(${Math.random() * 360}, 55%, 70%)`;
}
function saveColors() {
  if (IS_CLIENT && !isUndefined(window.localStorage)) {
    const map = {};
    colors.forEach(function(value, key2) {
      map[key2] = value;
    });
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(map));
  }
}

// src/logger/LogLevel.ts
var LogLevelValue = Object.freeze({
  silent: 0,
  error: 1,
  warn: 2,
  info: 3,
  debug: 4
});
var LogLevelColor = Object.freeze({
  silent: "white",
  error: "hsl(6, 58%, 50%)",
  warn: "hsl(51, 58%, 50%)",
  info: "hsl(219, 58%, 50%)",
  debug: "hsl(280, 58%, 50%)"
});

// src/utils/number.ts
function round(num, decimalPlaces = 2) {
  return Number(num.toFixed(decimalPlaces));
}
function clampNumber(min, value, max) {
  return Math.max(min, Math.min(max, value));
}
function getNumberOfDecimalPlaces(num) {
  return String(num).split(".")[1]?.length ?? 0;
}

// src/logger/ms.ts
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
function ms2(val) {
  const msAbs = Math.abs(val);
  if (msAbs >= d) {
    return Math.round(val / d) + "d";
  }
  if (msAbs >= h) {
    return Math.round(val / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(val / m) + "m";
  }
  if (msAbs >= s) {
    return Math.round(val / s) + "s";
  }
  return round(val, 2) + "ms";
}

// src/logger/LogController.ts
var LogController = class {
  constructor(_host) {
    this._host = _host;
    this.logLevel = true ? "warn" : "silent";
    this._disposal = new DisposalBin();
    _host.addController({
      hostConnected: this._start.bind(this),
      hostDisconnected: this._stop.bind(this)
    });
  }
  _start() {
    this._disposal.add(
      listen(this._host, "vds-log", (event) => {
        event.stopPropagation();
        const eventTargetName = (event.path?.[0] ?? event.target).tagName.toLowerCase();
        const { level = "warn", data } = event.detail;
        if (LogLevelValue[this.logLevel] < LogLevelValue[level]) {
          return;
        }
        saveColor(eventTargetName);
        const hint = data?.length === 1 && isGroupedLog(data[0]) ? data[0].title : isString(data?.[0]) ? data[0] : "";
        console.groupCollapsed(
          `%c${level.toUpperCase()}%c ${eventTargetName}%c ${hint.slice(0, 50)}${hint.length > 50 ? "..." : ""}`,
          `background: ${LogLevelColor[level]}; color: white; padding: 1.5px 2.2px; border-radius: 2px; font-size: 11px;`,
          `color: ${getColor(eventTargetName)}; padding: 4px 0px; font-size: 11px;`,
          "color: gray; font-size: 11px; padding-left: 4px;"
        );
        if (data?.length === 1 && isGroupedLog(data[0])) {
          this._logGroup(level, data[0]);
        } else if (data) {
          this._log(level, ...data);
        }
        this._logTimeDiff();
        this._logStackTrace();
        console.groupEnd();
      })
    );
  }
  _stop() {
    this._lastLogTimestamp = void 0;
    this._disposal.empty();
  }
  _logGroup(level, groupedLog2) {
    console.groupCollapsed(groupedLog2.title);
    for (const log of groupedLog2.logs) {
      if (isGroupedLog(log)) {
        this._logGroup(level, log);
      } else if ("label" in log && !isUndefined(log.label)) {
        this._labelledLog(log.label, ...log.data);
      } else {
        this._log(level, ...log.data);
      }
    }
    console.groupEnd();
  }
  _log(level, ...data) {
    console[level](...data);
  }
  _labelledLog(label, ...data) {
    console.log(`%c${label}:`, "color: gray", ...data);
  }
  _logStackTrace() {
    console.groupCollapsed("%cStack Trace", "color: gray");
    console.trace();
    console.groupEnd();
  }
  _logTimeDiff() {
    this._labelledLog("Time since last log", this._getLastLogTimeDiff());
  }
  _getLastLogTimeDiff() {
    const time = performance.now();
    const diff = time - (this._lastLogTimestamp || (this._lastLogTimestamp = performance.now()));
    this._lastLogTimestamp = time;
    return ms2(diff);
  }
};

// src/fullscreen/FullscreenController.ts
var FullscreenController = class {
  constructor(_host, _screenOrientationController) {
    this._host = _host;
    this._screenOrientationController = _screenOrientationController;
    this._logger = true ? new LogDispatcher(this._host) : void 0;
    this._listenerDisposal = new DisposalBin();
    _host.addController({
      hostDisconnected: this._handleHostDisconnected.bind(this)
    });
  }
  async _handleHostDisconnected() {
    if (this.isFullscreen)
      await this.exitFullscreen();
    this._listenerDisposal.empty();
  }
  get isSupported() {
    return this.isSupportedNatively;
  }
  get isSupportedNatively() {
    return fscreen_esm_default.fullscreenEnabled;
  }
  get isFullscreen() {
    return this.isNativeFullscreen;
  }
  get isNativeFullscreen() {
    if (fscreen_esm_default.fullscreenElement === this._host)
      return true;
    try {
      return this._host.matches(
        fscreen_esm_default.fullscreenPseudoClass
      );
    } catch (error) {
      return false;
    }
  }
  _addFullscreenChangeEventListener(listener) {
    if (!this.isSupported)
      return noop;
    if (true) {
      this._logger?.debug("adding `fullscreenchange` listener");
    }
    const dispose = listen(fscreen_esm_default, "fullscreenchange", listener);
    return () => {
      if (true) {
        this._logger?.debug("removing `fullscreenchange` listener");
      }
      dispose();
    };
  }
  _addFullscreenErrorEventListener(listener) {
    if (!this.isSupported)
      return noop;
    if (true) {
      this._logger?.debug("adding `fullscreenerror` listener");
    }
    const dispose = listen(fscreen_esm_default, "fullscreenerror", listener);
    return () => {
      if (true) {
        this._logger?.debug("removing `fullscreenerror` listener");
      }
      dispose();
    };
  }
  async enterFullscreen() {
    if (this.isFullscreen)
      return;
    this._throwIfNoFullscreenSupport();
    if (true) {
      this._logger?.debug("requesting fullscreen");
    }
    this._listenerDisposal.add(
      this._addFullscreenChangeEventListener(this._handleFullscreenChange.bind(this))
    );
    this._listenerDisposal.add(
      this._addFullscreenErrorEventListener(this._handleFullscreenError.bind(this))
    );
    const response = await this._makeEnterFullscreenRequest();
    await this._lockScreenOrientation();
    return response;
  }
  async _makeEnterFullscreenRequest() {
    return fscreen_esm_default.requestFullscreen(this._host);
  }
  _handleFullscreenChange(event) {
    if (!this.isFullscreen)
      this._listenerDisposal.empty();
    this._host.dispatchEvent(
      vdsEvent("vds-fullscreen-change", {
        bubbles: true,
        composed: true,
        detail: this.isFullscreen,
        triggerEvent: event
      })
    );
  }
  _handleFullscreenError(event) {
    this._host.dispatchEvent(
      vdsEvent("vds-fullscreen-error", {
        bubbles: true,
        composed: true,
        triggerEvent: event
      })
    );
  }
  async exitFullscreen() {
    if (!this.isFullscreen)
      return;
    this._throwIfNoFullscreenSupport();
    if (true) {
      this._logger?.debug("exiting fullscreen");
    }
    const response = await this._makeExitFullscreenRequest();
    await this._unlockScreenOrientation();
    return response;
  }
  async _makeExitFullscreenRequest() {
    return fscreen_esm_default.exitFullscreen();
  }
  _shouldOrientScreen() {
    return this._screenOrientationController.canOrient && !isUndefined(this.screenOrientationLock);
  }
  async _lockScreenOrientation() {
    if (isUndefined(this.screenOrientationLock) || !this._shouldOrientScreen()) {
      return;
    }
    await this._screenOrientationController.lock(this.screenOrientationLock);
  }
  async _unlockScreenOrientation() {
    if (!this._shouldOrientScreen())
      return;
    await this._screenOrientationController.unlock();
  }
  _throwIfNoFullscreenSupport() {
    if (this.isSupported)
      return;
    throw Error("Fullscreen API is not enabled or supported in this environment.");
  }
};

// src/observers/FocusVisibleController.ts
var FocusVisibleController = class {
  constructor(_host) {
    this._host = _host;
    const disposal = new DisposalBin();
    let hadKeyboardEvent = false;
    disposal.add(
      listen(document, "pointerdown", () => {
        hadKeyboardEvent = false;
      })
    );
    eventListener(_host, "keydown", (e) => {
      if (e.metaKey || e.altKey || e.ctrlKey) {
        return;
      }
      hadKeyboardEvent = true;
    });
    eventListener(_host, "focus", (e) => {
      if (hadKeyboardEvent) {
        _host.classList.add("focus-visible");
      }
    });
    eventListener(_host, "blur", (e) => {
      _host.classList.remove("focus-visible");
    });
    _host.addController({
      hostDisconnected: () => {
        disposal.empty();
      }
    });
  }
};
function focusVisiblePolyfill(host) {
  return new FocusVisibleController(host);
}

// src/observers/IntersectionController.ts
var IntersectionController = class {
  constructor(_host, config = {}, _callback = () => true, _logger = true ? new LogDispatcher(_host) : void 0) {
    this._host = _host;
    this._callback = _callback;
    this._logger = _logger;
    this._skipInitial = false;
    this._unobservedUpdate = false;
    const { target, skipInitial, ...intersectionObserverInit } = config;
    this._target = target ?? void 0;
    this._skipInitial = skipInitial ?? this._skipInitial;
    if (!window.IntersectionObserver) {
      if (true) {
        _logger?.warn(`Browser does not support \`IntersectionObserver\`.`);
      }
      return;
    }
    this._observer = new IntersectionObserver((entries) => {
      const unobservedUpdate = this._unobservedUpdate;
      this._unobservedUpdate = false;
      if (this._skipInitial && unobservedUpdate)
        return;
      this.handleChanges(entries);
      this._host.requestUpdate();
    }, intersectionObserverInit);
    _host.addController(this);
  }
  handleChanges(entries) {
    this.value = this._callback(entries, this._observer);
  }
  hostConnected() {
    if (this._target) {
      this.observe(this._target);
    }
  }
  hostDisconnected() {
    this._disconnect();
  }
  async hostUpdated() {
    const pendingRecords = this._observer.takeRecords();
    if (pendingRecords.length) {
      this.handleChanges(pendingRecords);
    }
  }
  observe(target) {
    this._observer.observe(target);
    this._unobservedUpdate = true;
    return () => {
      this._observer.unobserve(target);
    };
  }
  _disconnect() {
    this._observer.disconnect();
  }
};
function createIntersectionController(...params) {
  return new IntersectionController(...params);
}

// src/observers/PageController.ts
var IS_SAFARI2 = typeof window !== "undefined" && typeof window.safari === "object" && window?.safari.pushNotification;
var PageController = class {
  constructor(_host, _callback, _logger = true ? new LogDispatcher(_host) : void 0) {
    this._host = _host;
    this._callback = _callback;
    this._logger = _logger;
    this._state = this._determinePageState();
    this._visibility = document.visibilityState;
    this._disposal = new DisposalBin();
    _host.addController(this);
  }
  get state() {
    return this._state;
  }
  get visibility() {
    return this._visibility;
  }
  hostConnected() {
    const pageEvents = ["focus", "blur", "visibilitychange", "pageshow", "pagehide"];
    this._state = this._determinePageState();
    this._visibility = document.visibilityState;
    pageEvents.forEach((pageEvent) => {
      const off = listen(window, pageEvent, this._handlePageEvent.bind(this));
      this._disposal.add(off);
    });
    if (IS_SAFARI2) {
      this._disposal.add(
        listen(window, "beforeunload", (event) => {
          this._safariBeforeUnloadTimeout = setTimeout(() => {
            if (!(event.defaultPrevented || event.returnValue.length > 0)) {
              this._state = "hidden";
              this._visibility = "hidden";
              this._triggerCallback();
            }
          }, 0);
        })
      );
    }
  }
  hostDisconnected() {
    this._disposal.empty();
  }
  _handlePageEvent(event) {
    if (IS_SAFARI2) {
      window.clearTimeout(this._safariBeforeUnloadTimeout);
    }
    const prevState = this._state;
    const prevVisibility = this._visibility;
    if (event.type !== "blur" || this.state === "active") {
      this._state = this._determinePageState(event);
      this._visibility = document.visibilityState == "hidden" ? "hidden" : "visible";
    }
    if (this.state !== prevState || this.visibility !== prevVisibility) {
      this._triggerCallback();
    }
  }
  _triggerCallback() {
    this._callback({ state: this.state, visibility: this.visibility });
  }
  _determinePageState(event) {
    if (false)
      return "hidden";
    if (event?.type === "blur" || document.visibilityState === "hidden") {
      return "hidden";
    }
    if (document.hasFocus()) {
      return "active";
    }
    return "passive";
  }
};

// src/utils/promise.ts
function deferredPromise() {
  let resolve = noop;
  let reject = noop;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
function timedPromise(promise, timeout, timeoutMsg) {
  const timer = new Promise((_, reject) => {
    const timerId = window.setTimeout(() => {
      window.clearTimeout(timerId);
      reject(timeoutMsg);
    }, timeout);
  });
  return Promise.race([promise, timer]);
}

// src/queue/RequestQueue.ts
var RequestQueue = class {
  constructor() {
    this._requestQueue = /* @__PURE__ */ new Map();
    this._requestKeys = [];
    this._pendingFlush = deferredPromise();
    this._isServing = false;
  }
  get isServing() {
    return this._isServing;
  }
  get size() {
    return this._requestQueue.size;
  }
  async waitForFlush() {
    if (this._isServing)
      return;
    await this._pendingFlush.promise;
  }
  queue(key2, callback) {
    if (this._isServing) {
      callback();
      return;
    }
    this._requestKeys = [...this._requestKeys.filter((k) => k !== key2), key2];
    this._requestQueue.set(key2, callback);
  }
  serve(key2) {
    this._requestQueue.get(key2)?.();
    this._requestQueue.delete(key2);
  }
  start() {
    this._flush();
    this._isServing = true;
    if (this._requestQueue.size > 0) {
      this._flush();
    }
  }
  _flush() {
    for (const requestKey of this._requestKeys) {
      this.serve(requestKey);
    }
    this._requestKeys = [];
    this._release();
  }
  _empty() {
    this._requestQueue.clear();
  }
  _release() {
    this._pendingFlush.resolve();
    this._pendingFlush = deferredPromise();
  }
  stop() {
    this._isServing = false;
  }
  destroy() {
    this.stop();
    this._empty();
    this._release();
  }
};

// src/queue/host-request-queue.ts
function hostRequestQueue(host) {
  const q = new RequestQueue();
  host.addController({
    hostConnected: q.start.bind(q),
    hostDisconnected: q.destroy.bind(q)
  });
  return q;
}

// src/screen-orientation/ScreenOrientationController.ts
var ScreenOrientationController = class {
  constructor(_host) {
    this._host = _host;
    this._isScreenOrientationLocked = false;
    this._logger = true ? new LogDispatcher(this._host) : void 0;
    this._updateScreenOrientation();
    this._listenerDisposal = new DisposalBin();
    _host.addController({
      hostConnected: this._handleHostConnected.bind(this),
      hostDisconnected: this._handleHostDisconnected.bind(this)
    });
  }
  async _handleHostConnected() {
    this._updateScreenOrientation();
    this._addScreenOrientationEventListeners();
  }
  async _handleHostDisconnected() {
    if (this.canOrient && this._isScreenOrientationLocked)
      await this.unlock();
    this._listenerDisposal.empty();
  }
  get currentOrientation() {
    return this._screenOrientation;
  }
  get canOrient() {
    return canOrientScreen();
  }
  get isLocked() {
    return this._isScreenOrientationLocked;
  }
  async lock(lockType) {
    this._throwIfScreenOrientationUnavailable();
    if (true) {
      this._logger?.debug("locking screen orientation to", lockType);
    }
    await screen.orientation.lock(lockType);
    this._isScreenOrientationLocked = true;
    this._host.dispatchEvent(
      vdsEvent("vds-screen-orientation-lock-change", {
        bubbles: true,
        composed: true,
        detail: lockType
      })
    );
  }
  async unlock() {
    this._throwIfScreenOrientationUnavailable();
    if (true) {
      this._logger?.debug("unlocking screen orientation");
    }
    await screen.orientation.unlock();
    this._isScreenOrientationLocked = false;
    this._host.dispatchEvent(
      vdsEvent("vds-screen-orientation-lock-change", {
        bubbles: true,
        composed: true,
        detail: screen.orientation.type
      })
    );
  }
  _addScreenOrientationEventListeners() {
    if (!this.canOrient)
      return;
    this._listenerDisposal.add(this._addScreenOrientationChangeEventListener());
  }
  _addScreenOrientationChangeEventListener() {
    return listen(screen.orientation, "change", this._handleOrientationChange.bind(this));
  }
  _handleOrientationChange(event) {
    this._screenOrientation = window.screen.orientation.type;
    if (this._isScreenOrientationLocked) {
      this._logger?.debug("screen orientation changed to", this._screenOrientation);
    }
    this._host.dispatchEvent(
      vdsEvent("vds-screen-orientation-change", {
        bubbles: true,
        composed: true,
        detail: this._screenOrientation,
        triggerEvent: event
      })
    );
  }
  _updateScreenOrientation() {
    this._screenOrientation = IS_CLIENT ? window.screen?.orientation?.type : void 0;
  }
  _throwIfScreenOrientationUnavailable() {
    if (this.canOrient)
      return;
    throw Error("Screen orientation API is not available.");
  }
};

// src/utils/object.ts
function keysOf(obj) {
  return Object.keys(obj);
}
function pick(obj, keys) {
  return keys.reduce(
    (newObj, key2) => ({
      ...newObj,
      [key2]: obj[key2]
    }),
    {}
  );
}
function omit(obj, keys) {
  return keysOf(obj).filter((key2) => keys.indexOf(key2) < 0).reduce(
    (newObj, key2) => ({
      ...newObj,
      [key2]: obj[key2]
    }),
    {}
  );
}
var hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var sortObjectsBy = (objects, sortKey) => objects.sort((a, b) => {
  if (a[sortKey] === b[sortKey])
    return 0;
  return a[sortKey] < b[sortKey] ? -1 : 1;
});

// src/stores/store-subscription.ts
function storeSubscription(host, store, onChange) {
  let consumer;
  let unsubscribe;
  const subscribe = () => {
    unsubscribe = (consumer?.value ?? store).subscribe(onChange);
  };
  if (isContext(store)) {
    consumer = store.consume(host);
  }
  host.addController({
    hostConnected() {
      if (isContext(store)) {
        consumer.whenRegistered(subscribe);
      } else {
        subscribe();
      }
    },
    hostDisconnected() {
      unsubscribe?.();
    }
  });
}

// src/stores/stores.ts
var subscriberQueue = [];
function readable(value, start) {
  return {
    initialValue: value,
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(newValue) {
    if (safeNotEqual(value, newValue)) {
      value = newValue;
      if (stop) {
        const runQueue = !subscriberQueue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriberQueue.push(subscriber, value);
        }
        if (runQueue) {
          for (let i = 0; i < subscriberQueue.length; i += 2) {
            subscriberQueue[i][0](subscriberQueue[i + 1]);
          }
          subscriberQueue.length = 0;
        }
      }
    }
  }
  function update(updater) {
    set(updater(value));
  }
  function subscribe(run, invalidate = noop) {
    const subscriber = [run, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop?.();
        stop = null;
      }
    };
  }
  return { initialValue: value, set, update, subscribe };
}
function derived(stores, fn, initialValue) {
  const single = !Array.isArray(stores);
  const storesArray = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initialValue, (set) => {
    let initialized = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = isFunction(result) ? result : noop;
      }
    };
    const unsubscribers = storesArray.map(
      (store, i) => store.subscribe(
        (value) => {
          values[i] = value;
          pending &= ~(1 << i);
          if (initialized) {
            sync();
          }
        },
        () => {
          pending |= 1 << i;
        }
      )
    );
    initialized = true;
    sync();
    return function stop() {
      unsubscribers.forEach((fn2) => fn2());
      cleanup();
    };
  });
}
function getStoreValue(store) {
  let value;
  store.subscribe((_) => value = _)();
  return value;
}

// src/stores/store-record.ts
function storeRecordSubscription(host, store, key2, onChange) {
  if (isContext(store)) {
    const consumer = store.consume(host);
    let unsubscribe;
    const subscribe = () => {
      unsubscribe = consumer.value[key2].subscribe(onChange);
    };
    host.addController({
      hostConnected: () => {
        consumer.whenRegistered(subscribe);
      },
      hostDisconnected: () => {
        unsubscribe?.();
      }
    });
  } else {
    return storeSubscription(host, store[key2], onChange);
  }
}
function copyStoreRecords(storeRecordA, storeRecordB) {
  for (const key2 of keysOf(storeRecordA)) {
    const storeA = storeRecordA[key2];
    const storeB = storeRecordB[key2];
    if (!storeA || !storeB)
      continue;
    const valA = getStoreValue(storeA);
    const valB = getStoreValue(storeB);
    if (valA !== valB)
      storeB.set(valA);
  }
}
function unwrapStoreRecord(store) {
  return new Proxy(store, {
    get(target, key2) {
      return getStoreValue(target[key2]);
    },
    has(target, key2) {
      return Reflect.has(target, key2);
    },
    ownKeys(target) {
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(target, key2) {
      return Reflect.getOwnPropertyDescriptor(target, key2);
    }
  });
}

// src/utils/aria.ts
function ariaBool(value) {
  return value ? "true" : "false";
}

// src/utils/array.ts
function isScalarArrayEqual(arrayA, arrayB) {
  return arrayA.length === arrayB.length && arrayA.every((value, i) => value === arrayB[i]);
}
function filterUnique(items, key2, options = {}) {
  const seen = /* @__PURE__ */ new Set();
  return items.filter((item) => {
    if (options.removeNull && isNull(item[key2]))
      return false;
    if (options.removeUndefined && isUndefined(item[key2]))
      return false;
    const isUnique = !seen.has(item[key2]);
    if (!isUnique) {
      options.onDuplicateFound?.(item);
    }
    seen.add(item[key2]);
    return isUnique;
  });
}

// src/utils/dom.ts
function raf(callback) {
  return new Promise((resolve) => {
    const rafId = window.requestAnimationFrame(async () => {
      await callback?.();
      resolve(rafId);
    });
  });
}
function walkUpDOMTree(node, onDiscover) {
  let parent = node.parentElement;
  while (parent) {
    const skip = onDiscover(parent);
    parent = skip ? null : parent.parentElement;
  }
}
function buildExportPartsAttr(parts, prefix) {
  return parts.map(
    (part) => `${part}: ${!isFunction(prefix) ? prefix ? `${prefix}-` : "" : prefix(part)}${part}`
  ).join(", ");
}
function safelyDefineCustomElement(name, constructor, isClient = IS_CLIENT) {
  const isElementRegistered = isClient && !isUndefined(window.customElements.get(name));
  if (!isClient || isElementRegistered)
    return;
  window.customElements.define(name, constructor);
}
function setAttribute(element, attrName, attrValue) {
  if (isNil(attrValue) || attrValue === false) {
    element.removeAttribute(attrName);
  } else {
    const value = isString(attrValue) ? attrValue : "";
    element.setAttribute(attrName, value);
  }
}
function setAttributeIfEmpty(element, attrName, attrValue) {
  if (!element.hasAttribute(attrName)) {
    element.setAttribute(attrName, attrValue);
  }
}
function setCSSProperty(element, name, value, prefix = "vds") {
  element.style.setProperty(`--${prefix}-${name}`, value ? value : null);
}
function getSlottedChildren(el, name) {
  const selector = name ? `slot[name="${name}"]` : "slot:not([name])";
  const slot = el.shadowRoot?.querySelector(selector);
  const childNodes = slot?.assignedNodes({ flatten: true }) ?? [];
  return Array.prototype.filter.call(childNodes, (node) => node.nodeType == Node.ELEMENT_NODE);
}
function getElementAttributes(elementCtor) {
  return new Set(elementCtor.observedAttributes);
}
function observeAttributes(element, attributes, onChange, { skipInitial = false } = {}) {
  const callback = (attrName) => {
    const attrValue = element.getAttribute(attrName);
    onChange?.(attrName, attrValue);
  };
  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type === "attributes") {
        callback(mutation.attributeName);
      }
    }
  });
  if (!skipInitial) {
    for (const attrName of attributes) {
      callback(attrName);
    }
  }
  observer.observe(element, {
    attributeFilter: Array.from(attributes)
  });
  return observer;
}
function requestIdleCallback(callback) {
  if (false) {
    callback();
    return;
  }
  const idle = window.requestIdleCallback ?? ((fn) => fn());
  if (document.readyState === "complete") {
    idle(callback);
  } else {
    window.addEventListener(
      "load",
      () => {
        idle(callback);
      },
      { once: true }
    );
  }
}

// src/utils/keyboard.ts
function isKeyboardEvent(event) {
  return event?.type.startsWith("key") ?? false;
}
function wasEnterKeyPressed(event) {
  return isKeyboardEvent(event) && event.key === "Enter";
}
function wasEscapeKeyPressed(event) {
  return isKeyboardEvent(event) && event.key === "Escape";
}
function isKeyboardClick(event) {
  return isKeyboardEvent(event) && (event.key === "Enter" || event.key === " ");
}

// src/utils/network.ts
function tryParseJSON(json) {
  if (!isString(json))
    return void 0;
  try {
    return JSON.parse(json);
  } catch (error) {
    return void 0;
  }
}
function isObjOrJSON(value) {
  return isString(value) && value.startsWith("{") || isObject(value);
}
function objOrParseJSON(value) {
  return isObject(value) ? value : tryParseJSON(value);
}
function loadImage(src, minWidth = 1) {
  return new Promise((resolve, reject) => {
    const image = new Image();
    const handler = () => {
      image.naturalWidth >= minWidth ? resolve(image) : reject(image);
    };
    Object.assign(image, { onload: handler, onerror: handler, src });
  });
}
async function loadScript(src) {
  const hasLoaded = document.querySelector(`script[src="${src}"]`);
  if (!isNull(hasLoaded))
    return;
  const script = document.createElement("script");
  const load = deferredPromise();
  script.src = src;
  script.onload = load.resolve;
  script.onerror = load.reject;
  const firstScriptTag = document.getElementsByTagName("script")[0];
  if (!isNil(firstScriptTag.parentNode)) {
    firstScriptTag.parentNode.insertBefore(script, firstScriptTag);
  }
  return load.promise;
}
function decodeJSON(data) {
  if (!isObjOrJSON(data))
    return void 0;
  return objOrParseJSON(data);
}
function tryDecodeURIComponent(component, fallback = "", isClient = IS_CLIENT) {
  if (!isClient)
    return fallback;
  try {
    return window.decodeURIComponent(component);
  } catch (error) {
    return fallback;
  }
}
var QUERY_STRING_REGEX = /(?:^[#?]?|&)([^=&]+)(?:=([^&]*))?/g;
function parseQueryString(qs) {
  const params = /* @__PURE__ */ Object.create(null);
  if (isUndefined(qs))
    return params;
  let match;
  while (match = QUERY_STRING_REGEX.exec(qs)) {
    const name = tryDecodeURIComponent(match[1], match[1]).replace("[]", "");
    const value = isString(match[2]) ? tryDecodeURIComponent(match[2].replace(/\+/g, " "), match[2]) : "";
    const currValue = params[name];
    if (currValue && !isArray(currValue))
      params[name] = [currValue];
    currValue ? params[name].push(value) : params[name] = value;
  }
  return params;
}
function serializeQueryString(params) {
  const qs = [];
  const appendQueryParam = (param, v) => {
    qs.push(`${encodeURIComponent(param)}=${encodeURIComponent(v)}`);
  };
  Object.keys(params).forEach((param) => {
    const value = params[param];
    if (isNil(value))
      return;
    if (isArray(value)) {
      value.forEach((v) => appendQueryParam(param, v));
    } else {
      appendQueryParam(param, value);
    }
  });
  return qs.join("&");
}
function preconnect(url, rel = "preconnect", isClient = IS_CLIENT) {
  if (!isClient)
    return false;
  const hasLink = document.querySelector(`link[href="${url}"]`);
  if (!isNull(hasLink))
    return true;
  const link = document.createElement("link");
  link.rel = rel;
  link.href = url;
  link.crossOrigin = "true";
  document.head.append(link);
  return true;
}
function appendQueryStringToURL(url, qs) {
  if (isUndefined(qs) || qs.length === 0)
    return url;
  const mainAndQuery = url.split("?", 2);
  return mainAndQuery[0] + (!isUndefined(mainAndQuery[1]) ? `?${mainAndQuery[1]}&${qs}` : `?${qs}`);
}
function appendParamsToURL(url, params) {
  return appendQueryStringToURL(url, isObject(params) ? serializeQueryString(params) : params);
}
function decodeQueryString(qs) {
  if (!isString(qs))
    return void 0;
  return parseQueryString(qs);
}
var ScriptLoader = class {
  static async load(src) {
    return new Promise((resolve, reject) => {
      if (this.pendingRequests[src]) {
        this.pendingRequests[src].push({ resolve, reject });
        return;
      }
      this.pendingRequests[src] = [{ resolve, reject }];
      loadScript(src).then(() => {
        this.pendingRequests[src].forEach((request) => request.resolve());
        delete this.pendingRequests[src];
      }).catch((err) => {
        this.pendingRequests[src].forEach((request) => request.reject(err));
        delete this.pendingRequests[src];
      });
    });
  }
};
ScriptLoader.pendingRequests = {};

// src/utils/scroll.ts
function hideDocumentScrollbar(hidden) {
  window.requestAnimationFrame(() => {
    document.documentElement.classList[hidden ? "add" : "remove"]("overflow-hidden");
    document.documentElement.classList[!hidden ? "add" : "remove"]("overflow-x-hidden");
  });
}
function scrollIntoCenter(scroll, element, options = {}) {
  const scrollTop = isWindow(scroll) ? window.pageYOffset : scroll.scrollTop;
  const scrollHeight = isWindow(scroll) ? window.innerHeight : scroll.getBoundingClientRect().height;
  const elementRect = element.getBoundingClientRect();
  const center = elementRect.top + scrollTop - scrollHeight / 2;
  scroll.scrollTo({
    top: center + (options?.offset ?? 0),
    behavior: options.behaviour
  });
}

// src/utils/string.ts
var escapeQuotes = (str) => str.replace(/^"+|"+$/g, "").replace(/^'+|'+$/g, "");
var normalizeLineBreaks = (str) => str.replace(/\\r/g, "\n");
function splitLineBreaks(str) {
  if (typeof str !== "string")
    return [];
  return normalizeLineBreaks(str).split("\n");
}
function uppercaseFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function lowercaseFirstLetter(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
function kebabToTitleCase(str) {
  return uppercaseFirstLetter(str.replace(/-./g, (x) => " " + x[1].toUpperCase()));
}
function camelToKebabCase(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function kebabToCamelCase(str) {
  return str.replace(/-./g, (x) => x[1].toUpperCase());
}
function kebabToPascalCase(str) {
  return kebabToTitleCase(str).replace(/\s/g, "");
}
function camelToTitleCase(str) {
  return uppercaseFirstLetter(str.replace(/([A-Z])/g, " $1"));
}

// src/utils/time.ts
function padNumberWithZeroes(num, expectedLength) {
  const str = String(num);
  const actualLength = str.length;
  const shouldPad = actualLength < expectedLength;
  if (shouldPad) {
    const padLength = expectedLength - actualLength;
    const padding = `0`.repeat(padLength);
    return `${padding}${num}`;
  }
  return str;
}
var TimeUnit = /* @__PURE__ */ ((TimeUnit2) => {
  TimeUnit2["Hours"] = "hours";
  TimeUnit2["Minutes"] = "minutes";
  TimeUnit2["Seconds"] = "seconds";
  TimeUnit2["Fraction"] = "fraction";
  return TimeUnit2;
})(TimeUnit || {});
function parseTime(duration) {
  const hours = Math.trunc(duration / 3600);
  const minutes = Math.trunc(duration % 3600 / 60);
  const seconds = Math.trunc(duration % 60);
  const fraction = Number((duration - Math.trunc(duration)).toPrecision(3));
  return {
    ["hours" /* Hours */]: hours,
    ["minutes" /* Minutes */]: minutes,
    ["seconds" /* Seconds */]: seconds,
    ["fraction" /* Fraction */]: fraction
  };
}
function formatTime(duration, shouldPadHours = false, shouldAlwaysShowHours = false) {
  const { hours, minutes, seconds } = parseTime(duration);
  const paddedHours = shouldPadHours ? padNumberWithZeroes(hours, 2) : hours;
  const paddedMinutes = padNumberWithZeroes(minutes, 2);
  const paddedSeconds = padNumberWithZeroes(seconds, 2);
  if (hours > 0 || shouldAlwaysShowHours) {
    return `${paddedHours}:${paddedMinutes}:${paddedSeconds}`;
  }
  return `${minutes}:${paddedSeconds}`;
}
function formatSpokenTime(duration) {
  const spokenParts = [];
  const { hours, minutes, seconds } = parseTime(duration);
  const pluralize = (num, word) => num === 1 ? word : `${word}s`;
  if (hours > 0) {
    spokenParts.push(`${hours} ${pluralize(hours, "hour")}`);
  }
  if (minutes > 0) {
    spokenParts.push(`${minutes} ${pluralize(minutes, "minute")}`);
  }
  if (seconds > 0 || spokenParts.length === 0) {
    spokenParts.push(`${seconds} ${pluralize(seconds, "second")}`);
  }
  return spokenParts.join(", ");
}
function formatHtml5Duration(duration) {
  const { hours, minutes, seconds, fraction } = parseTime(duration);
  return `PT${hours}H${minutes}M${seconds + fraction}S`;
}

// src/utils/timing.ts
import debounce from "just-debounce-it";
import throttle from "just-throttle";
function wait(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
function rafThrottle(func) {
  let rafId;
  const pending = () => !isUndefined(rafId);
  const cancel = () => {
    if (isUndefined(rafId))
      return;
    window.cancelAnimationFrame(rafId);
    rafId = void 0;
  };
  function throttled(...args) {
    if (pending())
      return;
    rafId = window.requestAnimationFrame(() => {
      func.apply(this, args);
      rafId = void 0;
    });
  }
  throttled.cancel = cancel;
  throttled.pending = pending;
  return throttled;
}
export {
  ContextConsumerController,
  ContextProviderController,
  DisposalBin,
  FocusVisibleController,
  FullscreenController,
  GROUPED_LOG_ID,
  IS_ANDROID,
  IS_CHROME,
  IS_CLIENT,
  IS_FIREFOX,
  IS_IOS,
  IS_IPHONE,
  IS_MOBILE,
  IS_SAFARI,
  IntersectionController,
  LogController,
  LogDispatcher,
  LogLevelColor,
  LogLevelValue,
  ORIGIN,
  PageController,
  RequestQueue,
  ScreenOrientationController,
  ScriptLoader,
  TimeUnit,
  UA,
  VdsEvent,
  WithFocus,
  adoptOrphans,
  appendParamsToURL,
  appendQueryStringToURL,
  appendTriggerEvent,
  ariaBool,
  buildExportPartsAttr,
  camelToKebabCase,
  camelToTitleCase,
  canAutoplay,
  canFullscreenVideo,
  canObserveIntersection,
  canOrientScreen,
  canPlayHLSNatively,
  canRotateScreen,
  canUsePiP,
  canUsePiPInChrome,
  canUsePiPInSafari,
  clampNumber,
  copyStoreRecords,
  createContext,
  createIntersectionController,
  createRegex,
  currentSafariVersion,
  debounce,
  decodeJSON,
  decodeQueryString,
  deferredPromise,
  derived,
  discover,
  discoverable,
  equal,
  escapeQuotes,
  eventListener,
  filterUnique,
  findTriggerEvent,
  focusVisiblePolyfill,
  focusableSelector,
  formatHtml5Duration,
  formatSpokenTime,
  formatTime,
  getStoreValue as get,
  getElementAttributes,
  getMediaSource,
  getNumberOfDecimalPlaces,
  getOriginEvent,
  getSlottedChildren,
  getSourceBuffer,
  groupedLog,
  hasOwnProperty,
  hasTriggerEvent,
  hideDocumentScrollbar,
  hostRequestQueue,
  ifNonEmpty,
  ifNumber,
  isArray,
  isBoolean,
  isContext,
  isFunction,
  isGroupedLog,
  isHlsjsSupported,
  isKeyboardClick,
  isKeyboardEvent,
  isMouseEvent,
  isNil,
  isNull,
  isNumber,
  isObjOrJSON,
  isObject,
  isPointerEvent,
  isReducedMotionPreferred,
  isScalarArrayEqual,
  isString,
  isTouchEvent,
  isUndefined,
  isVdsEvent,
  isWindow,
  kebabToCamelCase,
  kebabToPascalCase,
  kebabToTitleCase,
  keysOf,
  listen,
  loadImage,
  loadScript,
  logElementLifecycle,
  logEvent,
  lowercaseFirstLetter,
  noop,
  normalizeLineBreaks,
  notEqual,
  objOrParseJSON,
  observeAttributes,
  omit,
  padNumberWithZeroes,
  parseQueryString,
  parseTime,
  pick,
  preconnect,
  raf,
  rafThrottle,
  readable,
  redispatchEvent,
  requestIdleCallback,
  round,
  safeNotEqual,
  safelyDefineCustomElement,
  scrollIntoCenter,
  serializeQueryString,
  setAttribute,
  setAttributeIfEmpty,
  setCSSProperty,
  sortObjectsBy,
  splitLineBreaks,
  storeRecordSubscription,
  storeSubscription,
  throttle,
  timedPromise,
  tryDecodeURIComponent,
  tryParseJSON,
  unwrapStoreRecord,
  uppercaseFirstLetter,
  vdsEvent,
  wait,
  waitForEvent,
  walkTriggerEventChain,
  walkUpDOMTree,
  wasEnterKeyPressed,
  wasEscapeKeyPressed,
  writable
};
