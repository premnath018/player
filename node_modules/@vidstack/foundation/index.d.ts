import debounce from 'just-debounce-it';
import { LitElement } from 'lit';
import { nothing } from 'lit';
import { ReactiveController } from 'lit';
import { ReactiveControllerHost } from 'lit';
import { ReactiveElement } from 'lit';
import throttle from 'just-throttle';

export declare function adoptOrphans(id: symbol, provider: Node): OrphanContextConsumer[];

/**
 * Serializes the given params into a query string and appends them to the given URL.
 */
export declare function appendParamsToURL(url: string, params: string | Params): string;

/**
 * Safely appends the given query string to the given URL.
 */
export declare function appendQueryStringToURL(url: string, qs?: string): string;

/**
 * Appends the given `triggerEvent` to the event chain. This means the new origin event will be
 * the origin of the given `triggerEvent`, or the `triggerEvent` itself (if no chain exists on the
 * trigger).
 *
 * @param event - The event on which to extend the trigger event chain.
 * @param triggerEvent - The trigger event that will becoming the new origin event.
 */
export declare function appendTriggerEvent(event: VdsEvent, triggerEvent?: Event): void;

export declare function ariaBool(value: boolean): "true" | "false";

export declare type ArrayElement<A> = A extends readonly (infer T)[] ? T : never;

/**
 * Builds an `exportsparts` attribute value given an array of `parts` and an optional `prefix`.
 */
export declare function buildExportPartsAttr(parts: string[], prefix: string | ((part: string) => string)): string;

/**
 * Converts a camelCase string to kebab-case.
 *
 * @example `myProperty -> my-property`
 */
export declare function camelToKebabCase(str: string): string;

/**
 * Converts a camelCase string to Title Case.
 *
 * @example `myProperty -> Title Case`
 */
export declare function camelToTitleCase(str: string): string;

/**
 * To detect autoplay, we create a video element and call play on it, if it is `paused` after
 * a `play()` call, autoplay is supported. Although this unintuitive, it works across browsers
 * and is currently the lightest way to detect autoplay without using a data source.
 *
 * @see {@link https://github.com/ampproject/amphtml/blob/9bc8756536956780e249d895f3e1001acdee0bc0/src/utils/video.js#L25}
 */
export declare function canAutoplay(muted?: boolean, playsinline?: boolean): Promise<boolean>;

/**
 * Checks if a video player can enter fullscreen.
 *
 * @see {@link https://developer.apple.com/documentation/webkitjs/htmlvideoelement/1633500-webkitenterfullscreen}
 */
export declare function canFullscreenVideo(): boolean;

/**
 * Checks whether the `IntersectionObserver` API is available.
 */
export declare function canObserveIntersection(): boolean;

/**
 * Checks if the ScreenOrientation API is available.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
 */
export declare function canOrientScreen(): boolean;

/**
 * Checks if the native HTML5 video player can play HLS.
 */
export declare function canPlayHLSNatively(): boolean;

/**
 * Checks if the screen orientation can be changed.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
 */
export declare function canRotateScreen(): boolean;

/**
 * Checks if the native HTML5 video player can enter PIP.
 */
export declare function canUsePiP(): boolean;

/**
 * Checks if the native HTML5 video player can enter picture-in-picture (PIP) mode when using
 * the Chrome browser.
 *
 * @see {@link https://developers.google.com/web/updates/2018/10/watch-video-using-picture-in-picture}
 */
export declare function canUsePiPInChrome(): boolean;

/**
 * Checks if the native HTML5 video player can enter picture-in-picture (PIP) mode when using
 * the desktop Safari browser, iOS Safari appears to "support" PiP through the check, however PiP
 * does not function.
 *
 * @see {@link https://developer.apple.com/documentation/webkitjs/adding_picture_in_picture_to_your_safari_media_controls}
 */
export declare function canUsePiPInSafari(): boolean;

/**
 * Clamp a given `value` between a minimum and maximum value.
 */
export declare function clampNumber(min: number, value: number, max: number): number;

export declare type Constructor<T = object> = {
    new (...args: any[]): T;
    prototype: T;
};

export declare type ConsumeContextOptions<T> = {
    /**
     * A unique identifier used to pair a context provider and consumer.
     */
    id: symbol;
};

export declare interface Context<T> {
    readonly id: symbol;
    provide(host: ContextProviderHost): ContextProviderController<T>;
    consume(host: ContextConsumerHost): ContextConsumerController<T>;
}

export declare type ContextConsumerConnectEvent = VdsEvent<ContextConsumerConnectEventDetail<any>>;

export declare type ContextConsumerConnectEventDetail<T> = {
    /**
     * A unique identifier used to pair a context provider and consumer.
     */
    id: symbol;
    /**
     * Sets value on context consumer.
     */
    setValue(value: T): void;
};

export declare class ContextConsumerController<T> {
    protected readonly _host: ContextConsumerHost;
    readonly initialValue: T;
    protected readonly _options: ConsumeContextOptions<T>;
    protected _registrationCallbacks?: ((value: T) => void)[];
    get id(): symbol;
    get value(): T;
    get registered(): boolean;
    constructor(_host: ContextConsumerHost, initialValue: T, _options: ConsumeContextOptions<T>);
    /**
     * Attempt connecting to a context provider.
     */
    protected _connect(): void;
    whenRegistered(callback: (value: T) => void): void;
}

export declare type ContextConsumerHost = ReactiveControllerHost & Node;

export declare type ContextEvents = {
    'vds-context-consumer-connect': ContextConsumerConnectEvent;
};

export declare class ContextProviderController<T> {
    protected readonly _host: ContextProviderHost;
    readonly _initValue: () => T;
    protected readonly _options: ProvideContextOptions<T>;
    protected _stopDisposal: DisposalBin;
    protected _value: T;
    get id(): symbol;
    get value(): T;
    constructor(_host: ContextProviderHost, _initValue: () => T, _options: ProvideContextOptions<T>);
    /**
     * Start providing context to consumers.
     */
    start(): void;
    /**
     * Stop providing context to consumers.
     */
    stop(): void;
    protected _handleConsumerConnect(event: ContextConsumerConnectEvent): void;
}

export declare type ContextProviderHost = ReactiveControllerHost & Node;

/**
 * Copies matching store record values from `storeRecordA` to `storeRecordB`.
 */
export declare function copyStoreRecords(storeRecordA: WritableStoreRecord, storeRecordB: WritableStoreRecord): void;

/**
 * Creates and returns a pairable context consumer and provider.
 */
export declare function createContext<T>(initValue: () => T): Context<T>;

export declare function createIntersectionController(...params: ConstructorParameters<typeof IntersectionController>): IntersectionController;

export declare function createRegex(regex: string | RegExp): RegExp;

/**
 * Returns the current version of Safari. Defaults to `0` if unknown.
 */
export declare function currentSafariVersion(): number;

export { debounce }

/**
 * Tries to parse json and return a object.
 */
export declare function decodeJSON<T>(data: unknown): T | undefined;

/**
 * Tries to convert a query string into a object.
 */
export declare function decodeQueryString<T>(qs: string): T | undefined;

export declare type DeferredPromise<ResolveType = void, RejectType = void> = {
    promise: Promise<ResolveType | undefined>;
    resolve: (value?: ResolveType) => void;
    reject: (reason: RejectType) => void;
};

/**
 * Creates an empty Promise and defers resolving/rejecting it.
 */
export declare function deferredPromise<ResolveType = void, RejectType = void>(): DeferredPromise<ResolveType, RejectType>;

/**
 * Derived value store by synchronizing one or more readable stores and
 * applying an aggregation function over its input values.
 */
export declare function derived<S extends Stores, T>(stores: S, fn: (values: StoresValues<S>, set: (value: T) => void) => StoreUnsubscriber | void, initialValue?: T): ReadableStore<T>;

/**
 * Derived value store by synchronizing one or more readable stores and
 * applying an aggregation function over its input values.
 */
export declare function derived<S extends Stores, T>(stores: S, fn: (values: StoresValues<S>) => T, initialValue?: T): ReadableStore<T>;

/**
 * Derived value store by synchronizing one or more readable stores and
 * applying an aggregation function over its input values.
 */
export declare function derived<S extends Stores, T>(stores: S, fn: (values: StoresValues<S>) => T): ReadableStore<T>;

export declare type DisconnectCallback = (callback: () => void) => void;

export declare function discover(host: DiscovererHost, id: symbol, callback: DiscoveryCallback): void;

export declare type Discoverable = {
    element: HTMLElement;
    onDisconnect: DisconnectCallback;
};

/**
 * Fires the given `eventType` when the given `host` connects to the DOM. A discovery event
 * also contains an event detail of the form `{ element: host; onDisconnect: () => void; }`.
 *
 * The discoverable element can be registered so other elements can be guaranteed to discover
 * it using the `discover()` function. Events can be missed depending on the define import order
 * because slotted custom elements may be defined before their parent.
 */
export declare function discoverable(host: DiscovererHost, eventType: keyof VdsElementEventMap, options?: {
    register?: symbol;
}): void;

export declare type Discoverer = {
    host: DiscovererHost;
    callback: DiscoveryCallback;
};

export declare type DiscovererHost = ReactiveControllerHost & HTMLElement;

export declare type DiscoveryCallback = (element: HTMLElement, onDisconnect: DisconnectCallback) => void;

/**
 * @event
 * @bubbles
 * @composed
 */
export declare type DiscoveryEvent<Discoverable extends Element> = VdsEvent<DiscoveryEventDetail<Discoverable>>;

export declare type DiscoveryEventDetail<Discoverable extends Element> = {
    element: Discoverable;
    onDisconnect: DisconnectCallback;
};

/**
 * A disposal bin used to add cleanup callbacks that can be called when required.
 */
export declare class DisposalBin {
    protected _disposal: (() => void)[];
    add(...callbacks: (() => void)[]): void;
    /**
     * Dispose callbacks.
     */
    empty(): void;
}

export declare function equal(valueA: unknown, valueB: unknown): boolean;

export declare const escapeQuotes: (str: string) => string;

/**
 * Add an event listener to the given `host` element until it's disconnected from the DOM, at which
 * point the listener will be removed.
 */
export declare function eventListener<EventType extends keyof HTMLElementEventCallbackMap>(host: ReactiveControllerHost & EventTarget, type: EventType, listener: HTMLElementEventCallbackMap[EventType], options?: (EventListenerOptions | AddEventListenerOptions) & {
    target?: EventTarget;
}): void;

export declare type ExtractEventDetail<Event> = Event extends VdsEvent<infer I> ? I : never;

export declare type ExtractEventInit<Event> = VdsEventInit<ExtractEventDetail<Event>>;

export declare function filterUnique<T>(items: T[], key: keyof T, options?: {
    removeNull?: boolean;
    removeUndefined?: boolean;
    onDuplicateFound?: (item: T) => void;
}): T[];

/**
 * Attempts to find a trigger event with a given `eventType` on the event chain.
 *
 * @param event - The event on which to look for a trigger event.
 * @param eventType - The type of event to find.
 */
export declare function findTriggerEvent<T extends keyof HTMLElementEventMap>(event: Event, eventType: T): HTMLElementEventMap[T] | undefined;

/**
 * A selector selecting focusable nodes.
 *
 * @see https://github.com/carbon-design-system/carbon-web-components
 */
export declare const focusableSelector: string;

/**
 * `:focus-visible` polyfill which adds the `focus-visible` class to the given `host` element
 * when a focus event occurs following a keyboard event.
 */
export declare class FocusVisibleController {
    protected readonly _host: ReactiveElement;
    constructor(_host: ReactiveElement);
}

export declare function focusVisiblePolyfill(host: ReactiveElement): FocusVisibleController;

/**
 * Formats the given `duration` into a valid HTML5 duration as specified in the linked
 * spec below.
 *
 * @param duration - The length of time to parse in seconds.
 * @see {@link https://www.w3.org/TR/2014/REC-html5-20141028/infrastructure.html#valid-duration-string}
 */
export declare function formatHtml5Duration(duration: number): string;

/**
 * Formats the given `duration` into human spoken form.
 *
 * @param duration - The length of time to parse in seconds.
 * @example `2 hours, 3 minutes, 4 seconds`
 */
export declare function formatSpokenTime(duration: number): string;

/**
 * Formats the given `duration` into a human readable form that can be displayed to the user.
 *
 * @param duration - The length of time to parse in seconds.
 * @param shouldPadHours - Whether to pad the hours to be length of 2.
 * @param shouldAlwaysShowHours - Whether to always show the hours unit.
 * @example `01:20 -> minutes:seconds`
 * @example `3:01:20 -> hours:minutes:seconds`
 * @example If `shouldPadHours` is `true` - `03:01:20`
 * @example If `shouldAlwaysShowHours` is `true` - `0:01:20`
 */
export declare function formatTime(duration: number, shouldPadHours?: boolean, shouldAlwaysShowHours?: boolean): string;

/**
 * Fired when an element enters/exits fullscreen. The event detail is a `boolean` indicating
 * if fullscreen was entered (`true`) or exited (`false`).
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type FullscreenChangeEvent = VdsEvent<boolean>;

/**
 * Unfortunately fullscreen isn't straight forward due to cross-browser inconsistencies. This
 * class abstract the logic for handling fullscreen across browsers.
 *
 * @example
 * ```ts
 * import { LitElement } from 'lit';
 * import { FullscreenController, ScreenOrientationController } from '@vidstack/player';
 *
 * class MyElement extends LitElement {
 *   fullscreenController = new FullscreenController(
 *     this,
 *     new ScreenOrientationController(this),
 *   );
 *
 *   enterFullscreen() {
 *     return this.fullscreenController.enterFullscreen();
 *   }
 *
 *   exitFullscreen() {
 *     return this.fullscreenController.exitFullscreen();
 *   }
 * }
 * ```
 */
export declare class FullscreenController {
    protected readonly _host: FullscreenControllerHost;
    protected readonly _screenOrientationController: ScreenOrientationController;
    protected readonly _listenerDisposal: DisposalBin;
    protected readonly _logger: LogDispatcher | undefined;
    /**
     * This will indicate the orientation to lock the screen to when in fullscreen mode. The default
     * is `undefined` which indicates no screen orientation change.
     */
    screenOrientationLock?: ScreenOrientationLock;
    constructor(_host: FullscreenControllerHost, _screenOrientationController: ScreenOrientationController);
    /**
     * Dispose of any event listeners and exit fullscreen (if active).
     */
    protected _handleHostDisconnected(): Promise<void>;
    /**
     * Whether fullscreen mode can be requested, generally is an API available to do so.
     */
    get isSupported(): boolean;
    /**
     * Whether the native Fullscreen API is enabled/available.
     */
    get isSupportedNatively(): boolean;
    /**
     * Whether the host element is in fullscreen mode.
     */
    get isFullscreen(): boolean;
    /**
     * Whether the host element is in fullscreen mode via the native Fullscreen API.
     */
    get isNativeFullscreen(): boolean;
    /**
     * @returns Stop listening function.
     */
    protected _addFullscreenChangeEventListener(listener: (this: HTMLElement, event: Event) => void): () => void;
    /**
     * @returns Stop listening function.
     */
    protected _addFullscreenErrorEventListener(listener: (this: HTMLElement, event: Event) => void): () => void;
    enterFullscreen(): Promise<void>;
    protected _makeEnterFullscreenRequest(): Promise<void>;
    protected _handleFullscreenChange(event: Event): void;
    protected _handleFullscreenError(event: Event): void;
    exitFullscreen(): Promise<void>;
    protected _makeExitFullscreenRequest(): Promise<void>;
    protected _shouldOrientScreen(): boolean;
    protected _lockScreenOrientation(): Promise<void>;
    protected _unlockScreenOrientation(): Promise<void>;
    /**
     * @throws Will throw if Fullscreen API is not enabled or supported.
     */
    protected _throwIfNoFullscreenSupport(): void;
}

export declare type FullscreenControllerHost = ReactiveElement & {
    enterFullscreen(): Promise<void>;
    exitFullscreen(): Promise<void>;
};

/**
 * Fired when an error occurs either entering or exiting fullscreen. This will generally occur
 * if the user has not interacted with the page yet.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type FullscreenErrorEvent = VdsEvent<unknown>;

export declare type FullscreenEvents = {
    'vds-fullscreen-change': FullscreenChangeEvent;
    'vds-fullscreen-error': FullscreenErrorEvent;
    'vds-fullscreen-support-change': FullscreenSupportChange;
};

/**
 * Fired when fullscreen support has changed. To be clear, support does not guarantee the
 * fullscreen request happening, as the browser might still reject the request if it's attempted
 * without user interaction. The event detail is a `boolean` that indicates whether it's
 * supported (`true`), or not (`false`).
 *
 * @event
 */
export declare type FullscreenSupportChange = VdsEvent<boolean>;

export declare function get<T>(store: ReadableStore<T>): T;

export declare function getElementAttributes(elementCtor: typeof LitElement): Set<string>;

/**
 * @see {@link https://github.com/video-dev/hls.js/blob/master/src/is-supported.ts}
 */
export declare function getMediaSource(): typeof MediaSource | undefined;

/**
 * Get the number of decimal places in the given `num`.
 *
 * @example `1 -> 0`
 * @example `1.0 -> 0`
 * @example `1.1 -> 1`
 * @example `1.12 -> 2`
 */
export declare function getNumberOfDecimalPlaces(num: number): number;

/**
 * Walks up the event chain (following each `triggerEvent`) and returns the origin event
 * that started the chain.
 */
export declare function getOriginEvent(event: VdsEvent): Event | undefined;

/**
 * Returns elements assigned to the given slot in the shadow root. Filters out all nodes
 * which are not of type `Node.ELEMENT_NODE`.
 *
 * @param el - The element containing the slot.
 * @param name - The name of the slot (optional).
 */
export declare function getSlottedChildren(el: HTMLElement, name?: string): Element[];

/**
 * @see {@link https://github.com/video-dev/hls.js/blob/master/src/is-supported.ts}
 */
export declare function getSourceBuffer(): typeof SourceBuffer | undefined;

export declare const GROUPED_LOG_ID: unique symbol;

export declare type GroupedLog = {
    readonly [GROUPED_LOG_ID]: true;
    readonly title: string;
    readonly logs: ({
        label?: string;
        data: any[];
    } | GroupedLog)[];
    log(...data: any[]): GroupedLog;
    labelledLog(label: string, ...data: any[]): GroupedLog;
    groupStart(title: string): GroupedLog;
    groupEnd(): GroupedLog;
};

export declare function groupedLog(title: string, parent?: GroupedLog): GroupedLog;

export declare type GroupedLogDispatch = {
    readonly [GROUPED_LOG_ID]: true;
    readonly title: string;
    readonly logs: ({
        label?: string;
        data: any[];
    } | GroupedLog)[];
    log(...data: any[]): GroupedLogDispatch;
    labelledLog(label: string, ...data: any[]): GroupedLogDispatch;
    groupStart(title: string): GroupedLogDispatch;
    groupEnd(): GroupedLogDispatch;
    dispatch(): void;
};

/**
 * Whether the given `prop` is a direct property of the given object (`obj`).
 */
export declare const hasOwnProperty: <T>(obj: T, prop: keyof T) => prop is keyof T;

/**
 * Whether a trigger event with the given `eventType` exists can be found in the event chain.
 *
 * @param event - The event on which to look for a trigger event.
 * @param eventType - The type of event to find.
 */
export declare function hasTriggerEvent<T extends keyof HTMLElementEventMap>(event: Event, eventType: T): boolean;

export declare function hideDocumentScrollbar(hidden: boolean): void;

/**
 * Creates and returns a `RequestQueue` that starts when the given `host` element connects
 * to the DOM, and destroys it when the `host`disconnects from the DOM.
 */
export declare function hostRequestQueue(host: ReactiveControllerHost): RequestQueue;

export declare type HTMLElementEventCallbackMap = {
    [EventType in keyof HTMLElementEventMap]?: (event: HTMLElementEventMap[EventType]) => void | Promise<void>;
};

/**
 * For AttributeParts, sets the attribute if the value is defined and non-empty, and removes
 * the attribute if the value is undefined or empty (`''`).
 *
 * For other part types, this directive is a no-op.
 */
export declare function ifNonEmpty(value: string | undefined): string | nothing;

/**
 * A variant of `lit/directives/if-defined` which stops rendering if the given value is
 * not a number in addition to  `null`/`undefined`.
 *
 * For AttributeParts, sets the attribute if the value is defined and a number, and removes
 * the attribute if the value is undefined not a number.
 *
 * For other part types, this directive is a no-op.
 */
export declare function ifNumber(value: number | null | undefined): number | nothing;

/**
 * `IntersectionController` integrates an `IntersectionObserver` with a host element's reactive
 * update lifecycle.
 *
 * This is can be used to detect when a target element "intersects" is visible inside of) another
 * element or the viewport by default, where intersect means "visible inside of."
 *
 * The controller can specify a `target` element to observe and the configuration options to
 * pass to the `IntersectionObserver`. The `observe` method can be called to observe
 * additional elements.
 *
 * When a change is detected, the controller's given `callback` function is used to process the
 * result into a value which is stored on the controller. The controller's `value` is usable
 * during the host's update cycle.
 */
export declare class IntersectionController implements ReactiveController {
    protected readonly _host: ReactiveControllerHost & EventTarget;
    protected readonly _callback: IntersectionValueCallback;
    protected readonly _logger: LogDispatcher | undefined;
    protected _target: Element | undefined;
    protected _observer: IntersectionObserver;
    protected _skipInitial: boolean;
    /**
     * Flag used to help manage calling the `callback` when observe is called and `skipInitial` is
     * set to true. Note that unlike the other observers `IntersectionObserver` *does* report its
     * initial state (e.g. whether or not there is an intersection). This flag is used to avoid
     * handling this state if `skipInitial` is true.
     */
    protected _unobservedUpdate: boolean;
    /**
     * The result of processing the observer's changes via the `callback` function.
     */
    value?: unknown;
    constructor(_host: ReactiveControllerHost & EventTarget, config?: IntersectionControllerConfig, _callback?: IntersectionValueCallback, _logger?: LogDispatcher | undefined);
    /**
     * Process the observer's changes with the controller's `callback` function to produce a
     * result stored in the `value` property.
     */
    protected handleChanges(entries: IntersectionObserverEntry[]): void;
    hostConnected(): void;
    hostDisconnected(): void;
    hostUpdated(): Promise<void>;
    /**
     * Observe the target element. The controller's `target` is automatically observed when the
     * host connects.
     *
     * @param target - Element to observe
     */
    observe(target: Element): () => void;
    /**
     * Disconnects the observer. This is done automatically when the host disconnects.
     */
    protected _disconnect(): void;
}

/**
 * The config options for a `IntersectionController`.
 */
export declare type IntersectionControllerConfig = {
    /**
     * The element that is used as the viewport for checking visibility of the target. Must be the
     * ancestor of the target. Defaults to the browser viewport if not specified or if `null`.
     */
    root?: Element | Document | null;
    /**
     * Margin around the root. Can have values similar to the CSS margin property, e.g.
     * "10px 20px 30px 40px" (top, right, bottom, left). The values can be percentages. This set
     * of values serves to grow or shrink each side of the root element's bounding box before
     * computing intersections. Defaults to all zeros.
     */
    rootMargin?: string;
    /**
     * Either a single number or an array of numbers which indicate at what percentage of the
     * target's visibility the observer's callback should be executed. If you only want to detect
     * when visibility passes the `50%` mark, you can use a value of `0.5`. If you want the callback
     * to run every time visibility passes another `25%`, you would specify the array
     * `[0, 0.25, 0.5, 0.75, 1]`.
     *
     * The default is `0` (meaning as soon as even one pixel is visible, the callback will be run).
     * A value of `1.0` means that the threshold isn't considered passed until every pixel is
     * visible.
     */
    threshold?: number | number[];
    /**
     * The element to observe. In addition to configuring the target here, the `observe` method
     * can be called to observe additional targets. When not specified, the target defaults to
     * the `host`. If set to `null`, no target is automatically observed. Only the configured
     * target will be re-observed if the host connects again after unobserving via disconnection.
     */
    target?: Element | null;
    /**
     * An IntersectionObserver reports the initial intersection state when observe is called.
     * Setting this flag to true skips processing this initial state for cases when this is
     * unnecessary.
     */
    skipInitial?: boolean;
};

/**
 * The callback function for a `IntersectionController`.
 */
export declare type IntersectionValueCallback = (...args: Parameters<IntersectionObserverCallback>) => unknown;

export declare const IS_ANDROID: boolean;

export declare const IS_CHROME: boolean;

export declare const IS_CLIENT: boolean;

export declare const IS_FIREFOX: boolean;

export declare const IS_IOS: boolean;

export declare const IS_IPHONE: boolean;

export declare const IS_MOBILE: boolean;

export declare const IS_SAFARI: boolean;

export declare function isArray(value: unknown): value is unknown[];

export declare function isBoolean(value: any): value is boolean;

export declare function isContext<T extends Context<any>>(context: unknown | T): context is T;

export declare function isFunction(value: any): value is Function;

export declare function isGroupedLog(data: unknown): data is GroupedLog;

/**
 * Whether `hls.js` is supported in this environment.
 *
 * @see {@link https://github.com/video-dev/hls.js/blob/master/src/is-supported.ts}
 */
export declare function isHlsjsSupported(): boolean;

export declare function isKeyboardClick(event: Event | undefined): boolean;

export declare function isKeyboardEvent(event: Event | undefined): event is KeyboardEvent;

export declare function isMouseEvent(event: Event | undefined): event is MouseEvent;

export declare function isNil(value: unknown): value is null | undefined;

export declare function isNull(value: unknown): value is null;

export declare function isNumber(value: any): value is number;

export declare function isObject(value: any): value is object;

/**
 * Check if the given `value` is JSON or a POJO.
 *
 * @param value - The value to check.
 */
export declare function isObjOrJSON(value: unknown): boolean;

export declare function isPointerEvent(event: Event | undefined): event is PointerEvent;

/**
 * Reduced motion iOS & MacOS setting.
 *
 * @see {@link https://webkit.org/blog/7551/responsive-design-for-motion/}
 */
export declare function isReducedMotionPreferred(): boolean;

export declare function isScalarArrayEqual<T extends string | number | boolean>(arrayA: T[], arrayB: T[]): boolean;

export declare function isString(value: any): value is string;

export declare function isTouchEvent(event: Event | undefined): event is TouchEvent;

export declare function isUndefined(value: unknown): value is undefined;

export declare function isVdsEvent(event: Event | undefined): event is VdsEvent<unknown>;

export declare function isWindow(value: unknown): value is Window;

/**
 * Converts a kebab-case string to camelCase.
 *
 * @example `my-property -> myProperty`
 */
export declare function kebabToCamelCase(str: string): string;

/**
 * Converts a kebab-case string to PascalCase.
 *
 * @example `myProperty -> MyProperty`
 */
export declare function kebabToPascalCase(str: string): string;

/**
 * Converts a kebab-case string to Title Case.
 *
 * @example `myProperty -> My Property`
 */
export declare function kebabToTitleCase(str: string): string;

export declare function keysOf<T>(obj: T): (keyof T)[];

export declare type KeysOfType<O, T> = {
    [P in keyof O]: O[P] extends T ? P : never;
};

/**
 * Listens to an event on the given `target` and returns a cleanup function to stop listening.
 *
 * @param target - The target to listen for the events on.
 * @param type - The name of the event to listen to.
 * @param listener - The function to be called when the event is fired.
 * @param options - Configures the event listener.
 * @returns Stop listening cleanup function.
 * @example
 * ```ts
 * const disposeListener = listen(window, 'resize', () => {});
 *
 * // Stop listening.
 * disposeListener();
 * ```
 */
export declare function listen<EventType extends keyof HTMLElementEventCallbackMap>(target: EventTarget, type: EventType, listener: HTMLElementEventCallbackMap[EventType], options?: boolean | EventListenerOptions | AddEventListenerOptions): () => void;

/**
 * Load image avoiding xhr/fetch CORS issues. Server status can't be obtained this way
 * unfortunately, so this uses "naturalWidth" to determine if the image has been loaded. By
 * default it checks if it is at least 1px.
 *
 * @param src - The URL of where the image resource is located.
 * @param minWidth - The minimum width for a valid image to be loaded.
 */
export declare function loadImage(src: string, minWidth?: number): Promise<HTMLImageElement>;

/**
 * Loads a script into the DOM.
 *
 * @param src - The URL of where the script is located.
 */
export declare function loadScript(src: string): Promise<unknown>;

export declare class LogController {
    protected readonly _host: ReactiveControllerHost & EventTarget;
    logLevel: LogLevel;
    protected _disposal: DisposalBin;
    constructor(_host: ReactiveControllerHost & EventTarget);
    protected _start(): void;
    protected _stop(): void;
    protected _logGroup(level: LogLevel, groupedLog: GroupedLog): void;
    protected _log(level: LogLevel, ...data: any[]): void;
    protected _labelledLog(label: string, ...data: any[]): void;
    protected _logStackTrace(): void;
    protected _logTimeDiff(): void;
    protected _lastLogTimestamp?: number;
    protected _getLastLogTimeDiff(): string;
}

/**
 * Simple facade that simplifies dispatching log events from a given `host` element.
 */
export declare class LogDispatcher {
    protected readonly _host: EventTarget;
    constructor(_host: EventTarget);
    error(...data: any[]): void;
    warn(...data: any[]): void;
    info(...data: any[]): void;
    debug(...data: any[]): void;
    errorGroup(title: string): GroupedLogDispatch;
    warnGroup(title: string): GroupedLogDispatch;
    infoGroup(title: string): GroupedLogDispatch;
    debugGroup(title: string): GroupedLogDispatch;
    protected _dispatch(level: LogLevel, ...data: any[]): void;
    protected _groupDispatcher(level: LogLevel, title: string, rootGroup?: GroupedLog, parentGroup?: GroupedLog): GroupedLogDispatch;
}

export declare function logElementLifecycle(_host: ReactiveControllerHost & EventTarget): void;

/**
 * @event
 * @bubbles
 * @composed
 */
export declare type LogEvent = VdsEvent<{
    /**
     * The log level.
     *
     * @defaultValue 'info'
     */
    level?: LogLevel;
    /**
     * Data to be logged.
     *
     * @defaultValue undefined
     */
    data?: any[];
}>;

export declare function logEvent(level: LogLevel, ...data: any[]): LogEvent;

export declare type LoggerEvents = {
    'vds-log': LogEvent;
};

export declare type LogLevel = 'silent' | 'error' | 'warn' | 'info' | 'debug';

export declare const LogLevelColor: Readonly<{
    silent: "white";
    error: "hsl(6, 58%, 50%)";
    warn: "hsl(51, 58%, 50%)";
    info: "hsl(219, 58%, 50%)";
    debug: "hsl(280, 58%, 50%)";
}>;

export declare const LogLevelValue: Readonly<{
    silent: 0;
    error: 1;
    warn: 2;
    info: 3;
    debug: 4;
}>;

export declare function lowercaseFirstLetter(str: string): string;

export declare function noop(...args: any[]): void;

export declare const normalizeLineBreaks: (str: string) => string;

export declare function notEqual(valueA: unknown, valueB: unknown): boolean;

/**
 * If an object return otherwise try to parse it as json.
 */
export declare function objOrParseJSON<T>(value: unknown): T | undefined;

export declare function observeAttributes<T extends string>(element: Element, attributes: readonly T[], onChange: (attrName: T, attrValue: string | null) => void, { skipInitial }?: {
    skipInitial?: boolean | undefined;
}): MutationObserver;

/**
 * The opposite of `pick`; this method creates an `object` composed of the own and inherited
 * enumerable property paths of object that are not omitted.
 */
export declare function omit<T>(obj: T, keys: (keyof T)[]): Omit<T, ArrayElement<typeof keys>>;

export declare const ORIGIN: string | undefined;

export declare type OrphanContextConsumer = {
    host: ContextConsumerHost;
    setValue(value: any): void;
};

/**
 * ðŸ¤– This section was generously ~stolen from~... err... donated by Furf. Cheers!
 *
 * @see https://github.snooguts.net/david-furfero/reddit-media-player/blob/main/src/lib/formatTime/index.ts
 */
/**
 * Casts a number to a string and pads it to match the given `expectedLength`.
 *
 * @param num - A number to pad.
 * @param expectedLength - The expected length of the numbers as a string.
 */
export declare function padNumberWithZeroes(num: number, expectedLength: number): string;

/**
 * `PageController` detects page state or visibility changes for the life of the given `host`
 * element.
 *
 * @see {@link PageState}
 * @see {@link PageVisibility}
 * @see https://developers.google.com/web/updates/2018/07/page-lifecycle-api
 */
export declare class PageController implements ReactiveController {
    protected readonly _host: ReactiveControllerHost & EventTarget;
    protected readonly _callback: PageControllerCallback;
    protected readonly _logger: LogDispatcher | undefined;
    protected _state: PageState;
    protected _visibility: PageVisibility;
    protected _disposal: DisposalBin;
    protected _safariBeforeUnloadTimeout?: any;
    get state(): PageState;
    get visibility(): PageVisibility;
    constructor(_host: ReactiveControllerHost & EventTarget, _callback: PageControllerCallback, _logger?: LogDispatcher | undefined);
    hostConnected(): void;
    hostDisconnected(): void;
    protected _handlePageEvent(event: Event): void;
    protected _triggerCallback(): void;
    protected _determinePageState(event?: Event): PageState;
}

/**
 * The callback function for a `PageController`. This is called when either the page
 * state or visibility changes.
 *
 * @see {@link PageState}
 * @see {@link PageVisibility}
 */
export declare type PageControllerCallback = ({ state: PageState, visibility: PageVisibilityState, }: {
    state: any;
    visibility: any;
}) => void;

/**
 * The current page state. Important to note we only account for a subset of page states, as
 * the rest aren't valuable to the player at the moment.
 *
 * - **active:** A page is in the active state if it is visible and has input focus.
 * - **passive:** A page is in the passive state if it is visible and does not have input focus.
 * - **hidden:** A page is in the hidden state if it is not visible.
 *
 * @see https://developers.google.com/web/updates/2018/07/page-lifecycle-api#states
 */
export declare type PageState = 'active' | 'passive' | 'hidden';

/**
 * The current page visibility state.
 *
 * - **visible:** The page content may be at least partially visible. In practice, this means that
 * the page is the foreground tab of a non-minimized window.
 * - **hidden:** The page content is not visible to the user. In practice this means that the
 * document is either a background tab or part of a minimized window, or the OS screen lock is
 * active.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilityState
 */
export declare type PageVisibility = 'visible' | 'hidden';

export declare type Params = Record<string, unknown>;

export declare type ParsedTime = {
    [P in TimeUnit]: number;
};

/**
 * Returns a simple key/value map and duplicate keys are merged into an array.
 *
 * @param qs - The query string to parse.
 * @see {@link https://github.com/ampproject/amphtml/blob/c7c46cec71bac92f5c5da31dcc6366c18577f566/src/url-parse-query-string.js#L31}
 */
export declare function parseQueryString<T>(qs?: string): T;

/**
 * Parses the given `duration` into the following units of time: hours, minutes,
 * seconds, fraction (fraction of a second).
 *
 * @param duration - The length of time to parse in seconds.
 */
export declare function parseTime(duration: number): ParsedTime;

/**
 * Creates an object composed of the picked `object` properties.
 */
export declare function pick<T>(obj: T, keys: (keyof T)[]): Pick<T, ArrayElement<typeof keys>>;

/**
 * Notifies the browser to start establishing a connection with the given URL.
 */
export declare function preconnect(url: string, rel?: 'preconnect' | 'prefetch' | 'preload', isClient?: boolean): boolean;

export declare type ProvideContextOptions<T> = {
    /**
     * A unique identifier used to pair a context provider and consumer.
     */
    id: symbol;
};

/**
 * Requests an animation frame and waits for it to be resolved.
 *
 * @param callback - Invoked on the next animation frame.
 */
export declare function raf(callback?: () => void): Promise<number>;

/**
 * Creates a throttled function that only invokes `func` at most once per animation frame.
 *
 * @param func - The function to throttle.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}
 */
export declare function rafThrottle<Fn extends (...args: any[]) => void>(func: Fn): RafThrottledFunction<Fn>;

export declare type RafThrottledFunction<Fn extends (...args: any) => void> = Fn & {
    cancel: () => void;
    pending: () => boolean;
};

/**
 * Creates a `Readable` store that allows reading by subscription.
 */
export declare function readable<T>(value?: T, start?: StoreStartStopNotifier<T>): ReadableStore<T>;

/** Readable interface for subscribing. */
export declare type ReadableStore<T> = {
    initialValue: T | undefined;
    /**
     * Subscribe on value changes.
     * @param run - subscription callback
     * @param invalidate - cleanup callback
     */
    subscribe(this: void, run: StoreSubscriber<T>, invalidate?: StoreInvalidator<T>): StoreUnsubscriber;
};

export declare type ReadableStoreRecord = {
    [prop: string]: ReadableStore<any>;
};

export declare function redispatchEvent(target: EventTarget, event: Event | CustomEvent | VdsEvent): void;

/**
 * Triggered after the page has finished loaded and during the browser's idle period.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback}
 */
declare function requestIdleCallback_2(callback: () => void): void;
export { requestIdleCallback_2 as requestIdleCallback }

export declare class RequestQueue {
    protected readonly _requestQueue: Map<string | symbol, () => void | Promise<void>>;
    protected _requestKeys: (string | symbol)[];
    protected _pendingFlush: DeferredPromise<void, void>;
    protected _isServing: boolean;
    /**
     * Whether items in the queue are being served immediately, otherwise they're queued to
     * be processed later.
     */
    get isServing(): boolean;
    /**
     * The number of callbacks that are currently in queue.
     */
    get size(): number;
    /**
     * Waits for the queue to be flushed (ie: start serving).
     */
    waitForFlush(): Promise<void>;
    /**
     * Queue the given `callback` to be invoked at a later time by either calling the `serve()` or
     * `start()` methods. If the queue has started serving (i.e., `start()` was already called),
     * then the callback will be invoked immediately.
     *
     * @param key - Uniquely identifies this callback so duplicates are ignored.
     * @param callback - The function to call when this item in the queue is being served.
     */
    queue(key: string | symbol, callback: () => void): void;
    /**
     * Invokes the callback with the given `key` in the queue (if it exists).
     */
    serve(key: string | symbol): void;
    /**
     * Flush all queued items and start serving future requests immediately until `stop()` is called.
     */
    start(): void;
    protected _flush(): void;
    protected _empty(): void;
    protected _release(): void;
    /**
     * Stop serving requests, they'll be queued until you begin processing again by calling
     * `start()`.
     */
    stop(): void;
    /**
     * Stop serving requests, empty the request queue, and release any promises waiting for the
     * queue to flush.
     */
    destroy(): void;
}

/**
 * Round a number to the given number of `decimalPlaces`.
 */
export declare function round(num: number, decimalPlaces?: number): number;

/**
 * Registers a custom element in the CustomElementRegistry. By "safely" we mean:
 *
 * - Called only client-side (`window` is defined).
 * - The element is only registered if it hasn't been registered before under the given `name`.
 *
 * @param name - A string representing the name you are giving the element.
 * @param constructor - A class object that defines the behavior of the element.
 */
export declare function safelyDefineCustomElement(name: string, constructor: CustomElementConstructor, isClient?: boolean): void;

export declare function safeNotEqual(a: any, b: any): any;

export declare type ScopedDiscoveryEvent<Discoverable extends Element = Element> = {
    TYPE: keyof HTMLElementEventMap;
    new (...args: any): DiscoveryEvent<Discoverable>;
};

/**
 * The screen orientation type.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
 * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
 */
declare type ScreenOrientation_2 = 
/**
* Landscape-primary is an orientation where the screen width is greater than the screen height.
* If the device's natural orientation is landscape, then it is in landscape-primary when held
* in that position. If the device's natural orientation is portrait, the user agent sets
* landscape-primary from the two options as shown in the screen orientation values table.
*/
'landscape-primary'
/**
* Landscape-secondary is an orientation where the screen width is greater than the screen
* height. If the device's natural orientation is landscape, it is in landscape-secondary when
* rotated 180Âº from its natural orientation. If the device's natural orientation is portrait,
* the user agent sets landscape-secondary from the two options as shown in the screen
* orientation values table.
*/
| 'landscape-secondary'
/**
* Portrait-primary is an orientation where the screen width is less than or equal to the screen
* height. If the device's natural orientation is portrait, then it is in portrait-primary when
* held in that position. If the device's natural orientation is landscape, the user agent sets
* portrait-primary from the two options as shown in the screen orientation values table.
*/
| 'portrait-primary'
/**
* Portrait-secondary is an orientation where the screen width is less than or equal to the
* screen height. If the device's natural orientation is portrait, then it is in
* portrait-secondary when rotated 180Âº from its natural position. If the device's natural
* orientation is landscape, the user agent sets portrait-secondary from the two options as
* shown in the screen orientation values table.
*/
| 'portrait-secondary';
export { ScreenOrientation_2 as ScreenOrientation }

/**
 * Fired when the current screen orientation changes.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type ScreenOrientationChangeEvent = VdsEvent<ScreenOrientation_2>;

/**
 * This class contains logic for managing the window's screen orientation.
 *
 * @example
 * ```ts
 * import { LitElement } from 'lit';
 * import { ScreenOrientationController } from '@vidstack/player';
 *
 * class MyElement extends LitElement {
 *   screenOrientationController = new ScreenOrientationController(this);
 * }
 * ```
 */
export declare class ScreenOrientationController {
    protected readonly _host: ReactiveElement;
    protected readonly _listenerDisposal: DisposalBin;
    protected _screenOrientation?: ScreenOrientation_2;
    protected _isScreenOrientationLocked: boolean;
    protected readonly _logger: LogDispatcher | undefined;
    constructor(_host: ReactiveElement);
    protected _handleHostConnected(): Promise<void>;
    /**
     * Dispose of any event listeners and unlock screen orientation (if locked).
     */
    protected _handleHostDisconnected(): Promise<void>;
    /**
     * The current screen orientation. It will return `undefined` if the Screen Orientation API
     * is not available.
     */
    get currentOrientation(): ScreenOrientation_2 | undefined;
    /**
     * Whether the native Screen Orientation API is available.
     */
    get canOrient(): boolean;
    /**
     * Whether the screen orientation is currently locked.
     *
     * @defaultValue false
     */
    get isLocked(): boolean;
    /**
     * Locks the orientation of the player to the desired orientation type using the
     * Screen Orientation API. This method will throw an error if the API is unavailable.
     *
     * @param lockType - The screen lock orientation type.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
     * @see https://w3c.github.io/screen-orientation
     */
    lock(lockType: ScreenOrientationLock): Promise<void>;
    /**
     * Unlocks the orientation of the player to it's default state using the Screen Orientation
     * API. This method will throw an error if the API is unavailable.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
     * @see https://w3c.github.io/screen-orientation
     */
    unlock(): Promise<void>;
    protected _addScreenOrientationEventListeners(): void;
    /**
     * @returns Stop listening function.
     */
    protected _addScreenOrientationChangeEventListener(): () => void;
    protected _handleOrientationChange(event: Event): void;
    protected _updateScreenOrientation(): void;
    /**
     * @throws Will throw if Screen Orientation API is unavailable.
     */
    protected _throwIfScreenOrientationUnavailable(): void;
}

export declare type ScreenOrientationEvents = {
    'vds-screen-orientation-change': ScreenOrientationChangeEvent;
    'vds-screen-orientation-lock-change': ScreenOrientationLockChangeEvent;
};

/**
 * The screen orientation lock type.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
 * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
 */
export declare type ScreenOrientationLock = 
/**
* Any is an orientation that means the screen can be locked to any one of portrait-primary,
* portrait-secondary, landscape-primary and landscape-secondary.
*/
'any'
/**
* Landscape is an orientation where the screen width is greater than the screen height and
* depending on platform convention locking the screen to landscape can represent
* landscape-primary, landscape-secondary or both.
*/
| 'landscape'
/**
* Landscape-primary is an orientation where the screen width is greater than the screen height.
* If the device's natural orientation is landscape, then it is in landscape-primary when held
* in that position. If the device's natural orientation is portrait, the user agent sets
* landscape-primary from the two options as shown in the screen orientation values table.
*/
| 'landscape-primary'
/**
* Landscape-secondary is an orientation where the screen width is greater than the screen
* height. If the device's natural orientation is landscape, it is in landscape-secondary when
* rotated 180Âº from its natural orientation. If the device's natural orientation is portrait,
* the user agent sets landscape-secondary from the two options as shown in the screen
* orientation values table.
*/
| 'landscape-secondary'
/**
* Natural is an orientation that refers to either portrait-primary or landscape-primary
* depending on the device's usual orientation. This orientation is usually provided by the
* underlying operating system.
*/
| 'natural'
/**
* Portrait is an orientation where the screen width is less than or equal to the screen height
* and depending on platform convention locking the screen to portrait can represent
* portrait-primary, portrait-secondary or both.
*/
| 'portrait'
/**
* Portrait-primary is an orientation where the screen width is less than or equal to the screen
* height. If the device's natural orientation is portrait, then it is in portrait-primary when
* held in that position. If the device's natural orientation is landscape, the user agent sets
* portrait-primary from the two options as shown in the screen orientation values table.
*/
| 'portrait-primary'
/**
* Portrait-secondary is an orientation where the screen width is less than or equal to the
* screen height. If the device's natural orientation is portrait, then it is in
* portrait-secondary when rotated 180Âº from its natural position. If the device's natural
* orientation is landscape, the user agent sets portrait-secondary from the two options as
* shown in the screen orientation values table.
*/
| 'portrait-secondary';

/**
 * Fired when the current screen orientation lock changes.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type ScreenOrientationLockChangeEvent = VdsEvent<ScreenOrientationLock>;

export declare class ScriptLoader {
    private static pendingRequests;
    static load(src: string): Promise<void>;
}

export declare function scrollIntoCenter(scroll: Element | Window, element: Element, options?: {
    offset?: number;
    behaviour?: 'auto' | 'smooth';
}): void;

/**
 * Serializes the given params into a query string.
 */
export declare function serializeQueryString(params: Params): string;

/**
 * Sets an attribute on the given `element`. If the `attrValue` is `undefined`or `null` the
 * attribute will be removed.
 *
 * @param element - The element to set the attribute on.
 * @param attrName - The name of the attribute.
 * @param attrValue - The value of the attribute.
 */
export declare function setAttribute(element: Element, attrName: string, attrValue?: string | boolean | undefined | null): void;

/**
 * Sets an attribute on the given `element` if it does not have the attribute set.
 *
 * @param element - The element to set the attribute on.
 * @param attrName - The name of the attribute.
 * @param attrValue - The value of the attribute.
 */
export declare function setAttributeIfEmpty(element: Element, attrName: string, attrValue: string): void;

/**
 * Sets a CSS property on the given `element`.
 *
 * @param element - The element to set the CSS property on.
 * @param name - The name of the CSS property.
 * @param value - The value of the CSS property.
 * @param prefix - The library CSS property prefix (default: 'vds').
 */
export declare function setCSSProperty(element: HTMLElement, name: string, value?: string | null, prefix?: string): void;

/**
 * Sorts an array of objects by a given property known as the sort key.
 */
export declare const sortObjectsBy: <T>(objects: T[], sortKey: keyof T) => T[];

export declare function splitLineBreaks(str: string): string[];

/** Cleanup logic callback. */
export declare type StoreInvalidator<T> = (value?: T) => void;

/**
 * Helper function to subscribe to an individual store record item for the life of the given
 * `host` element.
 *
 * @example
 * ```ts
 * import { LitElement } from 'lit';
 * import { storeRecordSubscription, mediaStoreContext } from '@vidstack/player';
 *
 * class MyElement extends LitElement {
 *   constructor() {
 *     super();
 *     storeRecordSubscription(this, mediaStoreContext, 'paused', ($value) => {
 *       // ...
 *     });
 *   }
 * }
 * ```
 */
export declare function storeRecordSubscription<StoreRecord extends ReadableStoreRecord, Key extends keyof StoreRecord>(host: StoreSubscriptionHost, store: StoreRecord | Context<StoreRecord>, key: Key, onChange: (value: StoreValue<StoreRecord[Key]>) => void): void;

/** One or more `Readable`s. */
export declare type Stores = ReadableStore<any> | [ReadableStore<any>, ...Array<ReadableStore<any>>] | Array<ReadableStore<any>>;

/** Start and stop notification callbacks. */
export declare type StoreStartStopNotifier<T> = (set: StoreSubscriber<T>) => StoreUnsubscriber | void;

/** Callback to inform of a value updates. */
export declare type StoreSubscriber<T> = (value: T) => void;

/**
 * Helper function to subscribe to a store for the life of the given `host` element, meaning
 * when it's disconnected from the DOM, the subscription is destroyed.
 *
 * @example
 * ```ts
 * import { LitElement } from 'lit';
 * import { storeSubscription } from '@vidstack/player';
 *
 * class MyElement extends LitElement {
 *   constructor() {
 *     super();
 *     storeSubscription(this, <<store>>, ($value) => {
 *       // ...
 *     });
 *   }
 * }
 * ```
 */
export declare function storeSubscription<T>(host: StoreSubscriptionHost, store: ReadableStore<T> | Context<ReadableStore<T>>, onChange: (value: T) => void): void;

export declare type StoreSubscriptionHost = ReactiveControllerHost & Node;

/** One or more values from `Readable` stores. */
export declare type StoresValues<T> = T extends ReadableStore<infer U> ? U : {
    [K in keyof T]: T[K] extends ReadableStore<infer U> ? U : never;
};

/** Unsubscribes from value updates. */
export declare type StoreUnsubscriber = () => void;

/** Callback to update a value. */
export declare type StoreUpdater<T> = (value: T) => T;

export declare type StoreValue<T> = T extends ReadableStore<infer U> ? U : never;

/** Pair of subscriber and invalidator. */
export declare type SubscribeInvalidateTuple<T> = [StoreSubscriber<T>, StoreInvalidator<T>];

export { throttle }

/**
 * Wraps a promise so it can timeout.
 */
export declare function timedPromise<T>(promise: Promise<T>, timeout: number, timeoutMsg: string): Promise<T>;

export declare enum TimeUnit {
    Hours = "hours",
    Minutes = "minutes",
    Seconds = "seconds",
    /**
     * Represents a fraction of a second in decimal form.
     */
    Fraction = "fraction"
}

/**
 * Attempts to safely decode a URI component, on failure it returns the given fallback.
 */
export declare function tryDecodeURIComponent(component: string, fallback?: string, isClient?: boolean): string;

/**
 * Attempt to parse json into a POJO.
 *
 * @param json - The JSON object to parse.
 */
export declare function tryParseJSON<T>(json: unknown): T | undefined;

export declare const UA: string;

/**
 * Unwraps a store record using a proxy and returning the underlying value when a key is accessed.
 */
export declare function unwrapStoreRecord<StoreRecord extends ReadableStoreRecord>(store: StoreRecord): {
    [Prop in keyof StoreRecord]: StoreValue<StoreRecord[Prop]>;
};

export declare function uppercaseFirstLetter(str: string): string;

export declare type Values<T> = T extends {
    [k: string]: infer V;
} ? V : never;

export declare class VdsEvent<DetailType = unknown> extends CustomEvent<DetailType> {
    /**
     * The preceding event that was responsible for this event being fired.
     */
    readonly triggerEvent?: Event;
    /**
     * Walks up the event chain (following each `triggerEvent`) and returns the origin event
     * that started the chain.
     */
    get originEvent(): Event;
    /**
     * Walks up the event chain (following each `triggerEvent`) and determines whether the initial
     * event was triggered by the end user (ie: check whether `isTrusted` on the `originEvent` `true`).
     */
    get isOriginTrusted(): boolean;
    constructor(type: string, eventInit?: VdsEventInit<DetailType>);
}

/**
 * Helps build a `VdsEvent` with type safety.
 */
export declare function vdsEvent<EventType extends keyof VdsElementEventMap>(type: EventType, eventInit?: ExtractEventInit<VdsElementEventMap[EventType]>): VdsElementEventMap[EventType];

export declare type VdsEventInit<DetailType> = CustomEventInit<DetailType> & {
    readonly triggerEvent?: Event;
};

export declare function wait(delay: number): Promise<void>;

export declare function waitForEvent<EventType extends keyof HTMLElementEventMap>(target: EventTarget, type: EventType, options?: (EventListenerOptions | AddEventListenerOptions) & {
    timeout?: number;
}): Promise<HTMLElementEventMap[EventType]>;

export declare type WalkCallbackTypes<T> = T | false | undefined | null | void;

/**
 * Walks an event chain on a given `event`, and invokes the given `callback` for each
 * trigger event.
 *
 * @param event - The event on which to follow the chain.
 * @param callback - Invoked for each trigger event in the chain. If a `value` is returned by
 * this callback, the walk will end and `[event, value]` will be returned.
 */
export declare function walkTriggerEventChain<T>(event: Event, callback: (event: Event) => NonNullable<T> | void): [event: Event, value: NonNullable<T>] | undefined;

/**
 * Walks up the DOM tree from the given node's parent element up to the root. The `onDiscover`
 * callback can return `true` to skip walking up the rest of tree.
 */
export declare function walkUpDOMTree(node: HTMLElement, onDiscover: (node: HTMLElement) => void | boolean): void;

export declare function wasEnterKeyPressed(event: Event | undefined): boolean;

export declare function wasEscapeKeyPressed(event: Event | undefined): boolean;

/**
 * Mixes in a `focus()` method that focuses the first focusable element in the shadow DOM.
 * Technically a polyfill for `shadowRoot.delegatesFocus`.
 *
 * @param Base - The constructor to mix into.
 * @see https://github.com/carbon-design-system/carbon-web-components
 */
export declare function WithFocus<T extends Constructor<LitElement>>(Base: T): T;

/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 */
export declare function writable<T>(value?: T, start?: StoreStartStopNotifier<T>): WritableStore<T>;

/** Writable interface for both updating and subscribing. */
export declare type WritableStore<T> = ReadableStore<T> & {
    /**
     * Set value and inform subscribers.
     * @param value - to set
     */
    set(this: void, value: T): void;
    /**
     * Update value using callback and inform subscribers.
     * @param updater - callback
     */
    update(this: void, updater: StoreUpdater<T>): void;
};

export declare type WritableStoreRecord = {
    [prop: string]: WritableStore<any>;
};

export { }
