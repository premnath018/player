import {
  VideoElement
} from "./chunk.WWUUJDIN.js";
import {
  __decorateClass
} from "./chunk.LNH2V2XS.js";

// src/providers/hls/HlsElement.ts
import {
  isHlsjsSupported,
  isNil,
  isString as isString2,
  isUndefined as isUndefined2,
  preconnect,
  VdsEvent,
  vdsEvent
} from "@vidstack/foundation";
import { property } from "lit/decorators.js";

// src/providers/hls/utils.ts
import {
  isFunction,
  isString,
  isUndefined,
  kebabToCamelCase,
  ScriptLoader
} from "@vidstack/foundation";
var HLS_CTOR_CACHE = /* @__PURE__ */ new Map();
function isHlsConstructorCached(src) {
  return HLS_CTOR_CACHE.has(src);
}
async function importHlsConstructor(importer, callbacks = {}) {
  if (isUndefined(importer))
    return void 0;
  callbacks.onLoadStart?.();
  if (!isFunction(importer)) {
    callbacks.onLoaded?.(importer);
    return importer;
  }
  const cacheKey = String(importer);
  if (HLS_CTOR_CACHE.has(cacheKey)) {
    const hlsCtor = HLS_CTOR_CACHE.get(cacheKey);
    callbacks.onLoaded?.(hlsCtor);
    return hlsCtor;
  }
  try {
    const hlsCtor = (await importer())?.default;
    if (hlsCtor && !!hlsCtor.isSupported) {
      callbacks.onLoaded?.(hlsCtor);
      HLS_CTOR_CACHE.set(cacheKey, hlsCtor);
    } else {
      throw Error(
        true ? "[vds]: Failed importing `hls.js`. Dynamic import returned invalid constructor." : ""
      );
    }
    return hlsCtor;
  } catch (err) {
    callbacks.onLoadError?.(err);
  }
  return void 0;
}
async function loadHlsConstructorScript(src, callbacks = {}) {
  if (!isString(src))
    return void 0;
  if (HLS_CTOR_CACHE.has(src))
    return HLS_CTOR_CACHE.get(src);
  callbacks.onLoadStart?.();
  try {
    await ScriptLoader.load(src);
    if (!isFunction(window.Hls)) {
      throw Error(
        true ? "[vds]: Failed loading `hls.js`. Could not find a valid Hls constructor on window" : ""
      );
    }
    const ctor = window.Hls;
    callbacks.onLoaded?.(ctor);
    HLS_CTOR_CACHE.set(src, ctor);
    return ctor;
  } catch (err) {
    callbacks.onLoadError?.(err);
  }
  return void 0;
}
function vdsToHlsEventType(type) {
  return kebabToCamelCase(type.replace("vds-", ""));
}
var vdsHlsEventPrefix = "vds-hls-";
var vdsHlsEvents = ["lib-load", "instance", "unsupported"];
function isHlsEventType(type) {
  return type.startsWith(vdsHlsEventPrefix) && !vdsHlsEvents.some((t) => type.startsWith(`${vdsHlsEventPrefix}${t}`));
}

// src/providers/hls/HlsElement.ts
var HLS_EXTENSIONS = /\.(m3u8)($|\?)/i;
var HLS_TYPES = /* @__PURE__ */ new Set([
  "application/vnd.apple.mpegurl",
  "audio/mpegurl",
  "audio/x-mpegurl",
  "application/x-mpegurl",
  "video/x-mpegurl",
  "video/mpegurl",
  "application/mpegurl"
]);
var HLS_CDN_SRC_BASE = "https://cdn.jsdelivr.net/npm/hls.js@^1.0.0/dist/hls.light";
var HLS_CDN_SRC_DEV = `${HLS_CDN_SRC_BASE}.js`;
var HLS_CDN_SRC_PROD = `${HLS_CDN_SRC_BASE}.min.js`;
var HlsElement = class extends VideoElement {
  constructor() {
    super();
    this._isHlsEngineAttached = false;
    this.hlsConfig = {};
    this.hlsLibrary = true ? HLS_CDN_SRC_DEV : HLS_CDN_SRC_PROD;
    this._currentHlsSrc = "";
    this._hlsEventListeners = [];
    Object.defineProperty(this, "hls-config", {
      set: (config) => {
        this.hlsConfig = config;
      }
    });
    Object.defineProperty(this, "hls-library", {
      set: (lib) => {
        this.hlsLibrary = lib;
      }
    });
  }
  get Hls() {
    return this._Hls;
  }
  get hlsEngine() {
    return this._hlsEngine;
  }
  get isHlsEngineAttached() {
    return this._isHlsEngineAttached;
  }
  get currentHlsSrc() {
    return this._currentHlsSrc;
  }
  async update(changedProperties) {
    super.update(changedProperties);
    if (changedProperties.has("hlsLibrary") && isHlsjsSupported()) {
      this._preconnectToHlsLibDownload();
    }
  }
  destroy() {
    this._destroyHlsEngine();
    super.destroy();
  }
  get isHlsSupported() {
    return this.Hls?.isSupported() ?? isHlsjsSupported();
  }
  get isHlsStream() {
    return this.state.src.some((src) => HLS_EXTENSIONS.test(src));
  }
  _preconnectToHlsLibDownload() {
    if (this.canLoad || !isString2(this.hlsLibrary) || isHlsConstructorCached(this.hlsLibrary)) {
      return;
    }
    if (true) {
      this._logger?.infoGroup("Preconnect to `hls.js` download").labelledLog("URL", this.hlsLibrary).dispatch();
    }
    preconnect(this.hlsLibrary);
  }
  async _buildHlsEngine(forceRebuild = false) {
    if (isNil(this.videoElement) && !forceRebuild && !isUndefined2(this.hlsEngine)) {
      this._logger?.infoGroup("\u{1F3D7}\uFE0F Could not build HLS engine").labelledLog("Video Element", this.videoElement).labelledLog("HLS Engine", this.hlsEngine).labelledLog("Force Rebuild Flag", forceRebuild).dispatch();
      return;
    }
    if (true) {
      this._logger?.info("\u{1F3D7}\uFE0F Building HLS engine");
    }
    if (!isUndefined2(this.hlsEngine)) {
      this._destroyHlsEngine();
    }
    const callbacks = {
      onLoadStart: () => {
        if (true) {
          this._logger?.infoGroup("Starting to load `hls.js`").labelledLog("URL", this.hlsLibrary).dispatch();
        }
        this.dispatchEvent(vdsEvent("vds-hls-lib-load-start"));
      },
      onLoaded: (HlsConstructor) => {
        if (true) {
          this._logger?.infoGroup("Loaded `hls.js`").labelledLog("URL", this.hlsLibrary).labelledLog("Library", HlsConstructor).dispatch();
        }
        this.dispatchEvent(vdsEvent("vds-hls-lib-loaded", { detail: HlsConstructor }));
      },
      onLoadError: (err) => {
        if (true) {
          this._logger?.errorGroup("Failed to load `hls.js`").labelledLog("Lib Loader", this.hlsLibrary).labelledLog("Error", err).dispatch();
        }
        this.dispatchEvent(vdsEvent("vds-hls-lib-load-error", { detail: err }));
        this.dispatchEvent(
          vdsEvent("vds-error", {
            detail: {
              message: err.message,
              code: 4 /* SrcNotSupported */
            }
          })
        );
      }
    };
    this._Hls = await loadHlsConstructorScript(this.hlsLibrary, callbacks);
    if (isUndefined2(this._Hls) && !isString2(this.hlsLibrary)) {
      this._Hls = await importHlsConstructor(this.hlsLibrary, callbacks);
    }
    if (!this.Hls) {
      return;
    }
    if (!this.Hls?.isSupported?.()) {
      const message = "[vds]: `hls.js` is not supported in this environment";
      if (true) {
        this._logger?.error(message);
      }
      this.dispatchEvent(vdsEvent("vds-hls-unsupported"));
      this.dispatchEvent(
        vdsEvent("vds-error", {
          detail: {
            message,
            code: 4 /* SrcNotSupported */
          }
        })
      );
      return;
    }
    this._hlsEngine = new this.Hls(this.hlsConfig);
    if (true) {
      this._logger?.infoGroup("\u{1F3D7}\uFE0F HLS engine built").labelledLog("Video Element", this.videoElement).labelledLog("HLS Engine", this.hlsEngine).dispatch();
    }
    this.dispatchEvent(vdsEvent("vds-hls-instance", { detail: this.hlsEngine }));
    this._listenToHlsEngine();
  }
  _attachHlsEngine() {
    if (this.isHlsEngineAttached || isUndefined2(this.hlsEngine) || isNil(this.videoElement)) {
      return;
    }
    this.hlsEngine.attachMedia(this.videoElement);
    this._isHlsEngineAttached = true;
    if (true) {
      this._logger?.infoGroup("\u{1F3D7}\uFE0F Attached HLS engine").labelledLog("Video Element", this.videoElement).labelledLog("HLS Engine", this._hlsEngine).dispatch();
    }
  }
  _detachHlsEngine() {
    if (!this.isHlsEngineAttached)
      return;
    this.hlsEngine?.detachMedia();
    this._isHlsEngineAttached = false;
    this._currentHlsSrc = "";
    if (true) {
      this._logger?.infoGroup("\u{1F3D7}\uFE0F Detached HLS engine").labelledLog("Video Element", this.videoElement).dispatch();
    }
  }
  _loadSrcOnHlsEngine(src) {
    if (isNil(this.hlsEngine) || !this.isHlsStream || src === this._currentHlsSrc) {
      return;
    }
    if (true) {
      this._logger?.infoGroup(`\u{1F4FC} Loading Source`).labelledLog("Src", src).labelledLog("Video Element", this.videoElement).labelledLog("HLS Engine", this._hlsEngine).dispatch();
    }
    this.hlsEngine.loadSource(src);
    this._currentHlsSrc = src;
  }
  _getMediaType() {
    if (this.state.mediaType === "live-video" /* LiveVideo */) {
      return "live-video" /* LiveVideo */;
    }
    if (this.isHlsStream) {
      return "video" /* Video */;
    }
    return super._getMediaType();
  }
  _destroyHlsEngine() {
    this._hlsEngine?.destroy();
    this._currentHlsSrc = "";
    this._hlsEngine = void 0;
    this._isHlsEngineAttached = false;
    if (true) {
      this._logger?.info("\u{1F3D7}\uFE0F Destroyed HLS engine");
    }
  }
  _handleSrcChange(sources) {
    if (this._currentHlsSrc.length > 0 && !sources.includes(this._currentHlsSrc)) {
      sources.push(this._currentHlsSrc);
    }
    super._handleSrcChange(sources);
  }
  _handleAbort(event) {
    if (this.isHlsSupported) {
      for (const src of this.state.src) {
        if (HLS_EXTENSIONS.test(src)) {
          this._handleHlsSrcChange(src);
          return;
        }
      }
    }
    super._handleAbort(event);
  }
  async _handleHlsSrcChange(src) {
    if (this._currentHlsSrc === src)
      return;
    if (!this.hasUpdated || !this.canLoad)
      return;
    if (!this.isHlsStream) {
      this._detachHlsEngine();
      return;
    }
    if (isNil(this.hlsLibrary))
      return;
    if (isUndefined2(this.hlsEngine)) {
      await this._buildHlsEngine();
    }
    if (true) {
      this._logger?.debug(`\u{1F4FC} Detected HLS source change \`${this.state.src}\``);
    }
    this._attachHlsEngine();
    this._loadSrcOnHlsEngine(src);
  }
  _handleLoadedMetadata(event) {
    super._handleLoadedMetadata(event);
    this._handleMediaReady({
      event,
      duration: this.mediaElement.duration
    });
  }
  _listenToHlsEngine() {
    if (isUndefined2(this.hlsEngine) || isUndefined2(this.Hls))
      return;
    this.hlsEngine.on(this.Hls.Events.LEVEL_LOADED, this._handleHlsLevelLoaded.bind(this));
    this._hlsEventListeners.forEach(({ type, listener, options }) => {
      this.hlsEngine?.[options?.once ? "once" : "on"](type, listener, options?.context);
    });
    this.hlsEngine.on(this.Hls.Events.ERROR, this._handleHlsError.bind(this));
  }
  _handleHlsError(eventType, data) {
    if (isUndefined2(this.Hls))
      return;
    if (true) {
      this._logger?.errorGroup(`HLS error \`${eventType}\``).labelledLog("Video Element", this.videoElement).labelledLog("HLS Engine", this._hlsEngine).labelledLog("Event Type", eventType).labelledLog("Data", data).labelledLog("Src", this.state.src).labelledLog("State", { ...this.state }).dispatch();
    }
    if (data.fatal) {
      switch (data.type) {
        case "networkError":
          this._handleHlsNetworkError();
          break;
        case "mediaError":
          this._handleHlsMediaError();
          break;
        default:
          this._handleHlsIrrecoverableError();
          break;
      }
    }
  }
  _handleHlsNetworkError() {
    this.hlsEngine?.startLoad();
  }
  _handleHlsMediaError() {
    this.hlsEngine?.recoverMediaError();
  }
  _handleHlsIrrecoverableError() {
    this._destroyHlsEngine();
  }
  _handleHlsLevelLoaded(eventType, data) {
    if (this.state.canPlay)
      return;
    this._handleHlsMediaReady(eventType, data);
  }
  _handleHlsMediaReady(eventType, data) {
    const { live, totalduration: duration } = data.details;
    const event = new VdsEvent(eventType, { detail: data });
    const mediaType = live ? "live-video" /* LiveVideo */ : "video" /* Video */;
    if (this.state.mediaType !== mediaType) {
      this.dispatchEvent(
        vdsEvent("vds-media-type-change", {
          detail: mediaType,
          triggerEvent: event
        })
      );
    }
    if (this.state.duration !== duration) {
      this.dispatchEvent(
        vdsEvent("vds-duration-change", {
          detail: duration,
          triggerEvent: event
        })
      );
    }
  }
  addEventListener(type, listener, options) {
    if (isHlsEventType(type)) {
      const hlsEventType = vdsToHlsEventType(type);
      const hasEventListener = this._hlsEventListeners.some(
        (l) => l.type === hlsEventType && l.listener === listener
      );
      if (!hasEventListener) {
        this._hlsEventListeners.push({ type: hlsEventType, listener, options });
        this.hlsEngine?.[options?.once ? "once" : "on"](hlsEventType, listener, options?.context);
      }
      return;
    }
    return super.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    if (isHlsEventType(type)) {
      const hlsEventType = vdsToHlsEventType(type);
      this._hlsEventListeners = this._hlsEventListeners.filter(
        (l) => l.type === hlsEventType && l.listener === listener
      );
      this.hlsEngine?.off(hlsEventType, listener, options?.context, options?.once);
      return;
    }
    return super.removeEventListener(type, listener, options);
  }
};
__decorateClass([
  property({ type: Object, attribute: "hls-config" })
], HlsElement.prototype, "hlsConfig", 2);
__decorateClass([
  property({ attribute: "hls-library" })
], HlsElement.prototype, "hlsLibrary", 2);

export {
  HLS_EXTENSIONS,
  HLS_TYPES,
  HlsElement
};
