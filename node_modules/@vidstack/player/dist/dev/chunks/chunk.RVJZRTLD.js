import {
  MediaProviderElement
} from "./chunk.BJN6YOPG.js";
import {
  __decorateClass
} from "./chunk.LNH2V2XS.js";

// src/providers/html5/Html5MediaElement.ts
import {
  DisposalBin,
  getNumberOfDecimalPlaces,
  getSlottedChildren,
  isNil,
  isNumber,
  isScalarArrayEqual,
  isUndefined,
  keysOf,
  listen,
  setAttribute,
  vdsEvent
} from "@vidstack/foundation";
import { property } from "lit/decorators.js";
var AUDIO_EXTENSIONS = /\.(m4a|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i;
var VIDEO_EXTENSIONS = /\.(mp4|og[gv]|webm|mov|m4v|avi)($|\?)/i;
function getMediaTypeFromExt(src) {
  if (AUDIO_EXTENSIONS.test(src))
    return "audio" /* Audio */;
  if (VIDEO_EXTENSIONS.test(src))
    return "video" /* Video */;
  return "unknown" /* Unknown */;
}
var Html5MediaElement = class extends MediaProviderElement {
  constructor() {
    super(...arguments);
    this.preload = "metadata";
    this._timeRAF = void 0;
    this._hasMediaElementConnected = false;
    this._mediaElementDisposal = new DisposalBin();
    this._isMediaWaiting = false;
    this._ignoreNextAbortEvent = false;
    this._ignoreNextEmptiedEvent = false;
  }
  get mediaElement() {
    return this._mediaElement;
  }
  disconnectedCallback() {
    this._isMediaWaiting = false;
    super.disconnectedCallback();
    this._cancelTimeUpdates();
  }
  destroy() {
    if (this.mediaElement) {
      this.mediaElement.pause();
      this.mediaElement.src = "";
      this.mediaElement.innerHTML = "";
      this.mediaElement.load();
    }
    super.destroy();
  }
  _cancelTimeUpdates() {
    if (isNumber(this._timeRAF))
      window.cancelAnimationFrame(this._timeRAF);
    this._timeRAF = void 0;
  }
  _requestTimeUpdates() {
    if (!isUndefined(this._timeRAF))
      return;
    this._requestTimeUpdate();
  }
  _requestTimeUpdate() {
    const newTime = this.mediaElement?.currentTime ?? 0;
    if (this.state.currentTime !== newTime) {
      this._updateCurrentTime(newTime);
    }
    this._timeRAF = window.requestAnimationFrame(() => {
      if (isUndefined(this._timeRAF))
        return;
      this._requestTimeUpdate();
    });
  }
  _updateCurrentTime(newTime, triggerEvent) {
    this.dispatchEvent(
      vdsEvent("vds-time-update", {
        detail: {
          currentTime: Math.min(newTime, this.mediaElement?.duration ?? 0),
          played: this.mediaElement.played
        },
        triggerEvent
      })
    );
  }
  handleDefaultSlotChange() {
    this._handleMediaElementDisconnect();
    this._handleMediaElementConnect();
  }
  get _canMediaElementConnect() {
    return this.canLoad && !isNil(this.mediaElement) && !this._hasMediaElementConnected;
  }
  _findSlottedMediaElement() {
    const mediaElement = getSlottedChildren(this)[0];
    const tagName = mediaElement?.tagName ?? "";
    if (!/^(audio|video)$/i.test(tagName)) {
      if (true) {
        throw Error(`[vds]: expected <audio> or <video> in default slot. Received: <${tagName}>.`);
      }
    }
    this._mediaElement = mediaElement ?? void 0;
  }
  _handleMediaElementConnect() {
    window.requestAnimationFrame(() => {
      this._findSlottedMediaElement();
      if (!this._canMediaElementConnect)
        return;
      const mediaEl = this.mediaElement;
      if (mediaEl.hasAttribute("loop")) {
        this.loop = true;
      }
      mediaEl.removeAttribute("loop");
      mediaEl.removeAttribute("poster");
      setAttribute(mediaEl, "controls", this.controls);
      if (!this.state.canFullscreen && this.fullscreenController.isSupported) {
        this.dispatchEvent(
          vdsEvent("vds-fullscreen-support-change", {
            detail: this.canFullscreen
          })
        );
      }
      this._attachMediaEventListeners();
      this._observePlaysinline();
      this._observeMediaSources();
      if (this.canLoadPoster && this.poster.length > 0 && mediaEl.getAttribute("poster") !== this.poster) {
        mediaEl.setAttribute("poster", this.poster);
      }
      this._startPreloadingMedia();
      if (true) {
        this._logger?.infoGroup("Media element connected").labelledLog("Media Element", mediaEl).dispatch();
      }
      this._hasMediaElementConnected = true;
      this._disconnectDisposal.add(this._handleMediaElementDisconnect.bind(this));
    });
  }
  _handleMediaElementDisconnect() {
    this._cancelTimeUpdates();
    window.requestAnimationFrame(() => {
      this._mediaElementDisposal.empty();
      this._mediaElement = void 0;
    });
    if (this._hasMediaElementConnected && true) {
      this._logger?.infoGroup("Media element disconnected").labelledLog("Media Element", this.mediaElement).dispatch();
    }
    this._hasMediaElementConnected = false;
  }
  startLoadingMedia() {
    super.startLoadingMedia();
    this._handleMediaElementConnect();
  }
  _startPreloadingMedia() {
    if (this.state.canPlay)
      return;
    this.mediaElement.setAttribute("preload", this.preload);
    const isNetworkActive = this.mediaElement.networkState >= 1;
    this._ignoreNextAbortEvent = isNetworkActive;
    this._ignoreNextEmptiedEvent = isNetworkActive;
    this.mediaElement.load();
    setTimeout(() => {
      this._ignoreNextAbortEvent = false;
      this._ignoreNextEmptiedEvent = false;
    }, 0);
  }
  _observePlaysinline() {
    const isPlayingInline = () => this.mediaElement.hasAttribute("playsinline");
    this._handlePlaysinlineChange(isPlayingInline());
    const observer = new MutationObserver(() => this._handlePlaysinlineChange(isPlayingInline()));
    observer.observe(this.mediaElement, { attributeFilter: ["playsinline"] });
    this._mediaElementDisposal.add(() => observer.disconnect());
  }
  _handlePlaysinlineChange(playsinline) {
    this.dispatchEvent(vdsEvent("vds-playsinline-change", { detail: playsinline }));
  }
  _observeMediaSources() {
    this._handleSrcChange(this._getMediaSources());
    const observer = new MutationObserver(() => this._handleSrcChange(this._getMediaSources()));
    observer.observe(this.mediaElement, { attributeFilter: ["src"], subtree: true });
    this._mediaElementDisposal.add(() => observer.disconnect());
  }
  _handleSrcChange(sources) {
    const prevSources = this.state.src;
    if (!isScalarArrayEqual(prevSources, sources)) {
      this.dispatchEvent(vdsEvent("vds-src-change", { detail: sources }));
    }
  }
  _getMediaSources() {
    const resources = [
      this.mediaElement?.src,
      ...Array.from(this.mediaElement?.querySelectorAll("source") ?? []).map(
        (source) => source.src
      )
    ].filter(Boolean);
    return Array.from(new Set(resources));
  }
  _getMediaMetadata() {
    return {
      src: this.state.src,
      currentSrc: this.mediaElement.currentSrc,
      duration: this.mediaElement.duration || 0,
      poster: this.mediaElement.poster,
      mediaType: this._getMediaType(),
      viewType: this.state.viewType
    };
  }
  _attachMediaEventListeners() {
    if (isNil(this.mediaElement))
      return;
    const mediaEventListeners = {
      abort: this._handleAbort,
      canplay: this._handleCanPlay,
      canplaythrough: this._handleCanPlayThrough,
      durationchange: this._handleDurationChange,
      emptied: this._handleEmptied,
      ended: this._handleEnded,
      error: this._handleError,
      loadeddata: this._handleLoadedData,
      loadedmetadata: this._handleLoadedMetadata,
      loadstart: this._handleLoadStart,
      pause: this._handlePause,
      play: this._handlePlay,
      playing: this._handlePlaying,
      progress: this._handleProgress,
      ratechange: this._handleRateChange,
      seeked: this._handleSeeked,
      seeking: this._handleSeeking,
      stalled: this._handleStalled,
      suspend: this._handleSuspend,
      volumechange: this._handleVolumeChange,
      waiting: this._handleWaiting
    };
    keysOf(mediaEventListeners).forEach((type) => {
      const handler = mediaEventListeners[type].bind(this);
      const off = listen(this.mediaElement, type, async (event) => {
        if (true) {
          this._logger?.debugGroup(`\u{1F4FA} fired \`${event.type}\``).labelledLog("Event", event).labelledLog("State", { ...this.state }).dispatch();
        }
        await handler(event);
      });
      this._mediaElementDisposal.add(off);
    });
    if (true) {
      this._logger?.debug("attached event listeners");
    }
  }
  _handleAbort(event) {
    if (this._ignoreNextAbortEvent)
      return;
    this.dispatchEvent(vdsEvent("vds-abort", { triggerEvent: event }));
    this._handleCurrentSrcChange("", event);
  }
  _handleCanPlay(event) {
    this._handleMediaReady({ event, duration: this.mediaElement.duration });
  }
  _handleCanPlayThrough(event) {
    if (this.state.started)
      return;
    this.dispatchEvent(
      vdsEvent("vds-can-play-through", {
        triggerEvent: event,
        detail: { duration: this.mediaElement.duration }
      })
    );
  }
  _handleLoadStart(event) {
    this._handleCurrentSrcChange(this.mediaElement.currentSrc, event);
    if (this.mediaElement.currentSrc === "") {
      this._handleAbort();
      return;
    }
    this.dispatchEvent(
      vdsEvent("vds-load-start", {
        triggerEvent: event,
        detail: this._getMediaMetadata()
      })
    );
  }
  _handleEmptied(event) {
    if (this._ignoreNextEmptiedEvent)
      return;
    this.dispatchEvent(vdsEvent("vds-emptied", { triggerEvent: event }));
  }
  _handleLoadedData(event) {
    this.dispatchEvent(vdsEvent("vds-loaded-data", { triggerEvent: event }));
  }
  _handleLoadedMetadata(event) {
    this.dispatchEvent(
      vdsEvent("vds-volume-change", {
        detail: {
          volume: this.mediaElement.volume,
          muted: this.mediaElement.muted
        }
      })
    );
    this.dispatchEvent(
      vdsEvent("vds-loaded-metadata", {
        triggerEvent: event,
        detail: this._getMediaMetadata()
      })
    );
  }
  _determineMediaType(event) {
    this.dispatchEvent(
      vdsEvent("vds-media-type-change", {
        detail: this._getMediaType(),
        triggerEvent: event
      })
    );
  }
  _handlePlay(event) {
    const playEvent = vdsEvent("vds-play", { triggerEvent: event });
    playEvent.autoplay = this._attemptingAutoplay;
    this.dispatchEvent(playEvent);
  }
  _handlePause(event) {
    if (this.mediaElement.readyState === 1 && !this._isMediaWaiting) {
      return;
    }
    this._isMediaWaiting = false;
    this._cancelTimeUpdates();
    this.dispatchEvent(vdsEvent("vds-pause", { triggerEvent: event }));
  }
  _handlePlaying(event) {
    this._isMediaWaiting = false;
    const playingEvent = vdsEvent("vds-playing", { triggerEvent: event });
    this.dispatchEvent(playingEvent);
    this._requestTimeUpdates();
  }
  _handleDurationChange(event) {
    if (this.mediaElement.ended) {
      this._updateCurrentTime(this.mediaElement.duration, event);
    }
    this.dispatchEvent(
      vdsEvent("vds-duration-change", {
        detail: this.mediaElement.duration,
        triggerEvent: event
      })
    );
  }
  _handleProgress(event) {
    this.dispatchEvent(
      vdsEvent("vds-progress", {
        triggerEvent: event,
        detail: {
          buffered: this.mediaElement.buffered,
          seekable: this.mediaElement.seekable
        }
      })
    );
  }
  _handleRateChange(event) {
    throw Error("Not implemented");
  }
  _handleSeeking(event) {
    this.dispatchEvent(
      vdsEvent("vds-seeking", {
        detail: this.mediaElement.currentTime,
        triggerEvent: event
      })
    );
  }
  _handleSeeked(event) {
    const seekedEvent = vdsEvent("vds-seeked", {
      detail: this.mediaElement.currentTime,
      triggerEvent: event
    });
    this.dispatchEvent(seekedEvent);
    const currentTime = this.mediaElement.currentTime;
    if (Math.trunc(currentTime) === Math.trunc(this.mediaElement.duration) && getNumberOfDecimalPlaces(this.mediaElement.duration) > getNumberOfDecimalPlaces(currentTime)) {
      this._updateCurrentTime(this.mediaElement.duration, event);
      if (!this.mediaElement.ended) {
        try {
          this.play();
        } catch (e) {
        }
      }
    }
  }
  _handleStalled(event) {
    this.dispatchEvent(vdsEvent("vds-stalled", { triggerEvent: event }));
    if (this.mediaElement.readyState < 3) {
      this._isMediaWaiting = true;
      this.dispatchEvent(vdsEvent("vds-waiting", { triggerEvent: event }));
    }
  }
  _handleVolumeChange(event) {
    this.dispatchEvent(
      vdsEvent("vds-volume-change", {
        detail: {
          volume: this.mediaElement.volume,
          muted: this.mediaElement.muted
        },
        triggerEvent: event
      })
    );
  }
  _handleWaiting(event) {
    if (this.mediaElement.readyState < 3) {
      this._isMediaWaiting = true;
      this.dispatchEvent(vdsEvent("vds-waiting", { triggerEvent: event }));
    }
  }
  _handleSuspend(event) {
    const suspendEvent = vdsEvent("vds-suspend", { triggerEvent: event });
    this.dispatchEvent(suspendEvent);
  }
  _handleEnded(event) {
    this._cancelTimeUpdates();
    this._updateCurrentTime(this.mediaElement.duration, event);
    const endEvent = vdsEvent("vds-end", { triggerEvent: event });
    this.dispatchEvent(endEvent);
    if (this.state.loop) {
      this._handleLoop();
    } else {
      this.dispatchEvent(vdsEvent("vds-ended", { triggerEvent: event }));
    }
  }
  _handleLoop() {
    const hasCustomControls = isNil(this.controls);
    if (hasCustomControls) {
      this.mediaElement.controls = false;
    }
    this.dispatchEvent(vdsEvent("vds-loop-request"));
  }
  _handleError(event) {
    const mediaError = this.mediaElement.error;
    if (!mediaError)
      return;
    this.dispatchEvent(
      vdsEvent("vds-error", {
        detail: {
          message: mediaError.message,
          code: mediaError.code,
          mediaError
        },
        triggerEvent: event
      })
    );
  }
  _getPaused() {
    return this.mediaElement?.paused ?? true;
  }
  _getVolume() {
    return this.mediaElement?.volume ?? 1;
  }
  _setVolume(newVolume) {
    this.mediaElement.volume = newVolume;
  }
  _getCurrentTime() {
    return this.mediaElement?.currentTime ?? 0;
  }
  _setCurrentTime(newTime) {
    if (this.mediaElement.currentTime !== newTime) {
      this.mediaElement.currentTime = newTime;
    }
  }
  _getMuted() {
    return this.mediaElement?.muted ?? false;
  }
  _setMuted(isMuted) {
    this.mediaElement.muted = isMuted;
  }
  async play() {
    if (true) {
      this._logger?.info("attempting to play...");
    }
    try {
      this._throwIfNotReadyForPlayback();
      await this._resetPlaybackIfEnded();
      return this.mediaElement?.play();
    } catch (error) {
      const playErrorEvent = vdsEvent("vds-play-fail");
      playErrorEvent.autoplay = this._attemptingAutoplay;
      playErrorEvent.error = error;
      throw error;
    }
  }
  async pause() {
    if (true) {
      this._logger?.info("attempting to pause...");
    }
    return this.mediaElement?.pause();
  }
  _getMediaType() {
    return getMediaTypeFromExt(this.state.currentSrc);
  }
};
__decorateClass([
  property()
], Html5MediaElement.prototype, "preload", 2);

export {
  AUDIO_EXTENSIONS,
  VIDEO_EXTENSIONS,
  Html5MediaElement
};
