// src/media/MediaType.ts
var MediaType = /* @__PURE__ */ ((MediaType2) => {
  MediaType2["Unknown"] = "unknown";
  MediaType2["Audio"] = "audio";
  MediaType2["Video"] = "video";
  MediaType2["LiveVideo"] = "live-video";
  return MediaType2;
})(MediaType || {});

// src/media/ViewType.ts
var ViewType = /* @__PURE__ */ ((ViewType2) => {
  ViewType2["Unknown"] = "unknown";
  ViewType2["Audio"] = "audio";
  ViewType2["Video"] = "video";
  return ViewType2;
})(ViewType || {});

// src/media/store.ts
import {
  createContext,
  keysOf,
  storeRecordSubscription,
  writable
} from "@vidstack/foundation";

// src/media/time-ranges.ts
import { isArray, isNumber, isUndefined } from "@vidstack/foundation";
function rangeCheck(fnName, index, maxIndex) {
  if (!isNumber(index) || index < 0 || index > maxIndex) {
    throw new Error(
      `Failed to execute '${fnName}' on 'TimeRanges': The index provided (${index}) is non-numeric or out of bounds (0-${maxIndex}).`
    );
  }
}
function getRange(fnName, valueIndex, ranges, rangeIndex) {
  rangeCheck(fnName, rangeIndex, ranges.length - 1);
  return ranges[rangeIndex][valueIndex];
}
function createTimeRangesObj(ranges) {
  if (isUndefined(ranges) || ranges.length === 0) {
    const throwEmptyError = () => {
      throw new Error("This TimeRanges object is empty");
    };
    return {
      length: 0,
      start: throwEmptyError,
      end: throwEmptyError
    };
  }
  return {
    length: ranges.length,
    start: getRange.bind(null, "start", 0, ranges),
    end: getRange.bind(null, "end", 1, ranges)
  };
}
function createTimeRanges(start, end) {
  if (isArray(start)) {
    return createTimeRangesObj(start);
  } else if (isUndefined(start) || isUndefined(end)) {
    return createTimeRangesObj();
  }
  return createTimeRangesObj([[start, end]]);
}

// src/media/store.ts
var MEDIA_STORE_DEFAULTS = {
  autoplay: false,
  autoplayError: void 0,
  buffered: createTimeRanges(),
  duration: 0,
  bufferedAmount: 0,
  canLoad: false,
  canPlay: false,
  canFullscreen: false,
  controls: false,
  poster: "",
  currentSrc: "",
  currentTime: 0,
  ended: false,
  error: void 0,
  fullscreen: false,
  userIdle: false,
  loop: false,
  mediaType: "unknown" /* Unknown */,
  muted: false,
  paused: true,
  played: createTimeRanges(),
  playing: false,
  playsinline: false,
  seekable: createTimeRanges(),
  seekableAmount: 0,
  seeking: false,
  src: [],
  started: false,
  viewType: "unknown" /* Unknown */,
  volume: 1,
  waiting: false
};
function createMediaStore() {
  const store = {};
  for (const prop of keysOf(MEDIA_STORE_DEFAULTS)) {
    store[prop] = writable(MEDIA_STORE_DEFAULTS[prop]);
  }
  return store;
}
var DO_NOT_RESET_ON_SRC_CHANGE = /* @__PURE__ */ new Set([
  "autoplay",
  "canFullscreen",
  "canLoad",
  "controls",
  "currentSrc",
  "loop",
  "muted",
  "playsinline",
  "poster",
  "src",
  "viewType",
  "volume"
]);
function softResetMediaStore(store) {
  keysOf(store).forEach((prop) => {
    if (!DO_NOT_RESET_ON_SRC_CHANGE.has(prop)) {
      store[prop].set(store[prop].initialValue);
    }
  });
}
function resetMediaStore(store) {
  for (const prop of keysOf(MEDIA_STORE_DEFAULTS)) {
    store[prop].set(MEDIA_STORE_DEFAULTS[prop]);
  }
}
var mediaStoreContext = createContext(createMediaStore);
function mediaStoreSubscription(host, property, onChange) {
  return storeRecordSubscription(host, mediaStoreContext, property, onChange);
}

export {
  MediaType,
  ViewType,
  MEDIA_STORE_DEFAULTS,
  createMediaStore,
  softResetMediaStore,
  resetMediaStore,
  mediaStoreContext,
  mediaStoreSubscription
};
