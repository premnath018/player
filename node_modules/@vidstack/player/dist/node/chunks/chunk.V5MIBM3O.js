import "@vidstack/foundation/shims/install-safe.js";

import {
  createMediaStore
} from "./chunk.O2H47C42.js";
import {
  __decorateClass,
  e,
  s,
  t,
  y
} from "./chunk.NUDNXB7T.js";

// src/media/provider/MediaProviderElement.ts
import {
  clampNumber,
  copyStoreRecords,
  createIntersectionController,
  discoverable,
  DisposalBin,
  FullscreenController,
  hostRequestQueue,
  isUndefined,
  raf,
  requestIdleCallback,
  RequestQueue,
  ScreenOrientationController,
  unwrapStoreRecord,
  vdsEvent
} from "@vidstack/foundation";
var mediaProviderDiscoveryId = Symbol("@vidstack/media-provider-discovery");
var MediaProviderElement = class extends s {
  constructor() {
    super();
    this._disconnectDisposal = new DisposalBin();
    this._logger = false ? new LogDispatcher(this) : void 0;
    this.loading = "visible";
    this._attemptingAutoplay = false;
    this.controllerQueue = new RequestQueue();
    this._store = createMediaStore();
    this._state = unwrapStoreRecord(this._store);
    this.connectedQueue = hostRequestQueue(this);
    this.mediaQueue = new RequestQueue();
    this.screenOrientationController = new ScreenOrientationController(this);
    this.fullscreenController = new FullscreenController(this, this.screenOrientationController);
    discoverable(this, "vds-media-provider-connect", { register: mediaProviderDiscoveryId });
    const intersectionController = createIntersectionController(
      this,
      { target: this, threshold: 0 },
      (entries) => {
        var _a;
        if (!/(visible|lazy)/.test(this.loading)) {
          intersectionController.hostDisconnected();
          return;
        }
        if ((_a = entries[0]) == null ? void 0 : _a.isIntersecting) {
          this.startLoadingMedia();
          intersectionController.hostDisconnected();
        }
      }
    );
  }
  connectedCallback() {
    super.connectedCallback();
    this._logMediaEvents();
    (typeof window !== "undefined" ? window : null)?.requestAnimationFrame(() => {
      if (isUndefined(this.canLoadPoster)) {
        this.canLoadPoster = true;
      }
    });
  }
  firstUpdated(changedProperties) {
    super.firstUpdated(changedProperties);
    this.dispatchEvent(
      vdsEvent("vds-fullscreen-support-change", {
        detail: this.canFullscreen
      })
    );
    if (this.canLoad || this.loading === "eager") {
      window == null ? void 0 : (typeof window !== "undefined" ? window : null)?.requestAnimationFrame(() => {
        this.startLoadingMedia();
      });
    } else if (this.loading === "idle") {
      requestIdleCallback(() => {
        this.startLoadingMedia();
      });
    }
  }
  render() {
    return y`<slot @slotchange="${this.handleDefaultSlotChange}"></slot>`;
  }
  disconnectedCallback() {
    this._updateMediaStoreOnDisconnect(this._store);
    this.mediaQueue.destroy();
    this._disconnectDisposal.empty();
    super.disconnectedCallback();
    raf(() => {
      raf(() => {
        if (!this.isConnected)
          this.destroy();
      });
    });
  }
  _updateMediaStoreOnDisconnect(store) {
    store.paused.set(true);
    store.playing.set(false);
    store.seeking.set(false);
    store.waiting.set(false);
    store.fullscreen.set(false);
  }
  destroy() {
    if (this.isConnected)
      this.disconnectedCallback();
    this.dispatchEvent(vdsEvent("vds-destroy"));
  }
  _logMediaEvents() {
    if (false) {
      const mediaEvents = [
        "vds-abort",
        "vds-can-play",
        "vds-can-play-through",
        "vds-current-src-change",
        "vds-duration-change",
        "vds-emptied",
        "vds-ended",
        "vds-error",
        "vds-fullscreen-change",
        "vds-loaded-data",
        "vds-loaded-metadata",
        "vds-load-start",
        "vds-media-type-change",
        "vds-pause",
        "vds-play",
        "vds-playing",
        "vds-progress",
        "vds-seeked",
        "vds-seeking",
        "vds-stalled",
        "vds-started",
        "vds-suspend",
        "vds-replay",
        "vds-view-type-change",
        "vds-volume-change",
        "vds-waiting"
      ];
      mediaEvents.forEach((eventType) => {
        const dispose = listen(this, eventType, (event) => {
          (_a = this._logger) == null ? void 0 : _a.infoGroup(`\u{1F4E1} dispatching \`${eventType}\``).labelledLog("State", { ...this.state }).labelledLog("Event", event).dispatch();
        });
        this._disconnectDisposal.add(dispose);
      });
    }
  }
  get volume() {
    return this._getVolume();
  }
  set volume(newVolume) {
    this.mediaQueue.queue("volume", () => {
      const oldVol = this.volume;
      const newVol = clampNumber(0, newVolume, 1);
      if (oldVol !== newVol) {
        this._setVolume(newVol);
        this.requestUpdate("volume", oldVol);
      }
    });
  }
  get paused() {
    return this._getPaused();
  }
  set paused(newPaused) {
    this.mediaQueue.queue("paused", () => {
      var _a;
      if (this.paused === newPaused)
        return;
      try {
        if (!newPaused) {
          this.play();
        } else {
          this.pause();
        }
        this.requestUpdate("paused", !newPaused);
      } catch (e2) {
        (_a = this._logger) == null ? void 0 : _a.error("paused-change-fail", e2);
      }
    });
  }
  get currentTime() {
    return this._getCurrentTime();
  }
  set currentTime(newTime) {
    this.mediaQueue.queue("current-time", () => {
      const oldTime = this.currentTime;
      if (oldTime !== newTime) {
        this._setCurrentTime(newTime);
        this.requestUpdate("currentTime", oldTime);
      }
    });
  }
  get muted() {
    return this._getMuted();
  }
  set muted(newMuted) {
    this.mediaQueue.queue("muted", () => {
      const oldMuted = this.muted;
      if (oldMuted !== newMuted) {
        this._setMuted(newMuted);
        this.requestUpdate("muted", oldMuted);
      }
    });
  }
  get poster() {
    return this.state.poster;
  }
  set poster(newPoster) {
    const oldPoster = this.poster;
    if (oldPoster !== newPoster) {
      this.dispatchEvent(vdsEvent("vds-poster-change", { detail: newPoster }));
      this.requestUpdate("poster", oldPoster);
    }
  }
  get loop() {
    return this.state.loop;
  }
  set loop(newLoop) {
    const oldLoop = this.loop;
    if (oldLoop !== newLoop) {
      this.dispatchEvent(vdsEvent("vds-loop-change", { detail: newLoop }));
      this.requestUpdate("loop", oldLoop);
    }
  }
  get controls() {
    return this.state.controls;
  }
  set controls(newControls) {
    const oldControls = this.controls;
    if (oldControls !== newControls) {
      this.dispatchEvent(vdsEvent("vds-controls-change", { detail: newControls }));
      this.requestUpdate("controls", oldControls);
    }
  }
  get canLoad() {
    return this.state.canLoad;
  }
  startLoadingMedia() {
    if (this.state.canPlay)
      return;
    this.dispatchEvent(vdsEvent("vds-can-load"));
  }
  _throwIfNotReadyForPlayback() {
    if (!this.state.canPlay) {
      throw Error(`Media is not ready - wait for \`vds-can-play\` event.`);
    }
  }
  async _resetPlaybackIfEnded() {
    if (!this.state.ended || this.state.currentTime === 0)
      return;
    return this._setCurrentTime(0);
  }
  _throwIfNotVideoView() {
    if (this.state.viewType !== "video" /* Video */) {
      throw Error("Player is currently not in a video view.");
    }
  }
  async _handleMediaReady({ event, duration }) {
    if (this.state.canPlay)
      return;
    this.dispatchEvent(
      vdsEvent("vds-can-play", {
        triggerEvent: event,
        detail: { duration }
      })
    );
    this.mediaQueue.start();
    if (false) {
      (_a = this._logger) == null ? void 0 : _a.infoGroup("-~-~-~-~-~-~-~-~- \u2705 MEDIA READY -~-~-~-~-~-~-~-~-").labelledLog("State", { ...this.state }).labelledLog("Event", event).dispatch();
    }
    await this._attemptAutoplay();
  }
  _handleCurrentSrcChange(currentSrc, triggerEvent) {
    if (this.state.currentSrc === currentSrc)
      return;
    if (false) {
      (_a = this._logger) == null ? void 0 : _a.infoGroup("\u{1F4FC} Media source change").labelledLog("Src", this.state.src).labelledLog("Current Src", currentSrc).dispatch();
    }
    this.mediaQueue.stop();
    this.dispatchEvent(
      vdsEvent("vds-current-src-change", {
        detail: currentSrc,
        triggerEvent
      })
    );
  }
  get autoplay() {
    return this.state.autoplay;
  }
  set autoplay(newAutoplay) {
    if (this.autoplay !== newAutoplay) {
      this.dispatchEvent(vdsEvent("vds-autoplay-change", { detail: newAutoplay }));
      this.requestUpdate("autoplay", !newAutoplay);
    }
    this._attemptAutoplay();
  }
  get _canAttemptAutoplay() {
    return this.state.canPlay && this.state.autoplay && !this.state.started;
  }
  async _attemptAutoplay() {
    if (!this._canAttemptAutoplay)
      return;
    this._attemptingAutoplay = true;
    try {
      await this.play();
      this.dispatchEvent(vdsEvent("vds-autoplay", { detail: { muted: this.muted } }));
    } catch (error) {
      this.dispatchEvent(
        vdsEvent("vds-autoplay-fail", {
          detail: {
            muted: this.muted,
            error
          }
        })
      );
      this.requestUpdate();
    }
    this._attemptingAutoplay = false;
  }
  get controller() {
    return this._controller;
  }
  get logLevel() {
    var _a;
    return ((_a = this._controller) == null ? void 0 : _a.logLevel) ?? "silent";
  }
  set logLevel(level) {
    if (false) {
      this.controllerQueue.queue("log-level", () => {
        this._controller.logLevel = level;
      });
    }
  }
  get idleDelay() {
    var _a;
    return ((_a = this._controller) == null ? void 0 : _a.idleDelay) ?? 0;
  }
  set idleDelay(delay) {
    this.controllerQueue.queue("idle-delay", () => {
      this._controller.idleDelay = delay;
    });
  }
  attachMediaController(controller, onDisconnect) {
    this._controller = controller;
    this._store = controller._store;
    this._state = controller.state;
    this.controllerQueue.start();
    onDisconnect(() => {
      this.controllerQueue.destroy();
      this._store = createMediaStore();
      this._state = unwrapStoreRecord(this._store);
      if (this._controller) {
        copyStoreRecords(this._controller._store, this._store);
        this._updateMediaStoreOnDisconnect(this._controller._store);
      }
      this._controller = void 0;
    });
  }
  dispatchEvent(event) {
    if (!this._controller && event.type.startsWith("vds-") && event.type !== "vds-destroy") {
      this.controllerQueue.queue(event.type, () => {
        super.dispatchEvent(event);
      });
      return false;
    }
    return super.dispatchEvent(event);
  }
  store() {
    return this._store;
  }
  get state() {
    return this._state;
  }
  get canFullscreen() {
    return this.fullscreenController.isSupported;
  }
  get fullscreen() {
    return this.fullscreenController.isFullscreen;
  }
  get fullscreenOrientation() {
    return this.fullscreenController.screenOrientationLock;
  }
  set fullscreenOrientation(lockType) {
    const prevLockType = this.fullscreenController.screenOrientationLock;
    if (prevLockType !== lockType) {
      this.fullscreenController.screenOrientationLock = lockType;
      this.requestUpdate("fullscreen-orientation", prevLockType);
    }
  }
  enterFullscreen() {
    return this.fullscreenController.enterFullscreen();
  }
  exitFullscreen() {
    return this.fullscreenController.exitFullscreen();
  }
};
__decorateClass([
  e({ type: Number })
], MediaProviderElement.prototype, "volume", 1);
__decorateClass([
  e({ type: Boolean })
], MediaProviderElement.prototype, "paused", 1);
__decorateClass([
  e({ type: Number })
], MediaProviderElement.prototype, "currentTime", 1);
__decorateClass([
  e({ type: Boolean })
], MediaProviderElement.prototype, "muted", 1);
__decorateClass([
  e()
], MediaProviderElement.prototype, "poster", 1);
__decorateClass([
  e({ type: Boolean })
], MediaProviderElement.prototype, "loop", 1);
__decorateClass([
  e({ type: Boolean })
], MediaProviderElement.prototype, "controls", 1);
__decorateClass([
  t()
], MediaProviderElement.prototype, "canLoadPoster", 2);
__decorateClass([
  e({ attribute: "loading" })
], MediaProviderElement.prototype, "loading", 2);
__decorateClass([
  e({ type: Boolean })
], MediaProviderElement.prototype, "autoplay", 1);
__decorateClass([
  e({ attribute: "log-level" })
], MediaProviderElement.prototype, "logLevel", 1);
__decorateClass([
  e({ attribute: "idle-delay", type: Number })
], MediaProviderElement.prototype, "idleDelay", 1);
__decorateClass([
  e({ attribute: "fullscreen-orientation" })
], MediaProviderElement.prototype, "fullscreenOrientation", 1);

export {
  mediaProviderDiscoveryId,
  MediaProviderElement
};
