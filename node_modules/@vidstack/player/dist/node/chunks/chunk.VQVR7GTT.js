import "@vidstack/foundation/shims/install-safe.js";

import {
  mediaProviderElementContext
} from "./chunk.APMKZUJJ.js";
import {
  mediaProviderDiscoveryId
} from "./chunk.V5MIBM3O.js";
import {
  mediaStoreContext,
  mediaStoreSubscription,
  resetMediaStore,
  softResetMediaStore
} from "./chunk.O2H47C42.js";
import {
  __decorateClass,
  e,
  i,
  s,
  t,
  y
} from "./chunk.NUDNXB7T.js";

// src/media/controller/UserIdleController.ts
import { DisposalBin, listen, vdsEvent } from "@vidstack/foundation";
var UserIdleController = class {
  constructor(_host, _mediaStore) {
    this._host = _host;
    this._mediaStore = _mediaStore;
    this._idle = false;
    this._mediaPaused = false;
    this._idlingPaused = false;
    this._disposal = new DisposalBin();
    this.delay = 2e3;
    _host.addController(this);
  }
  get paused() {
    return this._idlingPaused || this._mediaPaused;
  }
  set paused(paused) {
    this._idlingPaused = paused;
    this._handleIdleChange();
  }
  hostConnected() {
    this._disposal.add(
      this._mediaStore.paused.subscribe(($paused) => {
        this._mediaPaused = $paused;
        this._handleIdleChange();
      })
    );
    const startIdleTimerEvents = ["pointerdown", "pointermove", "focus", "keydown"];
    startIdleTimerEvents.forEach((eventType) => {
      const off = listen(this._host, eventType, this._handleIdleChange.bind(this));
      this._disposal.add(off);
    });
  }
  hostDisconnected() {
    this._disposal.empty();
    this._stopIdleTimer();
  }
  _handleIdleChange() {
    if (this.paused) {
      this._stopIdleTimer();
    } else {
      this._startIdleTimer();
    }
  }
  _startIdleTimer() {
    this._stopIdleTimer();
    this._idleTimeout = (typeof window !== "undefined" ? window : null)?.setTimeout(() => {
      this._dispatchIdleChange(!this.paused);
    }, this.delay);
  }
  _stopIdleTimer() {
    (typeof window !== "undefined" ? window : null)?.clearTimeout(this._idleTimeout);
    this._dispatchIdleChange(false);
  }
  _dispatchIdleChange(isIdle) {
    if (this._idle !== isIdle) {
      this._host.dispatchEvent(vdsEvent("vds-user-idle-change", { detail: isIdle }));
      this._idle = isIdle;
    }
  }
};

// src/media/controller/MediaController.ts
import {
  appendTriggerEvent,
  copyStoreRecords,
  debounce,
  discover,
  DisposalBin as DisposalBin2,
  eventListener,
  isNil,
  keysOf,
  listen as listen2,
  RequestQueue,
  throttle,
  unwrapStoreRecord,
  vdsEvent as vdsEvent2
} from "@vidstack/foundation";
var MediaController = class {
  constructor(_host) {
    this._host = _host;
    this._disconnectDisposal = new DisposalBin2();
    this.providerQueue = new RequestQueue();
    this.providerDisposal = new DisposalBin2();
    this._logController = false ? new LogController(this._host) : void 0;
    this._logger = false ? new LogDispatcher(this._host) : void 0;
    this._providerContext = mediaProviderElementContext.provide(this._host);
    this._mediaStoreProvider = mediaStoreContext.provide(this._host);
    this.state = unwrapStoreRecord(this._store);
    this._userIdleController = new UserIdleController(this._host, this._store);
    this._handleIdleChange = eventListener(this._host, "vds-user-idle-change", (event) => {
      this._store.userIdle.set(event.detail);
      this._satisfyMediaRequest("userIdle", event);
    });
    this._pendingMediaRequests = {
      loading: [],
      play: [],
      pause: [],
      volume: [],
      fullscreen: [],
      seeked: [],
      seeking: [],
      userIdle: []
    };
    this._handleStartLoadingRequest = eventListener(
      this._host,
      "vds-start-loading",
      this._createMediaRequestHandler("loading", (event) => {
        if (this.state.canLoad)
          return;
        this._pendingMediaRequests.loading.push(event);
        this._provider.startLoadingMedia();
      })
    );
    this._handleMuteRequest = eventListener(
      this._host,
      "vds-mute-request",
      this._createMediaRequestHandler("muted", (event) => {
        if (this.state.muted)
          return;
        this._pendingMediaRequests.volume.push(event);
        this.provider.muted = true;
      })
    );
    this._handleUnmuteRequest = eventListener(
      this._host,
      "vds-unmute-request",
      this._createMediaRequestHandler("muted", (event) => {
        if (!this.state.muted)
          return;
        this._pendingMediaRequests.volume.push(event);
        this.provider.muted = false;
        if (this.state.volume === 0) {
          this._pendingMediaRequests.volume.push(event);
          this.provider.volume = 0.25;
        }
      })
    );
    this._handlePlayRequest = eventListener(
      this._host,
      "vds-play-request",
      this._createMediaRequestHandler("paused", (event) => {
        if (!this.state.paused)
          return;
        this._pendingMediaRequests.play.push(event);
        this.provider.paused = false;
      })
    );
    this._handlePauseRequest = eventListener(
      this._host,
      "vds-pause-request",
      this._createMediaRequestHandler("paused", (event) => {
        if (this.state.paused)
          return;
        this._pendingMediaRequests.pause.push(event);
        this.provider.paused = true;
      })
    );
    this._isSeekingRequestPending = false;
    this._handleSeekingRequest = eventListener(
      this._host,
      "vds-seeking-request",
      this._createMediaRequestHandler("seeking", (event) => {
        this._stopWaiting();
        this._pendingMediaRequests.seeking.push(event);
        this._isSeekingRequestPending = true;
        this._store.seeking.set(true);
      })
    );
    this._handleSeekRequest = eventListener(
      this._host,
      "vds-seek-request",
      this._createMediaRequestHandler("seeking", (event) => {
        if (this.store.ended) {
          this._isReplay = true;
        }
        this._pendingMediaRequests.seeked.push(event);
        this._isSeekingRequestPending = false;
        let time = event.detail;
        if (this.state.duration - event.detail < 0.25) {
          time = this.state.duration;
        }
        this.provider.currentTime = time;
      })
    );
    this._handleVolumeChangeRequest = eventListener(
      this._host,
      "vds-volume-change-request",
      this._createMediaRequestHandler("volume", (event) => {
        const volume = event.detail;
        if (this.state.volume === volume)
          return;
        this._pendingMediaRequests.volume.push(event);
        this.provider.volume = volume;
        if (volume > 0 && this.state.muted) {
          this._pendingMediaRequests.volume.push(event);
          this.provider.muted = false;
        }
      })
    );
    this._handleEnterFullscreenRequest = eventListener(
      this._host,
      "vds-enter-fullscreen-request",
      this._createMediaRequestHandler("fullscreen", async (event) => {
        var _a, _b;
        if (this.state.fullscreen)
          return;
        const target = event.detail ?? "media";
        if (target === "media" && this._host.canFullscreen) {
          this._pendingMediaRequests.fullscreen.push(event);
          await ((_b = (_a = this._host).enterFullscreen) == null ? void 0 : _b.call(_a));
        } else if (this.provider) {
          this._pendingMediaRequests.fullscreen.push(event);
          await this.provider.enterFullscreen();
        }
      })
    );
    this._handleExitFullscreenRequest = eventListener(
      this._host,
      "vds-exit-fullscreen-request",
      this._createMediaRequestHandler("fullscreen", async (event) => {
        var _a, _b;
        if (!this.state.fullscreen)
          return;
        const target = event.detail ?? "media";
        if (target === "media" && this._host.canFullscreen) {
          this._pendingMediaRequests.fullscreen.push(event);
          await ((_b = (_a = this._host).exitFullscreen) == null ? void 0 : _b.call(_a));
        } else if (this.provider) {
          this._pendingMediaRequests.fullscreen.push(event);
          await this.provider.exitFullscreen();
        }
      })
    );
    this._handleResumeIdlingRequest = eventListener(
      this._host,
      "vds-resume-user-idle-request",
      (event) => {
        if (!this._mediaRequestEventGateway(event))
          return;
        this._pendingMediaRequests.userIdle.push(event);
        this._userIdleController.paused = false;
      }
    );
    this._handlePauseIdlingRequest = eventListener(
      this._host,
      "vds-pause-user-idle-request",
      (event) => {
        if (!this._mediaRequestEventGateway(event))
          return;
        this._pendingMediaRequests.userIdle.push(event);
        this._userIdleController.paused = true;
      }
    );
    this._handleShowPosterRequest = eventListener(
      this._host,
      "vds-show-poster-request",
      this._createMediaRequestHandler("poster", () => {
        this._provider.canLoadPoster = true;
      })
    );
    this._handleHidePosterRequest = eventListener(
      this._host,
      "vds-hide-poster-request",
      this._createMediaRequestHandler("poster", () => {
        this._provider.canLoadPoster = false;
      })
    );
    this._handleLoopRequest = this._createMediaRequestHandler("loop", () => {
      (typeof window !== "undefined" ? window : null)?.requestAnimationFrame(async () => {
        try {
          this._isLooping = true;
          this._isReplay = true;
          await this._provider.play();
        } catch (e2) {
          this._isReplay = false;
          this._isLooping = false;
        }
      });
    });
    this._handleFullscreenChange = eventListener(
      this._host,
      "vds-fullscreen-change",
      (event) => {
        var _a;
        this._store.fullscreen.set(event.detail);
        if (event.target !== this._host)
          return;
        this._satisfyMediaRequest("fullscreen", event);
        (_a = this._provider) == null ? void 0 : _a.dispatchEvent(
          vdsEvent2("vds-fullscreen-change", {
            detail: event.detail,
            triggerEvent: event
          })
        );
      }
    );
    this._handleFullscreenError = eventListener(
      this._host,
      "vds-fullscreen-error",
      (event) => {
        var _a;
        if (event.target !== this._host)
          return;
        this._satisfyMediaRequest("fullscreen", event);
        (_a = this._provider) == null ? void 0 : _a.dispatchEvent(
          vdsEvent2("vds-fullscreen-error", {
            detail: event.detail,
            triggerEvent: event
          })
        );
      }
    );
    this._isReplay = false;
    this._isLooping = false;
    this._firingWaiting = false;
    this._mediaEvents = [];
    this._handleSeeking = throttle(
      (event) => {
        this._mediaEvents.push(event);
        this._store.seeking.set(true);
        this._store.currentTime.set(event.detail);
        this._satisfyMediaRequest("seeking", event);
      },
      150,
      { leading: true }
    );
    this._fireWaiting = debounce(() => {
      var _a;
      if (!this._originalWaitingEvent)
        return;
      this._firingWaiting = true;
      const event = vdsEvent2("vds-waiting", this._originalWaitingEvent);
      this._mediaEvents.push(event);
      this._store.waiting.set(true);
      this._store.playing.set(false);
      (_a = this._provider) == null ? void 0 : _a.dispatchEvent(event);
      this._originalWaitingEvent = void 0;
      this._firingWaiting = false;
    }, 300);
    this._skipInitialSrcChange = true;
    discover(_host, mediaProviderDiscoveryId, (provider, onDisconnect) => {
      this.attachMediaProvider(provider, onDisconnect);
    });
    _host.addController({
      hostConnected: () => {
        if (!this.state.canPlay) {
          this._host.setAttribute("aria-busy", "true");
        }
      },
      hostDisconnected: () => {
        this._clearMediaStateTracking();
        this._clearPendingMediaRequests();
        this.providerQueue.destroy();
        this.providerDisposal.empty();
        this._skipInitialSrcChange = true;
        this._disconnectDisposal.empty();
      }
    });
  }
  get logLevel() {
    var _a;
    return ((_a = this._logController) == null ? void 0 : _a.logLevel) ?? "silent";
  }
  set logLevel(level) {
    if (false) {
      this._logController.logLevel = level;
    }
  }
  get provider() {
    return this._provider;
  }
  attachMediaProvider(provider, onDisconnect) {
    if (!isNil(this.provider) || this.provider === provider)
      return;
    this._handleMediaProviderDisconnect();
    this._provider = provider;
    this._providerContext.value.set(provider);
    copyStoreRecords(this._provider._store, this._store);
    this._attachMediaEventListeners();
    provider.attachMediaController(this, (cb) => this._disconnectDisposal.add(cb));
    this._flushMediaProviderConnectedQueue();
    onDisconnect(this._handleMediaProviderDisconnect.bind(this));
  }
  _handleMediaProviderDisconnect() {
    if (isNil(this.provider))
      return;
    this._stopWaiting();
    this.providerQueue.destroy();
    this.providerDisposal.empty();
    this._provider = void 0;
    this._providerContext.value.set(void 0);
    resetMediaStore(this._store);
    this._store.viewType.set("unknown" /* Unknown */);
  }
  _flushMediaProviderConnectedQueue() {
    this.providerQueue.start();
    this.providerDisposal.add(() => {
      this.providerQueue.stop();
    });
  }
  get store() {
    return this._mediaStoreProvider.value;
  }
  get _store() {
    return this._mediaStoreProvider.value;
  }
  get idleDelay() {
    return this._userIdleController.delay;
  }
  set idleDelay(delay) {
    this._userIdleController.delay = delay;
  }
  _clearPendingMediaRequests() {
    keysOf(this._pendingMediaRequests).forEach((key) => {
      this._pendingMediaRequests[key] = [];
    });
  }
  _satisfyMediaRequest(type, event) {
    const requestEvent = this._pendingMediaRequests[type].shift();
    if (requestEvent) {
      event.requestEvent = requestEvent;
      appendTriggerEvent(event, requestEvent);
    }
  }
  _mediaRequestEventGateway(event) {
    event.stopPropagation();
    if (false) {
      (_a = this._logger) == null ? void 0 : _a.infoGroup(`\u{1F4EC} received \`${event.type}\``).labelledLog("Request", event).dispatch();
    }
    return true;
  }
  _createMediaRequestHandler(queueKey, callback) {
    return (event) => {
      if (!this._mediaRequestEventGateway(event))
        return;
      if (this._provider) {
        callback(event);
        return;
      }
      this.providerQueue.queue(queueKey, () => {
        callback(event);
      });
    };
  }
  _attachMediaEventListeners() {
    if (!this._provider)
      return;
    const mediaEventListeners = {
      "vds-can-load": this._handleCanLoad,
      "vds-load-start": this._handleLoadStart,
      "vds-loaded-data": this._handleLoadedData,
      "vds-loaded-metadata": this._handleLoadedMetadata,
      "vds-can-play": this._handleCanPlay,
      "vds-can-play-through": this._handleCanPlayThrough,
      "vds-current-src-change": this._handleCurrentSrcChange,
      "vds-autoplay": this._handleAutoplay,
      "vds-autoplay-fail": this._handleAutoplayFail,
      "vds-loop-request": this._handleLoopRequest,
      "vds-play": this._handlePlay,
      "vds-play-fail": this._handlePlayFail,
      "vds-playing": this._handlePlaying,
      "vds-pause": this._handlePause,
      "vds-time-update": this._handleTimeUpdate,
      "vds-volume-change": this._handleVolumeChange,
      "vds-seeking": this._handleSeeking,
      "vds-seeked": this._handleSeeked,
      "vds-waiting": this._handleWaiting,
      "vds-ended": this._handleEnded,
      "vds-autoplay-change": this._handleAutoplayChange,
      "vds-error": this._handleError,
      "vds-fullscreen-support-change": this._handleFullscreenSupportChange,
      "vds-poster-change": this._handlePosterChange,
      "vds-loop-change": this._handleLoopChange,
      "vds-playsinline-change": this._handlePlaysinlineChange,
      "vds-controls-change": this._handleControlsChange,
      "vds-media-type-change": this._handleMediaTypeChange,
      "vds-view-type-change": this._handleViewTypeChange,
      "vds-duration-change": this._handleDurationChange,
      "vds-progress": this._handleProgress,
      "vds-src-change": this._handleSrcChange
    };
    for (const eventType of keysOf(mediaEventListeners)) {
      const handler = mediaEventListeners[eventType].bind(this);
      this.providerDisposal.add(listen2(this._provider, eventType, handler));
    }
  }
  _clearMediaStateTracking() {
    this._isReplay = false;
    this._isLooping = false;
    this._firingWaiting = false;
    this._originalWaitingEvent = void 0;
    this._mediaEvents = [];
  }
  _findLastMediaEvent(eventType) {
    return this._mediaEvents[this._mediaEvents.map((e2) => e2.type).lastIndexOf(eventType)];
  }
  _handleCanLoad(event) {
    this._store.canLoad.set(true);
    this._mediaEvents.push(event);
    this._satisfyMediaRequest("loading", event);
  }
  _updateMetadata(metadata) {
    this._store.currentSrc.set(metadata.currentSrc);
    this._store.mediaType.set(metadata.mediaType);
    this._store.viewType.set(metadata.viewType);
  }
  _handleLoadStart(event) {
    this._updateMetadata(event.detail);
    this._mediaEvents.push(event);
    appendTriggerEvent(event, this._findLastMediaEvent("vds-src-change"));
    appendTriggerEvent(event, this._findLastMediaEvent("vds-can-load"));
  }
  _handleLoadedData(event) {
    this._mediaEvents.push(event);
    appendTriggerEvent(event, this._findLastMediaEvent("vds-load-start"));
  }
  _handleLoadedMetadata(event) {
    this._updateMetadata(event.detail);
    this._mediaEvents.push(event);
    appendTriggerEvent(event, this._findLastMediaEvent("vds-load-start"));
  }
  _handleCanPlay(event) {
    var _a;
    this._mediaEvents.push(event);
    if (((_a = event.triggerEvent) == null ? void 0 : _a.type) !== "loadedmetadata") {
      appendTriggerEvent(event, this._findLastMediaEvent("vds-loaded-metadata"));
    }
    this._store.canPlay.set(true);
    this._store.duration.set(event.detail.duration);
    this._host.setAttribute("aria-busy", "false");
  }
  _handleCanPlayThrough(event) {
    this._store.canPlay.set(true);
    this._store.duration.set(event.detail.duration);
    appendTriggerEvent(event, this._findLastMediaEvent("vds-can-play"));
  }
  _handleAutoplay(event) {
    this._mediaEvents.push(event);
    appendTriggerEvent(event, this._findLastMediaEvent("vds-play"));
    appendTriggerEvent(event, this._findLastMediaEvent("vds-can-play"));
    this._store.autoplayError.set(void 0);
  }
  _handleAutoplayFail(event) {
    appendTriggerEvent(event, this._findLastMediaEvent("vds-play-fail"));
    appendTriggerEvent(event, this._findLastMediaEvent("vds-can-play"));
    this._store.autoplayError.set(event.detail);
    this._clearMediaStateTracking();
  }
  _handlePlay(event) {
    var _a;
    if (this._isLooping || !this.state.paused) {
      event.stopImmediatePropagation();
      return;
    }
    this._mediaEvents.push(event);
    appendTriggerEvent(event, this._findLastMediaEvent("vds-waiting"));
    this._satisfyMediaRequest("play", event);
    this._store.paused.set(false);
    this._store.autoplayError.set(void 0);
    if (this.state.ended || this._isReplay) {
      this._isReplay = false;
      this._store.ended.set(false);
      const replayEvent = vdsEvent2("vds-replay", {
        triggerEvent: event
      });
      (_a = this._provider) == null ? void 0 : _a.dispatchEvent(replayEvent);
    }
  }
  _handlePlayFail(event) {
    this._mediaEvents.push(event);
    this._stopWaiting();
    appendTriggerEvent(event, this._findLastMediaEvent("vds-play"));
    this._store.paused.set(true);
    this._store.playing.set(false);
    this._satisfyMediaRequest("play", event);
    this._clearMediaStateTracking();
  }
  _handlePlaying(event) {
    var _a;
    this._mediaEvents.push(event);
    const playEvent = this._findLastMediaEvent("vds-play");
    if (playEvent) {
      appendTriggerEvent(event, this._findLastMediaEvent("vds-waiting"));
      appendTriggerEvent(event, playEvent);
    } else {
      appendTriggerEvent(event, this._findLastMediaEvent("vds-seeked"));
    }
    this._stopWaiting();
    this._clearMediaStateTracking();
    this._store.paused.set(false);
    this._store.playing.set(true);
    this._store.seeking.set(false);
    this._store.ended.set(false);
    if (this._isLooping) {
      event.stopImmediatePropagation();
      this._isLooping = false;
      return;
    }
    if (!this.state.started) {
      this._store.started.set(true);
      (_a = this._provider) == null ? void 0 : _a.dispatchEvent(vdsEvent2("vds-started", { triggerEvent: event }));
    }
  }
  _handlePause(event) {
    if (this._isLooping) {
      event.stopImmediatePropagation();
      return;
    }
    appendTriggerEvent(event, this._findLastMediaEvent("vds-seeked"));
    this._satisfyMediaRequest("pause", event);
    this._store.paused.set(true);
    this._store.playing.set(false);
    this._store.seeking.set(false);
    this._stopWaiting();
    this._clearMediaStateTracking();
  }
  _handleTimeUpdate(event) {
    const { currentTime, played } = event.detail;
    this._store.currentTime.set(currentTime);
    this._store.played.set(played);
    this._store.waiting.set(false);
  }
  _handleVolumeChange(event) {
    this._store.volume.set(event.detail.volume);
    this._store.muted.set(event.detail.muted || event.detail.volume === 0);
    this._satisfyMediaRequest("volume", event);
  }
  _handleSeeked(event) {
    if (this._isSeekingRequestPending) {
      this._store.seeking.set(true);
      event.stopImmediatePropagation();
    } else if (this.state.seeking) {
      this._mediaEvents.push(event);
      appendTriggerEvent(event, this._findLastMediaEvent("vds-waiting"));
      appendTriggerEvent(event, this._findLastMediaEvent("vds-seeking"));
      if (this.state.paused) {
        this._stopWaiting();
      }
      this._store.seeking.set(false);
      if (event.detail !== this.state.duration) {
        this._store.ended.set(false);
      }
      this._store.currentTime.set(event.detail);
      this._satisfyMediaRequest("seeked", event);
    }
  }
  _stopWaiting() {
    this._fireWaiting.cancel();
    this._store.waiting.set(false);
  }
  _handleWaiting(event) {
    if (this._firingWaiting)
      return;
    event.stopImmediatePropagation();
    this._originalWaitingEvent = event;
    this._fireWaiting();
  }
  _handleEnded(event) {
    if (this._isLooping) {
      event.stopImmediatePropagation();
      return;
    }
    this._stopWaiting();
    this._store.paused.set(true);
    this._store.playing.set(false);
    this._store.seeking.set(false);
    this._store.ended.set(true);
    this._clearMediaStateTracking();
  }
  _handleAutoplayChange(event) {
    this._store.autoplay.set(event.detail);
  }
  _handleCurrentSrcChange(event) {
    this._store.currentSrc.set(event.detail);
    if (this._skipInitialSrcChange) {
      this._skipInitialSrcChange = false;
      return;
    }
    this._clearMediaStateTracking();
    softResetMediaStore(this._store);
    this._host.setAttribute("aria-busy", "true");
  }
  _handleError(event) {
    this._store.error.set(event.detail);
  }
  _handleFullscreenSupportChange(event) {
    this._store.canFullscreen.set(event.detail);
  }
  _handlePosterChange(event) {
    this._store.poster.set(event.detail);
  }
  _handleLoopChange(event) {
    this._store.loop.set(event.detail);
  }
  _handlePlaysinlineChange(event) {
    this._store.playsinline.set(event.detail);
  }
  _handleControlsChange(event) {
    this._store.controls.set(event.detail);
  }
  _handleMediaTypeChange(event) {
    this._store.mediaType.set(event.detail);
  }
  _handleDurationChange(event) {
    const duration = event.detail;
    this._store.duration.set(!isNaN(duration) ? duration : 0);
  }
  _handleProgress(event) {
    const { buffered, seekable } = event.detail;
    const bufferedAmount = buffered.length === 0 ? 0 : buffered.end(buffered.length - 1);
    const seekableAmount = seekable.length === 0 ? 0 : seekable.end(seekable.length - 1);
    this._store.buffered.set(buffered);
    this._store.bufferedAmount.set(bufferedAmount);
    this._store.seekable.set(seekable);
    this._store.seekableAmount.set(seekableAmount);
  }
  _handleSrcChange(event) {
    this._store.src.set(event.detail);
  }
  _handleViewTypeChange(event) {
    this._store.viewType.set(event.detail);
  }
};

// src/media/MediaElement.ts
import {
  discoverable,
  FullscreenController,
  IS_IOS,
  ScreenOrientationController,
  setAttribute as setAttribute2
} from "@vidstack/foundation";

// src/media/style/MediaAttrsController.ts
import { isNumber, isString, setAttribute } from "@vidstack/foundation";

// src/media/style/MediaStyleController.ts
import { camelToKebabCase, DisposalBin as DisposalBin3, requestIdleCallback } from "@vidstack/foundation";
var MediaStyleController = class {
  constructor(_host, _store, _mediaProps) {
    this._host = _host;
    this._store = _store;
    this._mediaProps = _mediaProps;
    this._disposal = new DisposalBin3();
    this._host.addController({
      hostConnected: this._hostConnected.bind(this),
      hostDisconnected: this._hostDisconnected.bind(this)
    });
  }
  _hostConnected() {
    requestIdleCallback(() => {
      for (const propName of this._mediaProps) {
        const store = this._store[propName];
        if (store) {
          const attrName = this._getMediaAttrName(propName);
          const unsub = store.subscribe(($v) => {
            window == null ? void 0 : (typeof window !== "undefined" ? window : null)?.requestAnimationFrame(() => {
              this._handleValueChange(propName, attrName, $v);
            });
          });
          this._disposal.add(unsub);
        }
      }
    });
  }
  _hostDisconnected() {
    for (const propName of this._mediaProps) {
      this._handleDisconnect(propName, this._getMediaAttrName(propName));
    }
    this._disposal.empty();
  }
  _getMediaAttrName(propName) {
    return camelToKebabCase(propName);
  }
};

// src/media/style/MediaAttrsController.ts
var MediaAttrsController = class extends MediaStyleController {
  _handleValueChange(_, attrName, value) {
    (typeof window !== "undefined" ? window : null)?.requestAnimationFrame(() => {
      setAttribute(
        this._host,
        attrName,
        isString(value) || isNumber(value) ? String(value) : !!value
      );
    });
  }
  _handleDisconnect(_, attrName) {
    this._host.removeAttribute(attrName);
  }
};
function bindMediaPropsToAttrs(...params) {
  return new MediaAttrsController(...params);
}

// src/media/style/MediaCssPropsController.ts
import { isNumber as isNumber2, isString as isString2 } from "@vidstack/foundation";
var MediaCssPropsController = class extends MediaStyleController {
  _handleValueChange(_, attrName, value) {
    (typeof window !== "undefined" ? window : null)?.requestAnimationFrame(() => {
      this._host.style.setProperty(
        this._getCssPropName(attrName),
        isString2(value) || isNumber2(value) ? String(value) : null
      );
    });
  }
  _getCssPropName(attrName) {
    return `--vds-${attrName}`;
  }
  _handleDisconnect(_, attrName) {
    this._host.style.setProperty(this._getCssPropName(attrName), null);
  }
};
function bindMediaPropsToCssProps(...params) {
  return new MediaCssPropsController(...params);
}

// src/media/MediaElement.ts
var mediaDiscoveryId = Symbol("@vidstack/media-discovery");
var MediaElement = class extends s {
  constructor() {
    super();
    this.controller = new MediaController(this);
    this.__mediaFullscreen = false;
    this.__mediaIsVideoView = false;
    this.__mediaPlaysinline = false;
    this.screenOrientationController = new ScreenOrientationController(this);
    this.fullscreenController = new FullscreenController(this, this.screenOrientationController);
    discoverable(this, "vds-media-connect", { register: mediaDiscoveryId });
    mediaStoreSubscription(this, "fullscreen", ($fullscreen) => {
      this.__mediaFullscreen = $fullscreen;
    });
    mediaStoreSubscription(this, "viewType", ($viewType) => {
      this.__mediaIsVideoView = $viewType === "video" /* Video */;
    });
    mediaStoreSubscription(this, "playsinline", ($playsinline) => {
      this.__mediaPlaysinline = $playsinline;
    });
    this._bindMediaAttributes();
    this._bindMediaCSSProperties();
  }
  static get styles() {
    return [
      i`:host{display:inline-block;position:relative;contain:content}:host([hidden]){display:none}`
    ];
  }
  get provider() {
    return this.controller.provider;
  }
  update(changedProperties) {
    setAttribute2(this, "hide-ui", this._shouldHideMediaUI());
    super.update(changedProperties);
  }
  render() {
    return y`<slot></slot>`;
  }
  get canFullscreen() {
    return this.fullscreenController.isSupported;
  }
  get fullscreen() {
    return this.fullscreenController.isFullscreen;
  }
  get fullscreenOrientation() {
    return this.fullscreenController.screenOrientationLock;
  }
  set fullscreenOrientation(lockType) {
    const prevLockType = this.fullscreenController.screenOrientationLock;
    if (prevLockType !== lockType) {
      this.fullscreenController.screenOrientationLock = lockType;
      this.requestUpdate("fullscreen-orientation", prevLockType);
    }
  }
  enterFullscreen() {
    return this.fullscreenController.enterFullscreen();
  }
  exitFullscreen() {
    return this.fullscreenController.exitFullscreen();
  }
  _bindMediaAttributes() {
    bindMediaPropsToAttrs(this, this.controller.store, [
      "autoplay",
      "autoplayError",
      "canLoad",
      "canPlay",
      "canFullscreen",
      "ended",
      "error",
      "fullscreen",
      "userIdle",
      "loop",
      "mediaType",
      "muted",
      "paused",
      "playing",
      "playsinline",
      "seeking",
      "started",
      "viewType",
      "waiting"
    ]);
  }
  _bindMediaCSSProperties() {
    bindMediaPropsToCssProps(this, this.controller.store, [
      "bufferedAmount",
      "currentTime",
      "duration",
      "seekableAmount"
    ]);
  }
  _shouldHideMediaUI() {
    return IS_IOS && this.__mediaIsVideoView && (!this.__mediaPlaysinline || this.__mediaFullscreen);
  }
};
__decorateClass([
  t()
], MediaElement.prototype, "__mediaFullscreen", 2);
__decorateClass([
  t()
], MediaElement.prototype, "__mediaIsVideoView", 2);
__decorateClass([
  t()
], MediaElement.prototype, "__mediaPlaysinline", 2);
__decorateClass([
  e({ attribute: "fullscreen-orientation" })
], MediaElement.prototype, "fullscreenOrientation", 1);

export {
  UserIdleController,
  MediaController,
  mediaDiscoveryId,
  MediaElement
};
