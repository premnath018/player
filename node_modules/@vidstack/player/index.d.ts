/// <reference types="@vidstack/foundation/globals" />

import { appendTriggerEvent } from '@vidstack/foundation';
import type { AudioTrackLoadedData } from 'hls.js';
import type { AudioTracksUpdatedData } from 'hls.js';
import type { AudioTrackSwitchedData } from 'hls.js';
import type { AudioTrackSwitchingData } from 'hls.js';
import type { BackBufferData } from 'hls.js';
import type { BufferAppendedData } from 'hls.js';
import type { BufferAppendingData } from 'hls.js';
import type { BufferCodecsData } from 'hls.js';
import type { BufferCreatedData } from 'hls.js';
import type { BufferEOSData } from 'hls.js';
import type { BufferFlushedData } from 'hls.js';
import type { BufferFlushingData } from 'hls.js';
import { Context } from '@vidstack/foundation';
import { ContextConsumerController } from '@vidstack/foundation';
import { ContextProviderController } from '@vidstack/foundation';
import { CSSResultGroup } from 'lit';
import type { CuesParsedData } from 'hls.js';
import { DeferredPromise } from '@vidstack/foundation';
import { DisconnectCallback } from '@vidstack/foundation';
import { DiscoveryEvent } from '@vidstack/foundation';
import { DisposalBin } from '@vidstack/foundation';
import type { ErrorData } from 'hls.js';
import type { Events } from 'hls.js';
import { ExtractEventInit } from '@vidstack/foundation';
import { findTriggerEvent } from '@vidstack/foundation';
import type { FPSDropData } from 'hls.js';
import type { FPSDropLevelCappingData } from 'hls.js';
import type { FragBufferedData } from 'hls.js';
import type { FragChangedData } from 'hls.js';
import type { FragDecryptedData } from 'hls.js';
import type { FragLoadedData } from 'hls.js';
import type { FragLoadEmergencyAbortedData } from 'hls.js';
import type { FragLoadingData } from 'hls.js';
import type { FragParsedData } from 'hls.js';
import type { FragParsingInitSegmentData } from 'hls.js';
import type { FragParsingMetadataData } from 'hls.js';
import type { FragParsingUserdataData } from 'hls.js';
import { FullscreenChangeEvent } from '@vidstack/foundation';
import { FullscreenController } from '@vidstack/foundation';
import { FullscreenControllerHost } from '@vidstack/foundation';
import { FullscreenErrorEvent } from '@vidstack/foundation';
import { FullscreenSupportChange } from '@vidstack/foundation';
import { hasTriggerEvent } from '@vidstack/foundation';
import type Hls from 'hls.js';
import type { HlsConfig } from 'hls.js';
import type { InitPTSFoundData } from 'hls.js';
import { IntersectionController } from '@vidstack/foundation';
import { isHlsjsSupported } from '@vidstack/foundation';
import type { KeyLoadedData } from 'hls.js';
import type { KeyLoadingData } from 'hls.js';
import type { LevelLoadedData } from 'hls.js';
import type { LevelLoadingData } from 'hls.js';
import type { LevelPTSUpdatedData } from 'hls.js';
import type { LevelsUpdatedData } from 'hls.js';
import type { LevelSwitchedData } from 'hls.js';
import type { LevelSwitchingData } from 'hls.js';
import type { LevelUpdatedData } from 'hls.js';
import { LitElement } from 'lit';
import { LogController } from '@vidstack/foundation';
import { LogDispatcher } from '@vidstack/foundation';
import { LogLevel } from '@vidstack/foundation';
import type { ManifestLoadedData } from 'hls.js';
import type { ManifestLoadingData } from 'hls.js';
import type { ManifestParsedData } from 'hls.js';
import type { MediaAttachedData } from 'hls.js';
import type { MediaAttachingData } from 'hls.js';
import type { NonNativeTextTracksData } from 'hls.js';
import { PageController } from '@vidstack/foundation';
import type { PageState } from '@vidstack/foundation';
import type { PageVisibility } from '@vidstack/foundation';
import { PropertyValues } from 'lit';
import { RafThrottledFunction } from '@vidstack/foundation';
import { ReactiveController } from 'lit';
import { ReactiveControllerHost } from 'lit';
import { ReactiveElement } from 'lit';
import { ReadableStore } from '@vidstack/foundation';
import { Ref } from 'lit/directives/ref.js';
import { RequestQueue } from '@vidstack/foundation';
import { ScreenOrientationChangeEvent } from '@vidstack/foundation';
import { ScreenOrientationController } from '@vidstack/foundation';
import { ScreenOrientationLock } from '@vidstack/foundation';
import { ScreenOrientationLockChangeEvent } from '@vidstack/foundation';
import { StoreSubscriptionHost } from '@vidstack/foundation';
import type { SubtitleFragProcessedData } from 'hls.js';
import type { SubtitleTrackLoadedData } from 'hls.js';
import type { SubtitleTracksUpdatedData } from 'hls.js';
import type { SubtitleTrackSwitchData } from 'hls.js';
import { TemplateResult } from 'lit';
import type { TrackLoadingData } from 'hls.js';
import { VdsEvent } from '@vidstack/foundation';
import { walkTriggerEventChain } from '@vidstack/foundation';
import { WritableStore } from '@vidstack/foundation';

export { appendTriggerEvent }

/**
 * This element creates a container that will hold the dimensions of the desired aspect ratio. This
 * container is useful for reserving space for media as it loads over the network.
 *
 * ðŸ’¡  If your browser matrix supports the
 * [`aspect-ratio`](https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio) CSS property
 * then you can skip using this component, and set the desired aspect ratio directly on the
 * provider element.
 *
 * ðŸ’¡ By default it respects the browser's default aspect-ratio for media. This is not specific
 * to the loaded media but instead a general setting of `2/1`.
 *
 * @tagname vds-aspect-ratio
 * @slot - Used to pass in a media provider element.
 * @example
 * ```html
 * <vds-aspect-ratio ratio="16/9">
 *  <vds-video>
 *   <!-- ... -->
 *  </vds-video>
 * </vds-aspect-ratio>
 * ```
 */
export declare class AspectRatioElement extends LitElement {
    static get styles(): CSSResultGroup;
    /**
     * The minimum height of the container.
     *
     * @defaultValue '150px'
     */
    minHeight: string;
    /**
     * The maximum height of the container.
     *
     * @defaultValue '100vh'
     */
    maxHeight: string;
    /**
     * The desired aspect ratio setting given as `'width/height'` (eg: `'16/9'`).
     *
     * @defaultValue '2/1'
     */
    ratio: string;
    /**
     * Whether the current `ratio` is a valid aspect ratio setting in the form `width/height`.
     */
    get isValidRatio(): boolean;
    render(): TemplateResult;
    protected _getAspectRatioPercent(): string;
    protected _parseAspectRatio(): [number, number];
}

export declare const AUDIO_EXTENSIONS: RegExp;

/**
 * The `<vds-audio>` element adapts the underlying `<audio>` element to satisfy the media provider
 * contract, which generally involves providing a consistent API for loading, managing, and
 * tracking media state.
 *
 * Most the logic for this element is contained in the `Html5MediaElement` class because both the
 * `<audio>` and `<video>` elements implement the native `HTMLMediaElement` interface.
 *
 * @tagname vds-audio
 * @slot - Used to pass in the `<audio>` element.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}
 * @example
 * ```html
 * <vds-audio>
 *   <audio
 *     controls
 *     preload="none"
 *     src="https://media-files.vidstack.io/audio.mp3"
 *    ></audio>
 * </vds-audio>
 * ```
 * @example
 * ```html
 * <vds-audio>
 *   <audio controls preload="none">
 *     <source src="https://media-files.vidstack.io/audio.mp3" type="audio/mp3" />
 *   </audio>
 * </vds-audio>
 * ```
 */
export declare class AudioElement extends Html5MediaElement {
    static get styles(): CSSResultGroup;
    connectedCallback(): void;
}

export declare function createMediaStore(): WritableMediaStoreRecord;

export declare function createSliderStore(): {
    /**
     * The current slider value.
     */
    value: WritableStore<number>;
    /**
     * The value at which the device pointer is pointing to inside the slider.
     */
    pointerValue: WritableStore<number>;
    /**
     * The minimum slider value.
     */
    min: WritableStore<number>;
    /**
     * The maximum slider value.
     */
    max: WritableStore<number>;
    /**
     * Whether the slider thumb is currently being dragged.
     */
    dragging: WritableStore<boolean>;
    /**
     * Whether a device pointer is within the slider bounds.
     */
    pointing: WritableStore<boolean>;
    /**
     * Whether the slider is being interacted with.
     */
    interactive: ReadableStore<boolean>;
};

export declare type DynamicHlsConstructorImport = () => Promise<{
    default: HlsConstructor;
} | undefined>;

/**
 * Fired when requesting media to enter fullscreen. The event `detail` can specify the
 * fullscreen target, which can be the media or provider element (defaults to `media`).
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type EnterFullscreenRequestEvent = VdsEvent<MediaFullscreenRequestTarget>;

export declare type EnterVisibilityMediaAction = 'play' | 'unmute';

/**
 * Fired when requesting media to exit fullscreen. The event `detail` can specify the fullscreen
 * target, which can be the media or provider element (defaults to `media`).
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type ExitFullscreenRequestEvent = VdsEvent<MediaFullscreenRequestTarget>;

export declare type ExitVisibilityMediaAction = 'pause' | 'mute';

export { findTriggerEvent }

/**
 * A button for toggling the fullscreen mode of the player.
 *
 * ðŸ’¡ The following attributes are applied:
 *
 * - `fullscreen`: Applied when the media has entered fullscreen.
 *
 * ðŸš¨ The `hidden` attribute will be present on this element in the event fullscreen cannot be
 * requested (no support). There are default styles for this by setting the `display` property to
 * `none`. Important to be aware of this and update it according to your needs.
 *
 * @tagname vds-fullscreen-button
 * @slot - Used to pass content into the fullscreen toggle for showing enter/exit states.
 * @example
 * ```html
 * <vds-fullscreen-button>
 *   <div class="enter">Enter</div>
 *   <div class="exit">Exit</div>
 * </vds-fullscreen-button>
 * ```
 * @example
 * ```css
 * vds-fullscreen-button[fullscreen] .enter {
 *   display: none;
 * }
 *
 * vds-fullscreen-button:not([fullscreen]) .exit {
 *   display: none;
 * }
 * ```
 */
export declare class FullscreenButtonElement extends ToggleButtonElement {
    protected readonly _mediaRemote: MediaRemoteControl;
    /**
     * The target element on which to request fullscreen on. The target can be the `media`
     * (i.e., `<vds-media>`) or `provider` (e.g., `<vds-video>`) element.
     *
     * @defaultValue 'media'
     */
    target?: MediaFullscreenRequestTarget;
    constructor();
    connectedCallback(): void;
    protected _handleButtonClick(event: Event): void;
}

export declare type GestureAction = 'play' | 'pause' | 'mute' | 'unmute' | 'enter-fullscreen' | 'exit-fullscreen' | `seek:${number}` | `toggle:${'paused' | 'muted' | 'fullscreen'}`;

/**
 * This element enables 'actions' to be performed on the media provider based on user gestures.
 *
 * The `GestureElement` can be used to build features such as:
 *
 * - Click the player to toggle playback.
 * - Double-click the player to toggle fullscreen.
 * - Tap the sides of the player to seek forwards or backwards.
 * - Pause media when the user's mouse leaves the player.
 *
 * This is a simple list, but it should give you an idea on when to reach for this element.
 *
 * @experimental
 * @tagname vds-gesture
 * @example
 * ```html
 * <vds-media>
 *   <vds-gesture type="mouseleave" action="pause"></vds-gesture>
 *   <vds-gesture type="click" action="toggle:paused"></vds-gesture>
 *   <vds-gesture
 *     type="click"
 *     repeat="1"
 *     action="toggle:fullscreen"
 *     priority="0"
 *   ></vds-gesture>
 * </vds-media>
 * ```
 */
export declare class GestureElement extends LitElement {
    static get styles(): CSSResultGroup;
    protected _mediaProviderElement?: MediaProviderElement;
    protected _isUserIdle: boolean;
    protected _disposal: DisposalBin;
    /** Pending actions that belong to the same container as this gesture element. */
    protected get _pendingActions(): Map<GestureElement, [event: Event, promise: DeferredPromise<void, void>]> | undefined;
    /** Pending action that belongs to this gesture element. */
    protected get _pendingAction(): [event: Event, promise: DeferredPromise<void, void>] | undefined;
    constructor();
    /**
     * The DOM event type that will trigger this gesture. It can be any valid DOM event type.
     *
     * @example 'pointerdown'
     * @example 'mouseleave'
     * @example 'touchstart'
     */
    type?: GestureType;
    /**
     * The number of times a gesture event `type` should be repeated before the action is
     * performed. Keep in mind that the provided value is a multiplier, and not a constant. Thus, if
     * you want an event to occur twice before the action is performed, this will be a single
     * repetition (eg: value of `1`).
     *
     * @defaultValue 0
     * @example 0 - wait for event to occur once.
     * @example 1 - wait for event to occur twice.
     * @example 2 - wait for event to occur thrice.
     */
    repeat: number;
    /**
     * The level of importance given to this gesture. If multiple gestures occur at the same time,
     * the priority will determine which gesture actions are performed. Higher priority gestures in
     * a single batch will cause lower level priorities to be ignored.
     *
     *ðŸ’¡ A lower priority value means greater prioritization (eg: `0 > 1 > 2 > ... > 100`).
     *
     * @defaultValue 10
     */
    priority: number;
    /**
     * An action describes the type of media request event that will be dispatched, which will
     * ultimately perform some operation on the player (eg: fullscreen, mute, etc.).
     *
     * @example 'play'
     * @example 'seek:30'
     * @example 'seek:-30'
     * @example 'toggle:paused'
     */
    action?: GestureAction;
    /**
     * Whether the gesture action can be triggered while the user is idle.
     *
     * @defaultValue false
     */
    whileIdle: boolean;
    connectedCallback(): void;
    protected willUpdate(changedProperties: PropertyValues): void;
    disconnectedCallback(): void;
    performAction(event?: Event): void;
    protected _attachListener(): void;
    protected _validateEvent(event: Event): boolean;
    protected _mediaCurrentTime: number;
    protected _subscribeToSeekStore(): void;
    protected _currentToggleState: boolean;
    protected _mediaStoreConsumer: ContextConsumerController<WritableMediaStoreRecord>;
    protected get _mediaStore(): WritableMediaStoreRecord;
    protected _getToggleEventType(): string;
    protected _subscribeToToggleStore(): void;
}

export declare type GestureType = keyof HTMLElementEventMap;

export { hasTriggerEvent }

/**
 * Fired when requesting the poster should _not_ be rendered by the media provider element. This
 * should be fired if a custom poster element is being used (eg: `vds-poster`).
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type HidePosterRequestEvent = VdsEvent<void>;

export declare const HLS_EXTENSIONS: RegExp;

export declare const HLS_TYPES: Set<string>;

/**
 * Fired when loading an audio track finishes.
 *
 * @event
 */
export declare type HlsAudioTrackLoadedEvent = VdsHlsEvent<AudioTrackLoadedData>;

/**
 * Fired when loading an audio track starts.
 *
 * @event
 */
export declare type HlsAudioTrackLoadingEvent = VdsHlsEvent<TrackLoadingData>;

/**
 * Fired to notify that the audio track list has been updated.
 *
 * @event
 */
export declare type HlsAudioTracksUpdatedEvent = VdsHlsEvent<AudioTracksUpdatedData>;

/**
 * Fired when an audio track switch actually occurs.
 *
 * @event
 */
export declare type HlsAudioTrackSwitchedEvent = VdsHlsEvent<AudioTrackSwitchedData>;

/**
 * Fired when an audio track switching is requested.
 *
 * @event
 */
export declare type HlsAudioTrackSwitchingEvent = VdsHlsEvent<AudioTrackSwitchingData>;

/**
 * Fired when the back buffer is reached as defined by the `backBufferLength` config option.
 *
 * @event
 */
export declare type HlsBackBufferReachedEvent = VdsHlsEvent<BackBufferData>;

/**
 * Fired when we are done with appending a media segment to the buffer.
 *
 * @event
 */
export declare type HlsBufferAppendedEvent = VdsHlsEvent<BufferAppendedData>;

/**
 * Fired when we begin appending a media segment to the buffer.
 *
 * @event
 */
export declare type HlsBufferAppendingEvent = VdsHlsEvent<BufferAppendingData>;

/**
 * Fired when we know about the codecs that we need buffers for to push into.
 *
 * @event
 */
export declare type HlsBufferCodecsEvent = VdsHlsEvent<BufferCodecsData>;

/**
 * Fired when `SourceBuffer`'s have been created.
 *
 * @event
 */
export declare type HlsBufferCreatedEvent = VdsHlsEvent<BufferCreatedData>;

/**
 * Fired when the stream is finished and we want to notify the media buffer that there will be no
 * more data.
 *
 * @event
 */
export declare type HlsBufferEosEvent = VdsHlsEvent<BufferEOSData>;

/**
 * Fired when the media buffer has been flushed.
 *
 * @event
 */
export declare type HlsBufferFlushedEvent = VdsHlsEvent<BufferFlushedData>;

/**
 * Fired when the media buffer should be flushed.
 *
 * @event
 */
export declare type HlsBufferFlushingEvent = VdsHlsEvent<BufferFlushingData>;

/**
 * Fired when we buffer is going to be reset.
 *
 * @event
 */
export declare type HlsBufferResetEvent = VdsHlsEvent<void>;

export declare type HlsConstructor = typeof Hls;

/**
 * Fired when a set of `VTTCue`'s to be managed externally has been parsed.
 *
 * @event
 */
export declare type HlsCuesParsedEvent = VdsHlsEvent<CuesParsedData>;

/**
 * Fired when the `hls.js` instance is being destroyed. Different from `vds-hls-media-detached` as
 * one could want to detach, and reattach media to the `hls.js` instance to handle mid-rolls.
 *
 * @event
 */
export declare type HlsDestroyingEvent = VdsHlsEvent<void>;

/**
 * The `<vds-hls>` element adapts the underlying `<video>` element to satisfy the media provider
 * contract, which generally involves providing a consistent API for loading, managing, and
 * tracking media state.
 *
 * This element also introduces support for HLS streaming via the popular `hls.js` library.
 * HLS streaming is either [supported natively](https://caniuse.com/?search=hls) (generally
 * on iOS), or in environments that [support the Media Stream API](https://caniuse.com/?search=mediastream).
 *
 * ðŸ’¡ This element re-dispatches all `hls.js` events so you can listen for them through the
 * native DOM interface (i.e., `vds-hls-media-attaching`).
 *
 * @tagname vds-hls
 * @slot - Used to pass in the `<video>` element.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video}
 * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md}
 * @events ./events.ts
 * @example
 * ```html
 * <vds-hls poster="https://media-files.vidstack.io/poster.png">
 *   <video
 *     controls
 *     preload="none"
 *     src="https://media-files.vidstack.io/hls/index.m3u8"
 *     poster="https://media-files.vidstack.io/poster-seo.png"
 *   ></video>
 * </vds-hls>
 * ```
 * @example
 * ```html
 * <vds-hls poster="https://media-files.vidstack.io/poster.png">
 *   <video
 *     controls
 *     preload="none"
 *     poster="https://media-files.vidstack.io/poster-seo.png"
 *   >
 *     <source
 *       src="https://media-files.vidstack.io/hls/index.m3u8"
 *       type="application/x-mpegURL"
 *     />
 *     <track
 *       default
 *       kind="subtitles"
 *       srclang="en"
 *       label="English"
 *       src="https://media-files.vidstack.io/subs/english.vtt"
 *     />
 *   </video>
 * </vds-hls>
 * ```
 */
export declare class HlsElement extends VideoElement {
    protected _hlsEngine: Hls | undefined;
    protected _isHlsEngineAttached: boolean;
    constructor();
    /**
     * The `hls.js` configuration object.
     *
     * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#fine-tuning}
     */
    hlsConfig: Partial<HlsConfig | undefined>;
    /**
     * The `hls.js` constructor (supports dynamic imports) or a URL of where it can be found.
     *
     * @defaultValue `https://cdn.jsdelivr.net/npm/hls.js@^1.0.0/dist/hls.js`
     */
    hlsLibrary: HlsConstructor | DynamicHlsConstructorImport | string | undefined;
    protected _Hls: HlsConstructor | undefined;
    /**
     * The `hls.js` constructor.
     */
    get Hls(): typeof Hls | undefined;
    /**
     * The current `hls.js` instance.
     */
    get hlsEngine(): Hls | undefined;
    /**
     * Whether the `hls.js` instance has mounted the `HtmlMediaElement`.
     *
     * @defaultValue false
     */
    get isHlsEngineAttached(): boolean;
    protected _currentHlsSrc: string;
    /**
     * The absolute URL of the chosen HLS media resource. Defaults to `''` if no media has been
     * loaded.
     *
     * @defaultValue ''
     */
    get currentHlsSrc(): string;
    protected update(changedProperties: PropertyValues): Promise<void>;
    destroy(): void;
    /**
     * Whether HLS streaming is supported in this environment.
     */
    get isHlsSupported(): boolean;
    /**
     * Whether the current src is using HLS.
     *
     * @defaultValue false
     */
    get isHlsStream(): boolean;
    /**
     * Attempts to preconnect to the `hls.js` remote source given via `hlsLibrary`. This is
     * assuming `hls.js` is not bundled and `hlsLibrary` is a URL string pointing to where it
     * can be found.
     */
    protected _preconnectToHlsLibDownload(): void;
    protected _buildHlsEngine(forceRebuild?: boolean): Promise<void>;
    protected _attachHlsEngine(): void;
    protected _detachHlsEngine(): void;
    protected _loadSrcOnHlsEngine(src: string): void;
    protected _getMediaType(): MediaType;
    protected _destroyHlsEngine(): void;
    protected _handleSrcChange(sources: string[]): void;
    protected _handleAbort(event?: Event): void;
    protected _handleHlsSrcChange(src: string): Promise<void>;
    protected _handleLoadedMetadata(event: Event): void;
    protected _listenToHlsEngine(): void;
    protected _handleHlsError(eventType: string, data: ErrorData): void;
    protected _handleHlsNetworkError(): void;
    protected _handleHlsMediaError(): void;
    protected _handleHlsIrrecoverableError(): void;
    protected _handleHlsLevelLoaded(eventType: string, data: LevelLoadedData): void;
    protected _handleHlsMediaReady(eventType: string, data: LevelLoadedData): void;
    protected _hlsEventListeners: {
        listener: () => void;
        type: Events;
        options?: AddEventListenerOptions & {
            context: any;
        };
    }[];
    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | (AddEventListenerOptions & {
        context: any;
    })): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | (AddEventListenerOptions & {
        context: any;
    })): void;
    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}

/**
 * Fired when an error has occurred during loading or playback.
 *
 * @event
 */
export declare type HlsErrorEvent = VdsHlsEvent<ErrorData>;

export declare type HlsEvents = {
    'vds-hls-lib-load-start': HlsLibLoadStartEvent;
    'vds-hls-lib-loaded': HlsLibLoadedEvent;
    'vds-hls-lib-load-error': HlsLibLoadErrorEvent;
    'vds-hls-instance': HlsInstanceEvent;
    'vds-hls-unsupported': HlsUnsupportedEvent;
    'vds-hls-media-attaching': HlsMediaAttachingEvent;
    'vds-hls-media-attached': HlsMediaAttachedEvent;
    'vds-hls-media-detaching': HlsMediaDetachingEvent;
    'vds-hls-media-detached': HlsMediaDetachedEvent;
    'vds-hls-buffer-reset': HlsBufferResetEvent;
    'vds-hls-buffer-codecs': HlsBufferCodecsEvent;
    'vds-hls-buffer-created': HlsBufferCreatedEvent;
    'vds-hls-buffer-appending': HlsBufferAppendingEvent;
    'vds-hls-buffer-appended': HlsBufferAppendedEvent;
    'vds-hls-buffer-eos': HlsBufferEosEvent;
    'vds-hls-buffer-flushing': HlsBufferFlushingEvent;
    'vds-hls-buffer-flushed': HlsBufferFlushedEvent;
    'vds-hls-manifest-loading': HlsManifestLoadingEvent;
    'vds-hls-manifest-loaded': HlsManifestLoadedEvent;
    'vds-hls-manifest-parsed': HlsManifestParsedEvent;
    'vds-hls-level-switching': HlsLevelSwitchingEvent;
    'vds-hls-level-switched': HlsLevelSwitchedEvent;
    'vds-hls-level-loading': HlsLevelLoadingEvent;
    'vds-hls-level-loaded': HlsLevelLoadedEvent;
    'vds-hls-level-updated': HlsLevelUpdatedEvent;
    'vds-hls-level-pts-updated': HlsLevelPtsUpdatedEvent;
    'vds-hls-levels-updated': HlsLevelsUpdatedEvent;
    'vds-hls-audio-tracks-updated': HlsAudioTracksUpdatedEvent;
    'vds-hls-audio-track-switching': HlsAudioTrackSwitchingEvent;
    'vds-hls-audio-track-switched': HlsAudioTrackSwitchedEvent;
    'vds-hls-audio-track-loading': HlsAudioTrackLoadingEvent;
    'vds-hls-audio-track-loaded': HlsAudioTrackLoadedEvent;
    'vds-hls-subtitle-tracks-updated': HlsSubtitleTracksUpdatedEvent;
    'vds-hls-subtitle-tracks-cleared': HlsSubtitleTracksClearedEvent;
    'vds-hls-subtitle-track-switch': HlsSubtitleTrackSwitchEvent;
    'vds-hls-subtitle-track-loading': HlsSubtitleTrackLoadingEvent;
    'vds-hls-subtitle-track-loaded': HlsSubtitleTrackLoadedEvent;
    'vds-hls-subtitle-frag-processed': HlsSubtitleFragProcessedEvent;
    'vds-hls-cues-parsed': HlsCuesParsedEvent;
    'vds-hls-non-native-text-tracks-found': HlsNonNativeTextTracksFoundEvent;
    'vds-hls-init-pts-found': HlsInitPtsFoundEvent;
    'vds-hls-frag-loading': HlsFragLoadingEvent;
    'vds-hls-frag-load-emergency-aborted': HlsFragLoadEmergencyAbortedEvent;
    'vds-hls-frag-loaded': HlsFragLoadedEvent;
    'vds-hls-frag-decrypted': HlsFragDecryptedEvent;
    'vds-hls-frag-parsing-init-segment': HlsFragParsingInitSegmentEvent;
    'vds-hls-frag-parsing-userdata': HlsFragParsingUserdataEvent;
    'vds-hls-frag-parsing-metadata': HlsFragParsingMetadataEvent;
    'vds-hls-frag-parsed': HlsFragParsedEvent;
    'vds-hls-frag-buffered-data': HlsFragBufferedDataEvent;
    'vds-hls-frag-changed': HlsFragChangedEvent;
    'vds-hls-fps-drop': HlsFpsDropEvent;
    'vds-hls-fps-drop-level-capping': HlsFpsDropLevelCappingEvent;
    'vds-hls-error': HlsErrorEvent;
    'vds-hls-destroying': HlsDestroyingEvent;
    'vds-hls-key-loading': HlsKeyLoadingEvent;
    'vds-hls-key-loaded': HlsKeyLoadedEvent;
    'vds-hls-back-buffer-reached': HlsBackBufferReachedEvent;
};

/**
 * Fired when a FPS drop is identified.
 *
 * @event
 */
export declare type HlsFpsDropEvent = VdsHlsEvent<FPSDropData>;

/**
 * Fired when FPS drop triggers auto level capping.
 *
 * @event
 */
export declare type HlsFpsDropLevelCappingEvent = VdsHlsEvent<FPSDropLevelCappingData>;

/**
 * Fired when fragment remuxed MP4 boxes have all been appended into `SourceBuffer`.
 *
 * @event
 */
export declare type HlsFragBufferedDataEvent = VdsHlsEvent<FragBufferedData>;

/**
 * Fired when fragment matching with current media position is changing.
 *
 * @event
 */
export declare type HlsFragChangedEvent = VdsHlsEvent<FragChangedData>;

/**
 * Fired when a fragment has finished decrypting.
 *
 * @event
 */
export declare type HlsFragDecryptedEvent = VdsHlsEvent<FragDecryptedData>;

/**
 * Fired when fragment loading is completed.
 *
 * @event
 */
export declare type HlsFragLoadedEvent = VdsHlsEvent<FragLoadedData>;

/**
 * Fired when fragment loading is aborted for emergency switch down.
 *
 * @event
 */
export declare type HlsFragLoadEmergencyAbortedEvent = VdsHlsEvent<FragLoadEmergencyAbortedData>;

/**
 * Fired when loading a fragment starts.
 *
 * @event
 */
export declare type HlsFragLoadingEvent = VdsHlsEvent<FragLoadingData>;

/**
 * Fired when fragment parsing is completed.
 *
 * @event
 */
export declare type HlsFragParsedEvent = VdsHlsEvent<FragParsedData>;

/**
 * Fired when `InitSegment` has been extracted from a fragment.
 *
 * @event
 */
export declare type HlsFragParsingInitSegmentEvent = VdsHlsEvent<FragParsingInitSegmentData>;

/**
 * Fired when parsing id3 is completed.
 *
 * @event
 */
export declare type HlsFragParsingMetadataEvent = VdsHlsEvent<FragParsingMetadataData>;

/**
 * Fired when parsing sei text is completed.
 *
 * @event
 */
export declare type HlsFragParsingUserdataEvent = VdsHlsEvent<FragParsingUserdataData>;

/**
 * Fired when the first timestamp is found.
 *
 * @event
 */
export declare type HlsInitPtsFoundEvent = VdsHlsEvent<InitPTSFoundData>;

/**
 * Fired when the `hls.js` instance is built. This will not fire if the browser does not
 * support `hls.js`.
 *
 * @event
 */
export declare type HlsInstanceEvent = VdsHlsEvent<Hls>;

/**
 * Fired when a decrypt key has been loaded.
 *
 * @event
 */
export declare type HlsKeyLoadedEvent = VdsHlsEvent<KeyLoadedData>;

/**
 * Fired when a decrypt key loading starts.
 *
 * @event
 */
export declare type HlsKeyLoadingEvent = VdsHlsEvent<KeyLoadingData>;

/**
 * Fired when a level playlist loading finishes.
 *
 * @event
 */
export declare type HlsLevelLoadedEvent = VdsHlsEvent<LevelLoadedData>;

/**
 * Fired when a level playlist loading starts.
 *
 * @event
 */
export declare type HlsLevelLoadingEvent = VdsHlsEvent<LevelLoadingData>;

/**
 * Fired when a level's PTS information has been updated after parsing a fragment.
 *
 * @event
 */
export declare type HlsLevelPtsUpdatedEvent = VdsHlsEvent<LevelPTSUpdatedData>;

/**
 * Fired when a level is removed after calling `removeLevel()`.
 *
 * @event
 */
export declare type HlsLevelsUpdatedEvent = VdsHlsEvent<LevelsUpdatedData>;

/**
 * Fired when a level switch is effective.
 *
 * @event
 */
export declare type HlsLevelSwitchedEvent = VdsHlsEvent<LevelSwitchedData>;

/**
 * Fired when a level switch is requested.
 *
 * @event
 */
export declare type HlsLevelSwitchingEvent = VdsHlsEvent<LevelSwitchingData>;

/**
 * Fired when a level's details have been updated based on previous details, after it has been
 * loaded.
 *
 * @event
 */
export declare type HlsLevelUpdatedEvent = VdsHlsEvent<LevelUpdatedData>;

/**
 * Fired when the `hls.js` library has been loaded.
 *
 * @event
 */
export declare type HlsLibLoadedEvent = VdsHlsEvent<typeof Hls>;

/**
 * Fired when the `hls.js` library fails during the download process.
 *
 * @event
 */
export declare type HlsLibLoadErrorEvent = VdsHlsEvent<Error>;

/**
 * Fired when the browser begins downloading the `hls.js` library.
 *
 * @event
 */
export declare type HlsLibLoadStartEvent = VdsHlsEvent<void>;

/**
 * Fired after the manifest has been loaded.
 *
 * @event
 */
export declare type HlsManifestLoadedEvent = VdsHlsEvent<ManifestLoadedData>;

/**
 * Fired to signal that manifest loading is starting.
 *
 * @event
 */
export declare type HlsManifestLoadingEvent = VdsHlsEvent<ManifestLoadingData>;

/**
 * Fired after manifest has been parsed.
 *
 * @event
 */
export declare type HlsManifestParsedEvent = VdsHlsEvent<ManifestParsedData>;

/**
 * Fired when `MediaSource` has been successfully attached to the media element.
 *
 * @event
 */
export declare type HlsMediaAttachedEvent = VdsHlsEvent<MediaAttachedData>;

/**
 * Fired before `MediaSource` begins attaching to the media element.
 *
 * @event
 */
export declare type HlsMediaAttachingEvent = VdsHlsEvent<MediaAttachingData>;

/**
 * Fired when `MediaSource` has been detached from media element.
 *
 * @event
 */
export declare type HlsMediaDetachedEvent = VdsHlsEvent<void>;

/**
 * Fired before detaching `MediaSource` from the media element.
 *
 * @event
 */
export declare type HlsMediaDetachingEvent = VdsHlsEvent<void>;

/**
 * Fired when a text track to be managed externally is found.
 *
 * @event
 */
export declare type HlsNonNativeTextTracksFoundEvent = VdsHlsEvent<NonNativeTextTracksData>;

/**
 * Fired when a subtitle fragment has been processed.
 *
 * @event
 */
export declare type HlsSubtitleFragProcessedEvent = VdsHlsEvent<SubtitleFragProcessedData>;

/**
 * Fired when loading a subtitle track finishes.
 *
 * @event
 */
export declare type HlsSubtitleTrackLoadedEvent = VdsHlsEvent<SubtitleTrackLoadedData>;

/**
 * Fired when loading a subtitle track starts.
 *
 * @event
 */
export declare type HlsSubtitleTrackLoadingEvent = VdsHlsEvent<TrackLoadingData>;

/**
 * Fired to notify that subtitle tracks were cleared as a result of stopping the media.
 *
 * @event
 */
export declare type HlsSubtitleTracksClearedEvent = VdsHlsEvent<void>;

/**
 * Fired to notify that the subtitle track list has been updated.
 *
 * @event
 */
export declare type HlsSubtitleTracksUpdatedEvent = VdsHlsEvent<SubtitleTracksUpdatedData>;

/**
 * Fired when a subtitle track switch occurs.
 *
 * @event
 */
export declare type HlsSubtitleTrackSwitchEvent = VdsHlsEvent<SubtitleTrackSwitchData>;

/**
 * Fired when the browser doesn't support HLS natively, _and_ `hls.js` doesn't support
 * this environment either, most likely due to missing Media Extensions or video codecs.
 *
 * @event
 */
export declare type HlsUnsupportedEvent = VdsHlsEvent<void>;

/**
 * This class adapts the underlying media element such as `<audio>` or `<video>` to
 * satisfy the media provider contract, which generally involves providing a consistent API
 * for loading, managing, and tracking media state.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement}
 */
export declare class Html5MediaElement extends MediaProviderElement {
    protected _mediaElement?: HTMLMediaElement;
    get mediaElement(): HTMLMediaElement | undefined;
    disconnectedCallback(): void;
    destroy(): void;
    /**
     * Configures the preload setting of the underlying media element once it can load (see
     * `loading` property). This will overwrite any existing `preload` value on the `<audio>`
     * or `<video>` element.
     *
     * The `preload` attribute provides a hint to the browser about what the author thinks will
     * lead to the best user experience with regards to what content is loaded before the video is
     * played. The recommended default is `metadata`.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-preload}
     * @defaultValue 'metadata'
     */
    preload: 'none' | 'metadata' | 'auto';
    protected _timeRAF?: number;
    protected _cancelTimeUpdates(): void;
    protected _requestTimeUpdates(): void;
    protected _requestTimeUpdate(): void;
    protected _updateCurrentTime(newTime: number, triggerEvent?: Event): void;
    protected _hasMediaElementConnected: boolean;
    protected _mediaElementDisposal: DisposalBin;
    handleDefaultSlotChange(): void;
    protected get _canMediaElementConnect(): boolean;
    protected _findSlottedMediaElement(): void;
    protected _handleMediaElementConnect(): void;
    protected _handleMediaElementDisconnect(): void;
    startLoadingMedia(): void;
    protected _startPreloadingMedia(): void;
    protected _observePlaysinline(): void;
    protected _handlePlaysinlineChange(playsinline: boolean): void;
    protected _observeMediaSources(): void;
    protected _handleSrcChange(sources: string[]): void;
    protected _getMediaSources(): string[];
    protected _getMediaMetadata(): {
        src: string[];
        currentSrc: string;
        duration: number;
        poster: string;
        mediaType: MediaType;
        viewType: ViewType;
    };
    protected _isMediaWaiting: boolean;
    protected _attachMediaEventListeners(): void;
    protected _ignoreNextAbortEvent: boolean;
    protected _handleAbort(event?: Event): void;
    protected _handleCanPlay(event: Event): void;
    protected _handleCanPlayThrough(event: Event): void;
    protected _handleLoadStart(event: Event): void;
    protected _ignoreNextEmptiedEvent: boolean;
    protected _handleEmptied(event: Event): void;
    protected _handleLoadedData(event: Event): void;
    protected _handleLoadedMetadata(event: Event): void;
    protected _determineMediaType(event: Event): void;
    protected _handlePlay(event: Event): void;
    protected _handlePause(event: Event): void;
    protected _handlePlaying(event: Event): void;
    protected _handleDurationChange(event: Event): void;
    protected _handleProgress(event: Event): void;
    protected _handleRateChange(event: Event): void;
    protected _handleSeeking(event: Event): void;
    protected _handleSeeked(event: Event): void;
    protected _handleStalled(event: Event): void;
    protected _handleVolumeChange(event: Event): void;
    protected _handleWaiting(event: Event): void;
    protected _handleSuspend(event: Event): void;
    protected _handleEnded(event: Event): void;
    protected _handleLoop(): void;
    protected _handleError(event: Event): void;
    protected _getPaused(): boolean;
    protected _getVolume(): number;
    protected _setVolume(newVolume: number): void;
    protected _getCurrentTime(): number;
    protected _setCurrentTime(newTime: number): void;
    protected _getMuted(): boolean;
    protected _setMuted(isMuted: boolean): void;
    play(): Promise<void | undefined>;
    pause(): Promise<void | undefined>;
    protected _getMediaType(): MediaType;
}

export { isHlsjsSupported }

/**
 * Internal event that is fired by a media provider when requesting media playback to restart after
 * reaching the end. This event also helps notify the media controller that media will be looping.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type LoopRequestEvent = VdsEvent<void>;

export declare const MEDIA_STORE_DEFAULTS: MediaContext;

/**
 * Fired when the resource was not fully loaded, but not as the result of an error.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/abort_event}
 */
export declare type MediaAbortEvent = VdsMediaEvent<void>;

/**
 * Fired when the `autoplay` property has changed value.
 *
 * @event
 */
export declare type MediaAutoplayChangeEvent = VdsMediaEvent<boolean>;

/**
 * Fired when an autoplay attempt has successfully been made (ie: media playback has automatically
 * started). The event detail whether media is `muted` before any attempts are made.
 *
 * @event
 */
export declare type MediaAutoplayEvent = VdsMediaEvent<{
    muted: boolean;
}>;

/**
 * Fired when an autoplay attempt has failed. The event detail contains the error that
 * had occurred on the last autoplay attempt which caused it to fail.
 *
 * @event
 */
export declare type MediaAutoplayFailEvent = VdsMediaEvent<{
    muted: boolean;
    error: Error;
}>;

/**
 * Fired when the provider can begin loading media. This depends on the type of `loading`
 * that has been configured. The `eager` strategy will be immediate, and `lazy` once the provider
 * has entered the viewport.
 */
export declare type MediaCanLoadEvent = VdsMediaEvent<void>;

/**
 * Fired when the user agent can play the media, but estimates that **not enough** data has been
 * loaded to play the media up to its end without having to stop for further buffering of content.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canplay_event}
 */
export declare type MediaCanPlayEvent = VdsMediaEvent<{
    duration: number;
}>;

/**
 * Fired when the user agent can play the media, and estimates that **enough** data has been
 * loaded to play the media up to its end without having to stop for further buffering of content.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canplaythrough_event}
 */
export declare type MediaCanPlayThroughEvent = VdsMediaEvent<{
    duration: number;
}>;

/**
 * Fired when `<vds-media>` connects to the DOM.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type MediaConnectEvent = DiscoveryEvent<MediaElement>;

export declare type MediaContext = {
    /**
     * Whether playback should automatically begin as soon as enough media is available to do so
     * without interruption.
     *
     * Sites which automatically play audio (or videos with an audio track) can be an unpleasant
     * experience for users, so it should be avoided when possible. If you must offer autoplay
     * functionality, you should make it opt-in (requiring a user to specifically enable it).
     *
     * However, autoplay can be useful when creating media elements whose source will be set at a
     * later time, under user control.
     *
     * @defaultValue false
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/autoplay}
     */
    autoplay: boolean;
    /**
     * Set to an error when autoplay has failed to begin playback. This can be used to determine
     * when to show a recovery UI in the event autoplay fails.
     *
     * @defaultValue undefined
     */
    autoplayError: {
        muted: boolean;
        error: Error;
    } | undefined;
    /**
     * Returns a `TimeRanges` object that indicates the ranges of the media source that the
     * browser has buffered (if any) at the moment the buffered property is accessed. This is usually
     * contiguous but if the user jumps about while media is buffering, it may contain holes.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges}
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered}
     * @defaultValue TimeRanges
     */
    buffered: TimeRanges;
    /**
     * A `double` indicating the total playback length of the media in seconds. If no media data is
     * available, the returned value is `0`. If the media is of indefinite length (such as
     * streamed live media, a WebRTC call's media, or similar), the value is `+Infinity`.
     *
     * @defaultValue 0
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/duration}
     */
    duration: number;
    /**
     * Converts the `buffered` time ranges into an absolute value to indicate the amount of
     * media that has buffered from `0` to `duration`.
     *
     * @defaultValue 0
     */
    bufferedAmount: number;
    /**
     * Whether media is allowed to begin loading. This depends on the `loading` configuration.
     * If `eager`, `canLoad` will be `true` immediately, and if `lazy` this will become `true`
     * once the media has entered the viewport.
     */
    canLoad: boolean;
    /**
     * Whether the user agent can play the media, but estimates that **not enough** data has been
     * loaded to play the media up to its end without having to stop for further buffering of
     * content.
     *
     * @defaultValue false
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canplay_event}
     */
    canPlay: boolean;
    /**
     * Whether the native browser fullscreen API is available, or the current provider can
     * toggle fullscreen mode. This does not mean that the operation is guaranteed to be successful,
     * only that it can be attempted.
     *
     * @defaultValue false
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API}
     */
    canFullscreen: boolean;
    /**
     * Indicates whether a user interface should be shown for controlling the resource. Set this to
     * `false` when you want to provide your own custom controls, and `true` if you want the current
     * provider to supply its own default controls. Depending on the provider, changing this prop
     * may cause the player to completely reset.
     *
     * @defaultValue false
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/controls}
     */
    controls: boolean;
    /**
     * The URL of the current poster. Defaults to `''` if no media/poster has been given or
     * loaded.
     *
     * @defaultValue ''
     */
    poster: string;
    /**
     * The absolute URL of the chosen media resource. Defaults to `''` if no media has been loaded.
     *
     * @defaultValue ''
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/currentSrc}
     */
    currentSrc: string;
    /**
     * A `double` indicating the current playback time in seconds. Defaults to `0` if the media has
     * not started to play and has not seeked. Setting this value seeks the media to the new
     * time. The value can be set to a minimum of `0` and maximum of the total length of the
     * media (indicated by the duration prop).
     *
     * @defaultValue 0
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/currentTime}
     */
    currentTime: number;
    /**
     * Whether media playback has reached the end. In other words it'll be true
     * if `currentTime === duration`.
     *
     * @defaultValue false
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/ended}
     */
    ended: boolean;
    /**
     * Contains the most recent media error or undefined if there's been none. You can listen for
     * `vds-error` event updates and examine this object to debug further.
     *
     * @defaultValue undefined
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/error}
     */
    error: MediaErrorDetail | undefined;
    /**
     * Whether the player is currently in fullscreen mode.
     *
     * @defaultValue false
     */
    fullscreen: boolean;
    /**
     * Whether the user is idle. This will occur when media playback is progressing (playing)
     * without any detected user activity for a set period of time (default is 2.5s). This means as
     * long as media is paused, `userIdle` will be `false`.
     *
     * @defaultValue false
     */
    userIdle: boolean;
    /**
     * Whether media should automatically start playing from the beginning (replay) every time
     * it ends.
     *
     * @defaultValue false
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loop}
     */
    loop: boolean;
    /**
     * The type of media that is currently active, whether it's audio or video. Defaults
     * to `unknown` when no media has been loaded or the type cannot be determined.
     *
     * @defaultValue MediaType.Unknown
     */
    mediaType: MediaType;
    /**
     * Whether the audio is muted or not.
     *
     * @defaultValue false
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/muted}
     */
    muted: boolean;
    /**
     * Whether playback should be paused. Defaults to `true` if no media has loaded or playback has
     * not started. Setting this to `false` will begin/resume playback.
     *
     * @defaultValue true
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/paused}
     */
    paused: boolean;
    /**
     * Contains the ranges of the media source that the browser has played, if any.
     *
     * @defaultValue TimeRanges
     */
    played: TimeRanges;
    /**
     * Whether media is actively playing back. Defaults to `false` if no media has
     * loaded or playback has not started.
     *
     * @defaultValue false
     */
    playing: boolean;
    /**
     * Whether the video is to be played "inline", that is within the element's playback area. Note
     * that setting this to `false` does not imply that the video will always be played in fullscreen.
     * Depending on the provider, changing this prop may cause the player to completely reset.
     *
     * @defaultValue false
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-playsinline}
     */
    playsinline: boolean;
    /**
     * Contains the time ranges that the user is able to seek to, if any. This tells us which parts
     * of the media can be played without delay; this is irrespective of whether that part has
     * been downloaded or not.
     *
     * Some parts of the media may be seekable but not buffered if byte-range
     * requests are enabled on the server. Byte range requests allow parts of the media file to
     * be delivered from the server and so can be ready to play almost immediately â€” thus they are
     * seekable.
     *
     * @defaultValue TimeRanges
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges}
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/seekable}
     */
    seekable: TimeRanges;
    /**
     * Converts the `seekable` time ranges into an absolute value to indicate the amount of
     * media that is seekable from `0` to `duration`.
     *
     * @defaultValue 0
     */
    seekableAmount: number;
    /**
     * Whether media is actively seeking to an new playback position.
     *
     * @defaultValue false
     */
    seeking: boolean;
    /**
     * The URL of the current media resource/s to be considered for playback. Use `currentSrc` to
     * get the currently loaded resource.
     *
     * @defaultValue []
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/src}
     */
    src: string[];
    /**
     * Whether media playback has started. In other words it will be true if `currentTime > 0`.
     *
     * @defaultValue false
     */
    started: boolean;
    /**
     * The type of player view that is being used, whether it's an audio player view or
     * video player view. Normally if the media type is of audio then the view is of type audio, but
     * in some cases it might be desirable to show a different view type. For example, when playing
     * audio with a poster. This is subject to the provider allowing it. Defaults to `unknown`
     * when no media has been loaded.
     *
     * @defaultValue ViewType.Unknown
     */
    viewType: ViewType;
    /**
     * An `int` between `0` (silent) and `1` (loudest) indicating the audio volume. Defaults to `1`.
     *
     * @defaultValue 1
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/volume}
     */
    volume: number;
    /**
     * Whether playback has temporarily stopped because of a lack of temporary data.
     *
     * @defaultValue false
     */
    waiting: boolean;
};

/**
 * The media controller acts as a message bus between the media provider and all other
 * components, such as UI components and plugins. The controller's main responsibilities are:
 *
 * - Providing the media store context down to all child consumers (i.e., UI elements) so they can
 * subscribe to media state changes.
 *
 * - Listening for media request events so it can try and satisfy them (e.g., accepting a play
 * request and satisfying it by calling play on the media provider).
 *
 * - Listening to media events and updating state in the media store.
 */
export declare class MediaController {
    protected readonly _host: MediaControllerHost;
    protected readonly _disconnectDisposal: DisposalBin;
    /**
     * Queue actions to be invoked after the provider has connected to the media controller.
     */
    readonly providerQueue: RequestQueue;
    /**
     * Queue actions to be invoked after the provider has detached from the media controller.
     */
    readonly providerDisposal: DisposalBin;
    constructor(_host: MediaControllerHost);
    protected readonly _logController: LogController | undefined;
    protected readonly _logger: LogDispatcher | undefined;
    get logLevel(): LogLevel;
    set logLevel(level: LogLevel);
    protected _provider: MediaProviderElement | undefined;
    protected readonly _providerContext: ContextProviderController<WritableStore<MediaProviderElement | undefined>>;
    /**
     * The media provider that is attached this media controller.
     */
    get provider(): MediaProviderElement | undefined;
    /**
     * Attach a media provider to this media controller.
     */
    attachMediaProvider(provider: MediaProviderElement, onDisconnect: DisconnectCallback): void;
    protected _handleMediaProviderDisconnect(): void;
    protected _flushMediaProviderConnectedQueue(): void;
    private readonly _mediaStoreProvider;
    get store(): ReadableMediaStoreRecord;
    /* Excluded from this release type: _store */
    readonly state: {
        autoplay: boolean;
        autoplayError: {
            muted: boolean;
            error: Error;
        } | undefined;
        buffered: TimeRanges;
        duration: number;
        bufferedAmount: number;
        canLoad: boolean;
        canPlay: boolean;
        canFullscreen: boolean;
        controls: boolean;
        poster: string;
        currentSrc: string;
        currentTime: number;
        ended: boolean;
        error: MediaErrorDetail | undefined;
        fullscreen: boolean;
        userIdle: boolean;
        loop: boolean;
        mediaType: MediaType;
        muted: boolean;
        paused: boolean;
        played: TimeRanges;
        playing: boolean;
        playsinline: boolean;
        seekable: TimeRanges;
        seekableAmount: number;
        seeking: boolean;
        src: string[];
        started: boolean;
        viewType: ViewType;
        volume: number;
        waiting: boolean;
    };
    protected _userIdleController: UserIdleController;
    get idleDelay(): number;
    set idleDelay(delay: number);
    protected _handleIdleChange: void;
    /**
     * Media requests that have been made but are waiting to be satisfied. Key represents the media
     * event type the request is waiting for to be considered "satisfied".
     */
    protected _pendingMediaRequests: PendingMediaRequests;
    protected _clearPendingMediaRequests(): void;
    protected _satisfyMediaRequest<T extends keyof PendingMediaRequests>(type: T, event: VdsMediaEvent<unknown>): void;
    /**
     * Override this to allow media events to bubble up the DOM.
     */
    protected _mediaRequestEventGateway(event: Event): boolean;
    protected _createMediaRequestHandler<E extends Event>(queueKey: string, callback: (event: E) => void | Promise<void>): (event: E) => void;
    protected _handleStartLoadingRequest: void;
    protected _handleMuteRequest: void;
    protected readonly _handleUnmuteRequest: void;
    protected readonly _handlePlayRequest: void;
    protected readonly _handlePauseRequest: void;
    protected _isSeekingRequestPending: boolean;
    protected readonly _handleSeekingRequest: void;
    protected readonly _handleSeekRequest: void;
    protected readonly _handleVolumeChangeRequest: void;
    protected readonly _handleEnterFullscreenRequest: void;
    protected readonly _handleExitFullscreenRequest: void;
    protected readonly _handleResumeIdlingRequest: void;
    protected readonly _handlePauseIdlingRequest: void;
    protected readonly _handleShowPosterRequest: void;
    protected readonly _handleHidePosterRequest: void;
    protected readonly _handleLoopRequest: (event: Event) => void;
    protected readonly _handleFullscreenChange: void;
    protected readonly _handleFullscreenError: void;
    protected _isReplay: boolean;
    protected _isLooping: boolean;
    protected _firingWaiting: boolean;
    protected _originalWaitingEvent?: Event;
    protected _mediaEvents: Event[];
    protected _attachMediaEventListeners(): void;
    protected _clearMediaStateTracking(): void;
    protected _findLastMediaEvent(eventType: keyof HTMLElementEventMap): Event;
    protected _handleCanLoad(event: MediaCanPlayEvent): void;
    protected _updateMetadata(metadata: MediaMetadataEventDetail): void;
    protected _handleLoadStart(event: MediaLoadStartEvent): void;
    protected _handleLoadedData(event: MediaLoadedDataEvent): void;
    protected _handleLoadedMetadata(event: MediaLoadedMetadataEvent): void;
    protected _handleCanPlay(event: MediaCanPlayEvent): void;
    protected _handleCanPlayThrough(event: MediaCanPlayThroughEvent): void;
    protected _handleAutoplay(event: MediaAutoplayEvent): void;
    protected _handleAutoplayFail(event: MediaAutoplayFailEvent): void;
    protected _handlePlay(event: MediaPlayEvent): void;
    protected _handlePlayFail(event: MediaPlayEvent): void;
    protected _handlePlaying(event: MediaPlayingEvent): void;
    protected _handlePause(event: MediaPauseEvent): void;
    protected _handleTimeUpdate(event: MediaTimeUpdateEvent): void;
    protected _handleVolumeChange(event: MediaVolumeChangeEvent): void;
    protected readonly _handleSeeking: ((event: MediaSeekingEvent) => void) & {
        cancel: () => void;
        flush: () => void;
    };
    protected _handleSeeked(event: MediaSeekedEvent): void;
    protected _stopWaiting(): void;
    protected readonly _fireWaiting: (() => void) & {
        cancel: () => void;
        flush: () => void;
    };
    protected _handleWaiting(event: MediaWaitingEvent): void;
    protected _handleEnded(event: MediaEndedEvent): void;
    protected _handleAutoplayChange(event: MediaAutoplayChangeEvent): void;
    protected _skipInitialSrcChange: boolean;
    protected _handleCurrentSrcChange(event: MediaCurrentSrcChangeEvent): void;
    protected _handleError(event: MediaErrorEvent): void;
    protected _handleFullscreenSupportChange(event: FullscreenSupportChange): void;
    protected _handlePosterChange(event: MediaPosterChangeEvent): void;
    protected _handleLoopChange(event: MediaLoopChangeEvent): void;
    protected _handlePlaysinlineChange(event: MediaPlaysinlineChangeEvent): void;
    protected _handleControlsChange(event: MediaControlsChangeEvent): void;
    protected _handleMediaTypeChange(event: MediaTypeChangeEvent): void;
    protected _handleDurationChange(event: MediaDurationChangeEvent): void;
    protected _handleProgress(event: MediaProgressEvent): void;
    protected _handleSrcChange(event: MediaSrcChangeEvent): void;
    protected _handleViewTypeChange(event: MediaViewTypeChangeEvent): void;
}

/**
 * All media events that are dispatched up to a media controller.
 */
export declare type MediaControllerEvents = MediaEvents & MediaRequestEvents;

export declare type MediaControllerHost = ReactiveElement & {
    readonly canFullscreen: boolean;
    enterFullscreen?(): Promise<void>;
    exitFullscreen?(): Promise<void>;
};

/**
 * Fired when the `controls` property has changed value.
 *
 * @event
 */
export declare type MediaControlsChangeEvent = VdsMediaEvent<boolean>;

/**
 * Fired when the `currentSrc` property has changed value.
 *
 * @event
 */
export declare type MediaCurrentSrcChangeEvent = VdsMediaEvent<string>;

/**
 * Fired when the media provider element is manually destroyed by calling the `destroy()` method.
 *
 * @event
 */
export declare type MediaDestroyEvent = VdsMediaEvent<void>;

export declare const mediaDiscoveryId: unique symbol;

/**
 * Fired when the `duration` property changes.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/durationchange_event}
 */
export declare type MediaDurationChangeEvent = VdsMediaEvent<number>;

/**
 * All media elements exist inside the `<vds-media>` component. It's main jobs are to host the
 * media controller, and expose media state through HTML attributes and CSS properties for styling
 * purposes.
 *
 * @tagname vds-media
 * @slot - Used to pass in components that use/manage/provide media state.
 * @events ./request.events.ts
 * @example
 * ```html
 * <vds-media>
 *   <vds-video>
 *     <video src="..." />
 *   </vds-video>
 *
 *   <!-- Other components that use/manage media state here. -->
 * </vds-media>
 * ```
 */
export declare class MediaElement extends LitElement {
    static get styles(): CSSResultGroup;
    /**
     * The media controller which is responsible for updating the media store and satisfying media
     * requests.
     */
    readonly controller: MediaController;
    protected __mediaFullscreen: boolean;
    protected __mediaIsVideoView: boolean;
    protected __mediaPlaysinline: boolean;
    /**
     * The media provider element (e.g., `vds-video`) that is attached to the controller.
     */
    get provider(): MediaProviderElement | undefined;
    constructor();
    protected update(changedProperties: PropertyValues): void;
    protected render(): TemplateResult;
    /**
     * Controls the screen orientation of the current browser window.
     */
    readonly screenOrientationController: ScreenOrientationController;
    /**
     * Controls the fullscreen state of the current element.
     */
    readonly fullscreenController: FullscreenController;
    /**
     * Whether the native browser fullscreen API is available. This does not mean that the
     * operation is guaranteed to be successful, only that it can be attempted.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API}
     */
    get canFullscreen(): boolean;
    /**
     * Whether the media element is currently in fullscreen mode.
     */
    get fullscreen(): boolean;
    /**
     * This will indicate the orientation to lock the screen to when in fullscreen mode and
     * the Screen Orientation API is available. The default is `undefined` which indicates
     * no screen orientation change.
     *
     * @defaultValue undefined
     */
    get fullscreenOrientation(): ScreenOrientationLock | undefined;
    set fullscreenOrientation(lockType: ScreenOrientationLock | undefined);
    /**
     * Attempts to display the element in fullscreen. The promise will resolve if successful, and
     * reject if not.
     */
    enterFullscreen(): Promise<void>;
    /**
     * Attempts to display the element inline by exiting fullscreen.
     */
    exitFullscreen(): Promise<void>;
    protected _bindMediaAttributes(): void;
    protected _bindMediaCSSProperties(): void;
    protected _shouldHideMediaUI(): boolean;
}

/**
 * Fired when the media has become empty.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/emptied_event}
 */
export declare type MediaEmptiedEvent = VdsMediaEvent<void>;

/**
 * Fired when playback or streaming has stopped because the end of the media was reached or
 * because no further data is available. This is not fired if playback will start from the
 * beginning again due to the `loop` property being `true` (see `MediaReplayEvent`
 * and `MediaEndEvent`).
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/ended_event}
 */
export declare type MediaEndedEvent = VdsMediaEvent<void>;

/**
 * Fired each time media playback has reached the end. This is fired even if the
 * `loop` property is `true`, which is generally when you'd reach for this event over the
 * `MediaEndedEvent` if you want to be notified of media looping.
 *
 * @event
 */
export declare type MediaEndEvent = VdsMediaEvent<void>;

/**
 * A number which represents the general type of error that occurred.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaError
 * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaError/code
 */
export declare enum MediaErrorCode {
    /**
     * The fetching of the associated resource was aborted by the user's request.
     */
    Aborted = 1,
    /**
     * Some kind of network error occurred which prevented the media from being successfully
     * fetched, despite having previously been available.
     */
    Network = 2,
    /**
     * Despite having previously been determined to be usable, an error occurred while trying to
     * decode the media resource, resulting in an error.
     */
    Decode = 3,
    /**
     * The associated resource or media provider object (such as a `MediaStream`) has been found to
     * be unsuitable.
     */
    SrcNotSupported = 4
}

export declare type MediaErrorDetail = {
    message: string;
    code: MediaErrorCode;
    mediaError?: MediaError;
};

/**
 * Fired when media loading or playback has encountered any issues (for example, a network
 * connectivity problem). The event detail contains a potential message containing more
 * information about the error (empty string if nothing available), and a code that identifies
 * the general type of error that occurred.
 *
 * @event
 * @see {@link https://html.spec.whatwg.org/multipage/media.html#error-codes}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/error_event}
 */
export declare type MediaErrorEvent = VdsMediaEvent<MediaErrorDetail>;

/**
 * Simplifies attaching event listeners to a media provider below in the DOM. This is required
 * because media events don't bubble by default.
 *
 * @example
 * ```ts
 * import { LitElement } from 'lit';
 * import { mediaEventListener } from '@vidstack/player';
 *
 * class MyElement extends LitElement {
 *   _handlePlay = mediaEventListener(this, 'vds-play', (event) => {
 *     // ...
 *   })
 * }
 * ```
 */
export declare function mediaEventListener<MediaEvent extends keyof MediaControllerEvents>(host: ReactiveControllerHost & HTMLElement, eventType: MediaEvent, listener: (event: MediaControllerEvents[MediaEvent]) => void): void;

export declare type MediaEvents = {
    'vds-abort': MediaAbortEvent;
    'vds-autoplay-change': MediaAutoplayChangeEvent;
    'vds-autoplay-fail': MediaAutoplayFailEvent;
    'vds-autoplay': MediaAutoplayEvent;
    'vds-can-load': MediaCanLoadEvent;
    'vds-can-play-through': MediaCanPlayThroughEvent;
    'vds-can-play': MediaCanPlayEvent;
    'vds-controls-change': MediaControlsChangeEvent;
    'vds-current-src-change': MediaCurrentSrcChangeEvent;
    'vds-destroy': MediaDestroyEvent;
    'vds-duration-change': MediaDurationChangeEvent;
    'vds-emptied': MediaEmptiedEvent;
    'vds-end': MediaEndEvent;
    'vds-ended': MediaEndedEvent;
    'vds-error': MediaErrorEvent;
    'vds-fullscreen-change': FullscreenChangeEvent;
    'vds-fullscreen-error': FullscreenErrorEvent;
    'vds-fullscreen-support-change': FullscreenSupportChange;
    'vds-user-idle-change': UserIdleChangeEvent;
    'vds-load-start': MediaLoadStartEvent;
    'vds-loaded-data': MediaLoadedDataEvent;
    'vds-loaded-metadata': MediaLoadedMetadataEvent;
    'vds-loop-change': MediaLoopChangeEvent;
    'vds-media-type-change': MediaTypeChangeEvent;
    'vds-pause': MediaPauseEvent;
    'vds-play-fail': MediaPlayFailEvent;
    'vds-play': MediaPlayEvent;
    'vds-playing': MediaPlayingEvent;
    'vds-playsinline-change': MediaPlaysinlineChangeEvent;
    'vds-poster-change': MediaPosterChangeEvent;
    'vds-progress': MediaProgressEvent;
    'vds-replay': MediaReplayEvent;
    'vds-seeked': MediaSeekedEvent;
    'vds-seeking': MediaSeekingEvent;
    'vds-src-change': MediaSrcChangeEvent;
    'vds-stalled': MediaStalledEvent;
    'vds-started': MediaStartedEvent;
    'vds-suspend': MediaSuspendEvent;
    'vds-screen-orientation-change': ScreenOrientationChangeEvent;
    'vds-screen-orientation-lock-change': ScreenOrientationLockChangeEvent;
    'vds-time-update': MediaTimeUpdateEvent;
    'vds-view-type-change': MediaViewTypeChangeEvent;
    'vds-volume-change': MediaVolumeChangeEvent;
    'vds-waiting': MediaWaitingEvent;
};

/**
 * Whether to request fullscreen on the media (i.e., `<vds-media>`) or provider element
 * (e.g., `<vds-video>`).
 *
 * @defaultValue 'media'
 */
export declare type MediaFullscreenRequestTarget = 'media' | 'provider';

/**
 * Fired when the frame at the current playback position of the media has finished loading; often
 * the first frame.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadeddata_event}
 */
export declare type MediaLoadedDataEvent = VdsMediaEvent<void>;

/**
 * Fired when the metadata has been loaded.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadedmetadata_event}
 */
export declare type MediaLoadedMetadataEvent = VdsMediaEvent<MediaMetadataEventDetail>;

/**
 * Fired when the browser has started to load a resource.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadstart_event}
 */
export declare type MediaLoadStartEvent = VdsMediaEvent<MediaMetadataEventDetail>;

/**
 * Fired when the `loop` property has changed value.
 *
 * @event
 */
export declare type MediaLoopChangeEvent = VdsMediaEvent<boolean>;

export declare type MediaMetadataEventDetail = {
    src: string[];
    currentSrc: string;
    duration: number;
    poster: string;
    mediaType: MediaType;
    viewType: ViewType;
};

/**
 * Fired when a request to `pause` an activity is handled and the activity has entered its
 * `paused` state, most commonly after the media has been paused through a call to the
 * `pause()` method.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause_event}
 */
export declare type MediaPauseEvent = VdsMediaEvent<void> & {
    requestEvent?: PauseRequestEvent;
};

/**
 * Fired when the `paused` property is changed from `true` to `false`, as a result of the `play()`
 * method, or the `autoplay` attribute.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play_event}
 */
export declare type MediaPlayEvent = VdsMediaEvent<void> & {
    autoplay?: boolean;
    requestEvent?: PlayRequestEvent;
};

/**
 * Fired when an attempt to start media playback results in an error.
 */
export declare type MediaPlayFailEvent = VdsMediaEvent<void> & {
    autoplay?: boolean;
    error?: Error;
    requestEvent?: PlayRequestEvent;
};

/**
 * Fired when playback is ready to start after having been paused or delayed due to lack of data.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/playing_event}
 */
export declare type MediaPlayingEvent = VdsMediaEvent<void>;

/**
 * Fired when the `playsinline` property has changed value.
 *
 * @event
 */
export declare type MediaPlaysinlineChangeEvent = VdsMediaEvent<boolean>;

/**
 * Fired when the `currentPoster` property has changed value.
 *
 * @event
 */
export declare type MediaPosterChangeEvent = VdsMediaEvent<string>;

/**
 * Fired periodically as the browser loads a resource.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/progress_event}
 */
export declare type MediaProgressEvent = VdsMediaEvent<{
    buffered: TimeRanges;
    seekable: TimeRanges;
}>;

/**
 * Fired when the media provider connects to the DOM.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type MediaProviderConnectEvent = DiscoveryEvent<MediaProviderElement>;

export declare const mediaProviderDiscoveryId: unique symbol;

/**
 * This is the base class that all other concrete provider implementations will extend such as the
 * `Html5MediaElement` or `EmbeddedMediaElement`. This class should provide shared functionality
 * and behaviour that is required by all other providers. Anything specific should exist
 * in a higher-level implementation.
 *
 * A media provider employs the adapter design pattern to wrap an existing provider such as
 * the native HTMLMediaElement (i.e., `<video>`), or embedded media (i.e., `<iframe>`), and
 * provide a consistent interface that will enable the media controller to satisfy requests
 * (e.g., satisfy a play request by calling play on the media provider, and confirming the
 * operation was successful or if it failed).
 *
 * A media provider is generally responsible for:
 *
 * - Handling the media loading process and determining the most appropriate time to invoke it.
 * - Providing a minimal and consistent set of properties for the media controller to satisfy media
 *   requests (e.g., `paused` property for controlling playback state).
 * - Providing a consistent events interface by firing `vds-*` specific custom media events (e.g.,
 *   `vds-play`, `vds-playing`, and so on).
 * - Manually invoking autoplay so we can track failure.
 * - Providing a consistent fullscreen API to the underlying media provider element.
 *
 * Note: Properties on this element are considered to be "upgraded" as they're safe to call before
 * media is ready for playback.
 *
 * @events ../events.ts
 * @see {@link https://en.wikipedia.org/wiki/Adapter_pattern}
 */
export declare abstract class MediaProviderElement extends LitElement {
    constructor();
    protected readonly _disconnectDisposal: DisposalBin;
    connectedCallback(): void;
    protected firstUpdated(changedProperties: PropertyValues): void;
    render(): TemplateResult<1>;
    disconnectedCallback(): void;
    abstract handleDefaultSlotChange(): void | Promise<void>;
    protected _updateMediaStoreOnDisconnect(store: WritableMediaStoreRecord): void;
    /**
     * Hard destroy the media provider and clear all state. This voids the media provider unusable,
     * so call with caution.
     */
    destroy(): void;
    protected readonly _logger: LogDispatcher | undefined;
    protected _logMediaEvents(): void;
    /**
     * An `int` between `0` (silent) and `1` (loudest) indicating the audio volume. Defaults to `1`.
     *
     * @defaultValue 1
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/volume}
     */
    get volume(): number;
    set volume(newVolume: number);
    protected abstract _getVolume(): number;
    protected abstract _setVolume(newVolume: number): void;
    /**
     * Whether playback should be paused. Defaults to `true` if no media has loaded or playback has
     * not started. Setting this to `false` will begin/resume playback.
     *
     * @defaultValue true
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/paused}
     */
    get paused(): boolean;
    set paused(newPaused: boolean);
    protected abstract _getPaused(): boolean;
    /**
     * A `double` indicating the current playback time in seconds. Defaults to `0` if the media has
     * not started to play and has not seeked. Setting this value seeks the media to the new
     * time. The value can be set to a minimum of `0` and maximum of the total length of the
     * media indicated by the `duration`.
     *
     * @defaultValue 0
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/currentTime}
     */
    get currentTime(): number;
    set currentTime(newTime: number);
    protected abstract _getCurrentTime(): number;
    protected abstract _setCurrentTime(newTime: number): void;
    /**
     * Whether the audio is muted or not.
     *
     * @defaultValue false
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/muted}
     */
    get muted(): boolean;
    set muted(newMuted: boolean);
    protected abstract _getMuted(): boolean;
    protected abstract _setMuted(isMuted: boolean): void;
    /**
     * A URL for an image to be shown while the video is downloading.
     */
    get poster(): string;
    set poster(newPoster: string);
    /**
     * Whether media should automatically start playing from the beginning (replay) every time
     * it ends.
     *
     * @defaultValue false
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loop}
     */
    get loop(): boolean;
    set loop(newLoop: boolean);
    /**
     * Indicates whether a user interface should be shown for controlling the resource. Set this to
     * `false` when you want to provide your own custom controls, and `true` if you want the current
     * provider to supply its own default controls. Depending on the provider, changing this prop
     * may cause the player to completely reset.
     *
     * @defaultValue false
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/controls}
     */
    get controls(): boolean;
    set controls(newControls: boolean);
    /* Excluded from this release type: canLoadPoster */
    /**
     * Whether media is allowed to begin loading. This depends on the `loading` configuration.
     *
     * - If `eager`, this will return `true` immediately.
     * - If `lazy`, this will return `true` after the media has entered the viewport.
     * - If `custom`, this will return `true` after the `startLoadingMedia()` method is called.
     */
    get canLoad(): boolean;
    /**
     * Indicates when the provider can begin loading media.
     *
     * - `eager`: media will be loaded immediately.
     * - `idle`: media will be loaded after the page has loaded and `requestIdleCallback` is fired.
     * - `visible`: media will delay loading until the provider has entered the viewport.
     * - `custom`: media will wait for the `startLoadingMedia()` method or `vds-start-loading` event.
     *
     * @defaultValue 'visible'
     */
    loading: 'eager' | 'idle' | 'visible' | 'custom';
    /**
     * Called when media can begin loading. Calling this method will trigger the initial provider
     * loading process. Calling it more than once has no effect.
     */
    startLoadingMedia(): void;
    /**
     * Begins/resumes playback of the media. If this method is called programmatically before the
     * user has interacted with the player, the promise may be rejected subject to the browser's
     * autoplay policies.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play}
     */
    abstract play(): Promise<void>;
    /**
     * Pauses playback of the media.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause}
     */
    abstract pause(): Promise<void>;
    /**
     * @throws Will throw if media is not ready for playback.
     */
    protected _throwIfNotReadyForPlayback(): void;
    protected _resetPlaybackIfEnded(): Promise<void>;
    /**
     * @throws Will throw if player is not in a video view.
     */
    protected _throwIfNotVideoView(): void;
    protected _handleMediaReady({ event, duration }: {
        event?: Event;
        duration: number;
    }): Promise<void>;
    protected _handleCurrentSrcChange(currentSrc: string, triggerEvent?: Event): void;
    /**
     * Whether playback should automatically begin as soon as enough media is available to do so
     * without interruption.
     *
     * Sites which automatically play audio (or videos with an audio track) can be an unpleasant
     * experience for users, so it should be avoided when possible. If you must offer autoplay
     * functionality, you should make it opt-in (requiring a user to specifically enable it).
     *
     * However, autoplay can be useful when creating media elements whose source will be set at a
     * later time, under user control.
     *
     * @defaultValue false
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/autoplay}
     */
    get autoplay(): boolean;
    set autoplay(newAutoplay: boolean);
    protected _attemptingAutoplay: boolean;
    protected get _canAttemptAutoplay(): boolean;
    protected _attemptAutoplay(): Promise<void>;
    protected _controller?: MediaController;
    /**
     * Queue actions to be applied safely after the provider has attached to the media controller.
     */
    protected controllerQueue: RequestQueue;
    /**
     * The media controller that this provider is attached to.
     */
    get controller(): MediaController | undefined;
    /**
     * The current log level. Values in order of priority are: `silent`, `error`, `warn`, `info`,
     * and `debug`.
     */
    get logLevel(): LogLevel;
    set logLevel(level: LogLevel);
    /**
     * The amount of delay in milliseconds while media playback is progressing without user
     * activity to indicate an idle state.
     *
     * @defaultValue 2000
     */
    get idleDelay(): number;
    set idleDelay(delay: number);
    /**
     * Attach a media controller to the media provider.
     */
    attachMediaController(controller: MediaController, onDisconnect: DisconnectCallback): void;
    dispatchEvent(event: Event): boolean;
    /* Excluded from this release type: _store */
    /* Excluded from this release type: _state */
    store(): ReadableMediaStoreRecord;
    get state(): {
        autoplay: boolean;
        autoplayError: {
            muted: boolean;
            error: Error;
        } | undefined;
        buffered: TimeRanges;
        duration: number;
        bufferedAmount: number;
        canLoad: boolean;
        canPlay: boolean;
        canFullscreen: boolean;
        controls: boolean;
        poster: string;
        currentSrc: string;
        currentTime: number;
        ended: boolean;
        error: MediaErrorDetail | undefined;
        fullscreen: boolean;
        userIdle: boolean;
        loop: boolean;
        mediaType: MediaType;
        muted: boolean;
        paused: boolean;
        played: TimeRanges;
        playing: boolean;
        playsinline: boolean;
        seekable: TimeRanges;
        seekableAmount: number;
        seeking: boolean;
        src: string[];
        started: boolean;
        viewType: ViewType;
        volume: number;
        waiting: boolean;
    };
    /**
     * Queue actions to be applied after the element has connected to the DOM.
     */
    readonly connectedQueue: RequestQueue;
    /**
     * Queue actions to be taken on the current media provider when it's ready for playback (i.e.,
     * `canPlay`). If the media provider is ready, actions will be invoked immediately.
     */
    readonly mediaQueue: RequestQueue;
    /**
     * Controls the screen orientation of the current browser window.
     */
    readonly screenOrientationController: ScreenOrientationController;
    /**
     * Controls the fullscreen state of the current element.
     */
    readonly fullscreenController: FullscreenController;
    /**
     * Whether the native browser fullscreen API is available, or the current provider can
     * toggle fullscreen mode. This does not mean that the operation is guaranteed to be successful,
     * only that it can be attempted.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API}
     */
    get canFullscreen(): boolean;
    /**
     * Whether the provider is currently in fullscreen mode.
     *
     * @defaultValue false
     */
    get fullscreen(): boolean;
    /**
     * This will indicate the orientation to lock the screen to when in fullscreen mode and
     * the Screen Orientation API is available. The default is `undefined` which indicates
     * no screen orientation change.
     *
     * @defaultValue undefined
     */
    get fullscreenOrientation(): ScreenOrientationLock | undefined;
    set fullscreenOrientation(lockType: ScreenOrientationLock | undefined);
    /**
     * Attempts to display the element in fullscreen. The promise will resolve if successful, and
     * reject if not.
     */
    enterFullscreen(): Promise<void>;
    /**
     * Attempts to display the element inline by exiting fullscreen.
     */
    exitFullscreen(): Promise<void>;
}

export declare type MediaProviderElementContext = Context<WritableStore<MediaProviderElement | undefined>>;

/**
 * Holds a contextual store reference to the media provider element (e.g, `<vds-video>` or
 * `<vds-hls>`, etc.).
 */
export declare const mediaProviderElementContext: MediaProviderElementContext;

/**
 * A simple facade for dispatching media requests to the nearest media controller.
 *
 * @example
 * ```ts
 * import { MediaRemoteControl } from '@vidstack/player';
 *
 * class MyElement extends HTMLElement {
 *   mediaRemoteControl = new MediaRemoteControl(this);
 *
 *   sendPlayRequest() {
 *     this.mediaRemoteControl.play();
 *   }
 * }
 * ```
 */
export declare class MediaRemoteControl {
    protected _target?: EventTarget | null;
    protected _logger?: LogDispatcher;
    protected readonly _requests: RequestQueue;
    constructor(_host?: ReactiveControllerHost & EventTarget);
    startLoading(triggerEvent?: Event): void;
    play(triggerEvent?: Event): void;
    pause(triggerEvent?: Event): void;
    mute(triggerEvent?: Event): void;
    unmute(triggerEvent?: Event): void;
    enterFullscreen(target?: MediaFullscreenRequestTarget, triggerEvent?: Event): void;
    exitFullscreen(target?: MediaFullscreenRequestTarget, triggerEvent?: Event): void;
    seeking(time: number, triggerEvent?: Event): void;
    seek(time: number, triggerEvent?: Event): void;
    changeVolume(volume: number, triggerEvent?: Event): void;
    resumeUserIdle(triggerEvent?: Event): void;
    pauseUserIdle(triggerEvent?: Event): void;
    showPoster(triggerEvent?: Event): void;
    hidePoster(triggerEvent?: Event): void;
    setTarget(target?: EventTarget | null): void;
    protected _dispatchRequest<EventType extends keyof MediaRequestEvents>(type: EventType, eventInit: ExtractEventInit<MediaRequestEvents[EventType]>): void;
    protected _createLogger(target: EventTarget): void;
}

/**
 * Fired when media playback starts again after being in an `ended` state. This is fired
 * when the `loop` property is `true` and media loops, whereas the `vds-play` event is not.
 *
 * @event
 */
export declare type MediaReplayEvent = VdsMediaEvent<void> & {
    requestEvent?: PlayRequestEvent;
};

export declare type MediaRequestEvents = {
    'vds-start-loading': StartLoadingRequestEvent;
    'vds-mute-request': MuteRequestEvent;
    'vds-unmute-request': UnmuteRequestEvent;
    'vds-enter-fullscreen-request': EnterFullscreenRequestEvent;
    'vds-exit-fullscreen-request': ExitFullscreenRequestEvent;
    'vds-play-request': PlayRequestEvent;
    'vds-pause-request': PauseRequestEvent;
    'vds-seek-request': SeekRequestEvent;
    'vds-seeking-request': SeekingRequestEvent;
    'vds-volume-change-request': VolumeChangeRequestEvent;
    'vds-resume-user-idle-request': ResumeUserIdleRequestEvent;
    'vds-pause-user-idle-request': PauseUserIdleRequestEvent;
    'vds-show-poster-request': ShowPosterRequestEvent;
    'vds-hide-poster-request': HidePosterRequestEvent;
    'vds-loop-request': LoopRequestEvent;
};

/**
 * Fired when a seek operation completed, the current playback position has changed, and the
 * `seeking` property is changed to `false`.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/seeked_event}
 */
export declare type MediaSeekedEvent = VdsMediaEvent<number> & {
    requestEvent?: SeekRequestEvent;
};

/**
 * Fired when a seek operation starts, meaning the seeking property has changed to `true` and the
 * media is seeking to a new position.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/seeking_event}
 */
export declare type MediaSeekingEvent = VdsMediaEvent<number> & {
    requestEvent?: SeekingRequestEvent;
};

/**
 * Fired when the `src` property has changed value.
 *
 * @event
 */
export declare type MediaSrcChangeEvent = VdsMediaEvent<string[]>;

/**
 * Fired when the user agent is trying to fetch media data, but data is unexpectedly not
 * forthcoming.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/stalled_event}
 */
export declare type MediaStalledEvent = VdsMediaEvent<void>;

/**
 * Fired when media playback has just started, in other words the at the moment the following
 * happens: `currentTime > 0`.
 *
 * @event
 */
export declare type MediaStartedEvent = VdsMediaEvent<void>;

export declare const mediaStoreContext: Context<WritableMediaStoreRecord>;

/**
 * Helper function to simplify subscribing to a media store for the life of the given `host`
 * element, meaning when it's disconnected from the DOM, the subscription is destroyed.
 *
 * @example
 * ```ts
 * import { LitElement } from 'lit';
 * import { mediaStoreSubscription } from '@vidstack/player';
 *
 * class MyElement extends LitElement {
 *   constructor() {
 *     super();
 *     mediaStoreSubscription(this, 'paused', ($paused) => {
 *       // ...
 *     });
 *   }
 * }
 * ```
 */
export declare function mediaStoreSubscription<T extends keyof ReadableMediaStoreRecord>(host: StoreSubscriptionHost, property: T, onChange: (value: MediaContext[T]) => void): void;

/**
 * Fired when media data loading has been suspended.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/suspend_event}
 */
export declare type MediaSuspendEvent = VdsMediaEvent<void>;

/**
 * This element is responsible for synchronizing elements of the type `MediaProviderElement`.
 *
 * Synchronization includes:
 *
 * - Single media playback (eg: user plays a video while another is already playing, so we pause
 * the newly inactive player).
 *
 * - Synchronized media volume (eg: user sets desired volume to 50% on one player, and they expect
 * it to be consistent across all players).
 *
 * - Saving media volume to local storage (eg: user sets desired to volume 50%, they leave
 * the site, and when they come back they expect it to be 50% without any interaction).
 *
 * @tagname vds-media-sync
 * @slot - Used to pass in content, typically a media player/provider.
 * @events ./media-sync.events.ts
 * @example
 * ```html
 * <vds-media-sync
 *   single-playback
 *   sync-volume
 *   volume-storage-key="@vidstack/volume"
 * >
 *   <!-- ... -->
 * </vds-media-sync>
 * ```
 */
export declare class MediaSyncElement extends LitElement {
    static get styles(): CSSResultGroup;
    constructor();
    /**
     * Whether only one is player should be playing at a time.
     *
     * @defaultValue false
     */
    singlePlayback: boolean;
    /**
     * Whether media volume should be in-sync across all media players.
     *
     * @defaultValue false
     */
    syncVolume: boolean;
    /**
     * If a value is provided, volume will be saved to local storage to the given key as it's
     * updated. In addition, when a media provider connects to the manager, it's volume will be
     * set to the saved volume level. If no value is provided, nothing is saved or retrieved.
     *
     * Note that this includes both the volume and muted state.
     *
     * @defaultValue undefined
     */
    volumeStorageKey?: string;
    disconnectedCallback(): void;
    render(): TemplateResult<1>;
    protected _provider?: MediaProviderElement;
    protected _providerDisposal: DisposalBin;
    get provider(): MediaProviderElement | undefined;
    protected _handleMediaProviderConnect(provider: MediaProviderElement, onDisconnect: DisconnectCallback): void;
    protected _handleMediaPlay(): void;
    protected _handleMediaVolumeChange(event: MediaVolumeChangeEvent): void;
    protected _getSavedMediaVolume(): MediaVolumeChange | undefined;
    protected _saveMediaVolume(event: MediaVolumeChangeEvent): void;
}

export declare type MediaSyncEvents = {
    'vds-media-volume-sync': MediaVolumeSyncEvent;
};

/**
 * Fired when the `currentTime` property value changes due to media playback or the
 * user seeking.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/timeupdate_event}
 */
export declare type MediaTimeUpdateEvent = VdsMediaEvent<{
    currentTime: number;
    played: TimeRanges;
}>;

/**
 * Indicates the type of media currently loading/loaded.
 */
export declare enum MediaType {
    Unknown = "unknown",
    Audio = "audio",
    Video = "video",
    LiveVideo = "live-video"
}

/**
 * Fired when the `mediaType` property changes value.
 *
 * @event
 */
export declare type MediaTypeChangeEvent = VdsMediaEvent<MediaType>;

/**
 * Fired when the `viewType` property changes `value`. This will generally fire when the
 * new provider has mounted and determined what type of player view is appropriate given
 * the type of media it can play.
 *
 * @event
 */
export declare type MediaViewTypeChangeEvent = VdsMediaEvent<ViewType>;

export declare type MediaVisibilityChange = {
    /**
     * The media provider element for which visibility has changed.
     */
    provider: MediaProviderElement;
    /**
     * Whether media is intersecting the configured viewport on the `MediaVisibilityElement`.
     */
    viewport: {
        isIntersecting: boolean;
    };
    /**
     * The current page state and visibility.
     */
    page: {
        state: PageState;
        visibility: PageVisibility;
    };
};

/**
 * Fired when media visibility changes based on the viewport position or page visibility state.
 *
 * @bubbles
 * @composed
 */
export declare type MediaVisibilityChangeEvent = VdsEvent<MediaVisibilityChange>;

/**
 * This element is responsible for managing a `MediaProviderElement` as viewport or page
 * visibility changes occur.
 *
 * Management includes:
 *
 * - Playback or volume changes when page visibility changes (eg: user changes tab or device
 * sleeps).
 *
 * - Playback or volume changes when viewport visibility changes (eg: user scrolls video in and
 * out of view).
 *
 * @tagname vds-media-visibility
 * @slot - Used to pass in content, typically a media player/provider.
 * @events ./media-visibility.events.ts
 * @example
 * ```html
 * <vds-media-visibility
 *   enter-viewport="play"
 *   exit-viewport="pause"
 *   enter-page="unmute"
 *   exit-page="mute"
 * >
 *   <!-- ... -->
 * </vds-media-visibility>
 * ```
 */
export declare class MediaVisibilityElement extends LitElement {
    static get styles(): CSSResultGroup;
    constructor();
    /**
     * The action to perform on the media provider when it enters the viewport.
     *
     * @defaultValue undefined
     */
    enterViewport?: EnterVisibilityMediaAction;
    /**
     * The action to perform on the media provider when it exits the viewport.
     *
     * @defaultValue undefined
     */
    exitViewport?: ExitVisibilityMediaAction;
    /**
     * The amount of time in milliseconds to delay viewport enter actions.
     *
     * @defaultValue 0
     */
    viewportEnterDelay: number;
    /**
     * The action to perform on the media provider when the page becomes visible.
     *
     * @defaultValue undefined
     */
    enterPage?: EnterVisibilityMediaAction;
    /**
     * The action to perform on the media provider when the page becomes hidden.
     *
     * @defaultValue undefined
     */
    exitPage?: ExitVisibilityMediaAction;
    /**
     * The type of page state to use when determining visibility.
     *
     * - **state:** Refers to the page lifecycle state. This is typically what you want.
     * - **visibility:** Visible here means the page content may be at least partially visible. In
     * practice, this means that the page is the foreground tab of a non-minimized window.
     *
     *ðŸ’¡ Need help making a decision?
     *
     * - Use `state` when you want completely visible / not visible.
     * - Use `visibility` when you want partially visible / not visible.
     *
     * @defaultValue 'state'
     */
    pageChangeType: 'state' | 'visibility';
    /**
     * The amount of time in milliseconds to delay page enter actions.
     *
     * @defaultValue 0
     */
    pageEnterDelay: number;
    /**
     * A DOM query selector for the element that is used as the viewport for checking visibility
     * of the media player. Must be a ancestor of the media player. Defaults to the browser viewport
     * if not specified.
     *
     * @defaultValue undefined
     */
    intersectionRoot?: string;
    /**
     * A number which indicates at what percentage of the media player's visibility the observer's
     * `onEnter` and `onExit` actions should be triggered.
     *
     * @defaultValue 1
     */
    intersectionThreshold: number;
    protected _isIntersecting: boolean;
    get isIntersecting(): boolean;
    disconnectedCallback(): void;
    render(): TemplateResult<1>;
    protected _provider?: MediaProviderElement;
    protected _providerDisposal: DisposalBin;
    get provider(): MediaProviderElement | undefined;
    protected _handleMediaProviderConnect(provider: MediaProviderElement, onDisconnect: DisconnectCallback): void;
    protected _hasIntersected: boolean;
    protected _intersectionTimeout?: any;
    protected intersectionController: IntersectionController;
    protected _pageTimeout?: any;
    protected pageController: PageController;
    protected _triggerOnEnter(mediaAction?: EnterVisibilityMediaAction): void;
    protected _triggerOnExit(mediaAction?: ExitVisibilityMediaAction): void;
    protected _dispatchVisibilityChange(): void;
}

export declare type MediaVisibilityEvents = {
    'vds-media-visibility-change': MediaVisibilityChangeEvent;
};

export declare type MediaVolumeChange = {
    muted: boolean;
    volume: number;
};

/**
 * Fired when the `volume` or `muted` properties change value.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/volumechange_event}
 */
export declare type MediaVolumeChangeEvent = VdsMediaEvent<MediaVolumeChange> & {
    requestEvent?: MuteRequestEvent | UnmuteRequestEvent | VolumeChangeRequestEvent;
};

/**
 * Fired when media volume has been synchronized.
 *
 * @bubbles
 * @composed
 */
export declare type MediaVolumeSyncEvent = VdsEvent<MediaVolumeChange>;

/**
 * Fired when playback has stopped because of a temporary lack of data.
 *
 * @event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/waiting_event}
 */
export declare type MediaWaitingEvent = VdsMediaEvent<void>;

/**
 * A button for toggling the muted state of the player.
 *
 * ðŸ’¡ The following attributes are applied:
 *
 * - `muted`: Applied when media audio has been muted.
 *
 * @tagname vds-mute-button
 * @slot - Used to pass content into the mute toggle for showing mute/unmute states.
 * @example
 * ```html
 * <vds-mute-button>
 *   <div class="mute">Mute</div>
 *   <div class="unmute">Unmute</div>
 * </vds-mute-button>
 * ```
 * @example
 * ```css
 * vds-mute-button[muted] .mute {
 *   display: none;
 * }
 *
 * vds-mute-button:not([muted]) .unmute {
 *   display: none;
 * }
 * ```
 */
export declare class MuteButtonElement extends ToggleButtonElement {
    protected readonly _mediaRemote: MediaRemoteControl;
    protected _volume: number;
    protected _muted: boolean;
    constructor();
    connectedCallback(): void;
    protected _handleMutedChange(): void;
    protected _handleButtonClick(event: Event): void;
}

/**
 * Fired when requesting the media to be muted.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type MuteRequestEvent = VdsEvent<void>;

/**
 * Fired when requesting media playback to temporarily stop.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type PauseRequestEvent = VdsEvent<void>;

/**
 * Fired when user idle state tracking should pause. This is typically used when a control
 * is being actively interacted with, and we don't want the `idle` state changing until
 * the interaction is complete (eg: scrubbing, or settings is open).
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type PauseUserIdleRequestEvent = VdsEvent<void>;

export declare type PendingMediaRequests = {
    loading: StartLoadingRequestEvent[];
    play: PlayRequestEvent[];
    pause: PauseRequestEvent[];
    volume: (MuteRequestEvent | UnmuteRequestEvent | VolumeChangeRequestEvent)[];
    fullscreen: (EnterFullscreenRequestEvent | ExitFullscreenRequestEvent)[];
    seeked: SeekRequestEvent[];
    seeking: SeekingRequestEvent[];
    userIdle: (ResumeUserIdleRequestEvent | PauseUserIdleRequestEvent)[];
};

/**
 * A button for toggling the playback state (play/pause) of the current media.
 *
 * ðŸ’¡ The following attributes are applied:
 *
 * - `paused`: Applied when media playback has paused.
 *
 * @tagname vds-play-button
 * @slot - Used to pass content into the play toggle for showing play/pause states.
 * @example
 * ```html
 * <vds-play-button>
 *   <div class="play">Play</div>
 *   <div class="pause">Pause</div>
 * </vds-play-button>
 * ```
 * @example
 * ```css
 * vds-play-button:not([paused]) .play {
 *   display: none;
 * }
 *
 * vds-play-button[paused] .pause {
 *   display: none;
 * }
 * ```
 */
export declare class PlayButtonElement extends ToggleButtonElement {
    protected readonly _mediaRemote: MediaRemoteControl;
    constructor();
    connectedCallback(): void;
    protected _handleButtonClick(event: Event): void;
}

/**
 * Fired when requesting media playback to begin/resume.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type PlayRequestEvent = VdsEvent<void>;

/**
 * Loads and displays the current media poster image. By default, the media provider's
 * loading strategy is respected meaning the poster won't load until the media can.
 *
 * ðŸ’¡ The following img attributes are applied:
 *
 * - `img-loading`: When the poster image is in the process of being downloaded by the browser.
 * - `img-loaded`: When the poster image has successfully loaded.
 * - `img-error`: When the poster image has failed to load.
 *
 * @tagname vds-poster
 * @csspart img - The img element.
 * @example
 * ```html
 * <vds-media>
 *   <vds-poster alt="Large alien ship hovering over New York."></vds-poster>
 * </vds-media>
 * ```
 * @example
 * ```css
 * vds-poster {
 *   position: absolute;
 *   top: 0;
 *   left: 0;
 *   width: 100%;
 *   height: 100%;
 * }
 * ```
 */
export declare class PosterElement extends LitElement {
    static get styles(): CSSResultGroup;
    constructor();
    protected __src?: string;
    protected __canLoad: boolean;
    /**
     * The URL of the current poster resource.
     *
     * @defaultValue undefined
     */
    get src(): string | undefined;
    /**
     * â™¿ **ARIA:** Provides alternative information for a poster image if a user for some reason
     * cannot view it.
     *
     * @defaultValue undefined
     */
    alt?: string;
    protected _mediaRemoteControl: MediaRemoteControl;
    connectedCallback(): void;
    disconnectedCallback(): void;
    protected render(): TemplateResult;
    protected _setImgLoadingAttr(): void;
    protected _handleImgLoad(): void;
    protected _handleImgError(): void;
    protected _handleCanLoadChange(canLoad: boolean): void;
}

export declare type ReadableMediaStoreRecord = {
    [Prop in keyof MediaContext]: ReadableStore<MediaContext[Prop]>;
};

/**
 * Hard resets all media state in the store.
 */
export declare function resetMediaStore(store: WritableMediaStoreRecord): void;

/**
 * Fired when user idle state tracking may resume. This is typically called after requesting
 * the idle state to pause via `vds-pause-user-idle-request`.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type ResumeUserIdleRequestEvent = VdsEvent<void>;

/**
 * Fired when seeking/scrubbing to a new playback position.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type SeekingRequestEvent = VdsEvent<number>;

/**
 * Fired when requesting a time change. In other words, moving the playhead to a new position.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type SeekRequestEvent = VdsEvent<number>;

/**
 * Fired when requesting the poster _should_ be rendered by the media provider element. This
 * should be fired if a custom poster element is _not_ being used.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type ShowPosterRequestEvent = VdsEvent<void>;

/**
 * Fired when the user stops dragging the slider thumb. The event detail contains the value
 * the drag is ending at.
 *
 * @event
 */
export declare type SliderDragEndEvent = VdsSliderEvent<number>;

/**
 * Fired when the user begins interacting with the slider and dragging the thumb. The event
 * detail contains the current value the drag is starting at.
 *
 * @event
 */
export declare type SliderDragStartEvent = VdsSliderEvent<number>;

/**
 * Fired when the slider drag value changes. The drag value indicates the last slider value that
 * the user has dragged to. The event detail contains the value.
 *
 * @event
 */
export declare type SliderDragValueChangeEvent = VdsSliderEvent<number>;

/**
 * A custom built `input[type="range"]` that is cross-browser friendly, ARIA friendly, mouse/touch
 * friendly and easily stylable. This component allows users to input numeric values between a
 * minimum and maximum value.
 *
 * ðŸ’¡ The following attributes are available on the host element:
 *
 * - `pointing`: Whether a device pointer is within the slider bounds.
 * - `dragging`: Whether the slider thumb is currently being dragged.
 * - `interactive`: When either `pointing` or `dragging` is true.
 *
 * @tagname vds-slider
 * @slot - Used to pass in additional content inside the slider.
 * @cssprop --vds-slider-fill-rate - The ratio of the slider that is filled (eg: `0.3`).
 * @cssprop --vds-slider-fill-value - The current amount of the slider that is filled (eg: `30`).
 * @cssprop --vds-slider-fill-percent - The fill rate expressed as a percentage such as (eg: `30%`).
 * @cssprop --vds-slider-pointer-rate - The ratio of the slider that is filled up to the device pointer.
 * @cssprop --vds-slider-pointer-value - The amount of the slider that is filled up to the device pointer.
 * @cssprop --vds-slider-pointer-percent - The pointer rate expressed as a percentage.
 * @events ./events.ts
 * @example
 * ```html
 * <vds-slider
 *   min="0"
 *   max="100"
 *   value="50"
 * >
 *  <div class="thumb"></div>
 * </vds-slider>
 * ```
 */
export declare class SliderElement extends LitElement {
    static get styles(): CSSResultGroup;
    static get parts(): string[];
    constructor();
    protected readonly _sliderStoreProvider: ContextProviderController<    {
    value: WritableStore<number>;
    pointerValue: WritableStore<number>;
    min: WritableStore<number>;
    max: WritableStore<number>;
    dragging: WritableStore<boolean>;
    pointing: WritableStore<boolean>;
    interactive: ReadableStore<boolean>;
    }>;
    get store(): {
        value: WritableStore<number>;
        pointerValue: WritableStore<number>;
        min: WritableStore<number>;
        max: WritableStore<number>;
        dragging: WritableStore<boolean>;
        pointing: WritableStore<boolean>;
        interactive: ReadableStore<boolean>;
    };
    /**
     * The lowest slider value in the range of permitted values.
     *
     * @defaultValue 0
     */
    get min(): number;
    set min(newMin: number);
    /**
     * The greatest slider value in the range of permitted values.
     *
     * @defaultValue 100
     */
    get max(): number;
    set max(newMax: number);
    /**
     * Whether the slider should be disabled (non-interactive).
     *
     * @defaultValue false
     */
    disabled: boolean;
    /**
     * The current slider value.
     *
     * @defaultValue 50
     */
    value: number;
    /**
     * A number that specifies the granularity that the slider value must adhere to.
     *
     * @defaultValue 1
     */
    get step(): number;
    set step(newStep: number);
    protected _step: number;
    /**
     * â™¿ **ARIA:** A number that specifies the number of steps taken when interacting with
     * the slider via keyboard.
     */
    get keyboardStep(): number;
    set keyboardStep(newStep: number);
    protected _keyboardStep: number;
    /**
     * â™¿ **ARIA:** A number that will be used to multiply the `keyboardStep` when the `Shift` key
     * is held down and the slider value is changed by pressing `LeftArrow` or `RightArrow`. Think
     * of it as `keyboardStep * shiftKeyMultiplier`.
     */
    shiftKeyMultiplier: number;
    /**
     * â™¿ **ARIA:** Whether custom `aria-valuemin`, `aria-valuenow`, `aria-valuemax`, and
     * `aria-valuetext` values will be provided.
     */
    customValueText: boolean;
    /**
     * Whether the slider thumb is currently being dragged.
     *
     * @defaultValue false
     */
    get isDragging(): boolean;
    /**
     * The current value to range ratio.
     *
     * @defaultValue 0.5
     * @example
     * `min` = 0
     * `max` = 10
     * `value` = 5
     * `range` = 10 (max - min)
     * `fillRate` = 0.5 (result)
     */
    get fillRate(): number;
    /**
     * The fill rate expressed as a percentage (`fillRate * 100`).
     *
     * @defaultValue 50
     */
    get fillPercent(): number;
    /**
     * The value at which the device pointer is pointing to inside the slider.
     *
     * @defaultValue 0
     */
    get pointerValue(): number;
    /**
     * The pointer value to range ratio.
     *
     * @defaultValue 0
     */
    get pointerRate(): number;
    /**
     * The pointer rate expressed as a percentage (`pointerRate * 100`).
     *
     * @defaultValue 0
     */
    get pointerPercent(): number;
    protected _mediaRemote: MediaRemoteControl;
    protected _disconnectDisposal: DisposalBin;
    connectedCallback(): void;
    protected willUpdate(changedProperties: PropertyValues): void;
    disconnectedCallback(): void;
    protected readonly _handlePointerEnter: void;
    protected readonly _handlePointerMove: void;
    protected readonly _handlePointerLeave: void;
    protected readonly _handlePointerDown: void;
    protected readonly _handleKeydown: void;
    protected readonly _handleFillValueChange: void;
    protected _updateFillCSSProps(): void;
    protected readonly _handlePointerValueChange: void;
    protected _updatePointerCSSProps(): void;
    protected render(): TemplateResult;
    protected _renderSlider(): TemplateResult;
    protected _renderDefaultSlot(): TemplateResult;
    protected _setupAriaAttrs(): void;
    protected _updateAriaValueAttrs(): void;
    protected _getValueMin(): string;
    protected _getValueNow(): string;
    protected _getValueMax(): string;
    protected _getValueText(): string;
    protected _startDragging(event: PointerEvent): void;
    protected readonly _onDrag: RafThrottledFunction<(event: PointerEvent) => void>;
    protected _stopDragging(event: PointerEvent): void;
    protected readonly _handleDocumentPointerUp: void;
    protected readonly _handleDocumentTouchMove: void;
    protected readonly _handleDocumentPointerMove: void;
    protected _getClampedValue(value: number): number;
    protected _getValueFromRate(rate: number): number;
    protected _getValueBasedOnThumbPosition(event: PointerEvent): number;
    protected _lastDispatchedValue: number;
    protected readonly _dispatchValueChange: RafThrottledFunction<(event?: Event) => void>;
    protected _lastDispatchedPointerValue: number;
    protected readonly _dispatchPointerValueChange: RafThrottledFunction<(event: Event) => void>;
}

export declare type SliderEvents = {
    'vds-slider-drag-start': SliderDragStartEvent;
    'vds-slider-drag-end': SliderDragEndEvent;
    'vds-slider-value-change': SliderValueChangeEvent;
    'vds-slider-drag-value-change': SliderDragValueChangeEvent;
    'vds-slider-pointer-value-change': SliderPointerValueChangeEvent;
};

/**
 * The direction to move the thumb, associated with key symbols.
 */
export declare enum SliderKeyDirection {
    Left = -1,
    ArrowLeft = -1,
    Up = -1,
    ArrowUp = -1,
    Right = 1,
    ArrowRight = 1,
    Down = 1,
    ArrowDown = 1
}

/**
 * Fired when the device pointer is inside the slider region and it's position changes. The
 * event detail contains the value.
 *
 * @event
 */
export declare type SliderPointerValueChangeEvent = VdsSliderEvent<number>;

export declare const sliderStoreContext: Context<    {
/**
* The current slider value.
*/
value: WritableStore<number>;
/**
* The value at which the device pointer is pointing to inside the slider.
*/
pointerValue: WritableStore<number>;
/**
* The minimum slider value.
*/
min: WritableStore<number>;
/**
* The maximum slider value.
*/
max: WritableStore<number>;
/**
* Whether the slider thumb is currently being dragged.
*/
dragging: WritableStore<boolean>;
/**
* Whether a device pointer is within the slider bounds.
*/
pointing: WritableStore<boolean>;
/**
* Whether the slider is being interacted with.
*/
interactive: ReadableStore<boolean>;
}>;

/**
 * Fired when the slider value changes. The event detail contains the current value.
 *
 * @event
 */
export declare type SliderValueChangeEvent = VdsSliderEvent<number>;

/**
 * Outputs the current slider value as text.
 *
 * @tagname vds-slider-value-text
 * @example
 * ```html
 * <vds-slider-value-text
 *   type="current"
 * ></vds-slider-value-text>
 * ```
 * @example
 * ```html
 * <vds-slider-value-text
 *   format="time"
 *   show-hours
 *   pad-hours
 * ></vds-slider-value-text>
 * ```
 * @example
 * ```html
 * <vds-slider-value-text
 *   format="percent"
 *   decimal-places="2"
 * ></vds-slider-value-text>
 * ```
 */
export declare class SliderValueTextElement extends LitElement {
    static get styles(): CSSResultGroup;
    protected _disposal: DisposalBin;
    protected _sliderStoreConsumer: ContextConsumerController<    {
    value: WritableStore<number>;
    pointerValue: WritableStore<number>;
    min: WritableStore<number>;
    max: WritableStore<number>;
    dragging: WritableStore<boolean>;
    pointing: WritableStore<boolean>;
    interactive: ReadableStore<boolean>;
    }>;
    protected get _sliderStore(): {
        value: WritableStore<number>;
        pointerValue: WritableStore<number>;
        min: WritableStore<number>;
        max: WritableStore<number>;
        dragging: WritableStore<boolean>;
        pointing: WritableStore<boolean>;
        interactive: ReadableStore<boolean>;
    };
    protected __value: number;
    /**
     * Whether to use the slider's current value, or pointer value.
     */
    type: 'current' | 'pointer';
    /**
     * Determines how the value is formatted.
     *
     * @defaultValue undefined
     */
    format?: 'percent' | 'time';
    /**
     * Whether the time should always show the hours unit, even if the time is less than
     * 1 hour. Only available if the `format` attribute is set to `time`.
     *
     * @defaultValue false
     * @example `20:30 -> 0:20:35`
     */
    showHours: boolean;
    /**
     * Whether the hours unit should be padded with zeroes to a length of 2. Only available if
     * the `format` attribute is set to `time`.
     *
     * @defaultValue false
     * @example `1:20:03 -> 01:20:03`
     */
    padHours: boolean;
    /**
     * Round the value when formatted as a percentage to the given number of decimal places. Only
     * available if `format` attribute is `percent`.
     *
     * @defaultValue 2
     */
    decimalPlaces: number;
    connectedCallback(): void;
    protected update(changedProperties: PropertyValues): void;
    disconnectedCallback(): void;
    protected render(): TemplateResult<1>;
    protected _handleTypeChange(): void;
    protected _createPercentStore(valueStore: ReadableStore<number>): ReadableStore<number>;
    protected _getValueText(): string;
    protected _getPercentFormat(): string;
    protected _getTimeFormat(): string;
}

/**
 * Used to load a low-resolution video to be displayed when the user is hovering or dragging
 * the slider. The point at which they're hovering or dragging (`pointerValue`) is the preview
 * time position. The video will automatically be updated to match, so ensure it's of the same
 * length as the original.
 *
 * ðŸ’¡ The following attributes are updated for your styling needs:
 *
 * - `video-can-play`: Applied when the video is ready for playback.
 * - `video-error`: Applied when a media error has been encountered.
 *
 * ðŸ’¡ The `canplay` and `error` events are re-dispatched by this element for you to listen to if
 * needed.
 *
 * @tagname vds-slider-video
 * @csspart video - The video element.
 * @example
 * ```html
 * <vds-time-slider>
 *  <vds-slider-video
 *    src="/low-res-video.mp4"
 *  ></vds-slider-video>
 * </vds-time-slider>
 * ```
 */
export declare class SliderVideoElement extends LitElement {
    static get styles(): CSSResultGroup;
    constructor();
    /**
     * The URL of a media resource to use.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/src}
     */
    src: string | undefined;
    protected readonly _videoRef: Ref<HTMLVideoElement>;
    /**
     * The underlying `<video>` element.
     */
    get videoElement(): HTMLVideoElement | undefined;
    protected _updateCurrentTime(seconds: number): void;
    willUpdate(changedProperties: PropertyValues): void;
    protected render(): TemplateResult;
    protected _renderVideo(): TemplateResult;
    protected __canPlay: boolean;
    protected _handleCanPlay(event: Event): Promise<void>;
    protected __hasError: boolean;
    protected _handleError(event: Event): void;
}

/**
 * Resets all media state and leaves general player state intact (i.e., `autoplay`, `volume`, etc.).
 */
export declare function softResetMediaStore(store: WritableMediaStoreRecord): void;

/**
 * Fired when requesting media to begin loading. This will only take effect if the `loading`
 * strategy on the provider is set to `custom`.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type StartLoadingRequestEvent = VdsEvent<void>;

/**
 * Outputs a media duration (eg: `currentTime`, `duration`, `bufferedAmount`, etc.) value as time
 * formatted text.
 *
 * @tagname vds-time
 * @example
 * ```html
 * <vds-time type="current"></vds-time>
 * ```
 * @example
 * ```html
 * <!-- Remaining time. -->
 * <vds-time type="current" remainder></vds-time>
 * ```
 */
export declare class TimeElement extends LitElement {
    static get styles(): CSSResultGroup;
    protected _disposal: DisposalBin;
    protected _mediaStoreConsumer: ContextConsumerController<WritableMediaStoreRecord>;
    protected get _mediaStore(): WritableMediaStoreRecord;
    protected __seconds: number;
    /**
     * The type of media time to track.
     *
     * @defaultValue 'current'
     */
    type: 'current' | 'buffered' | 'duration' | 'seekable';
    /**
     * Whether the time should always show the hours unit, even if the time is less than
     * 1 hour.
     *
     * @defaultValue false
     * @example `20:30 -> 0:20:35`
     */
    showHours: boolean;
    /**
     * Whether the hours unit should be padded with zeroes to a length of 2.
     *
     * @defaultValue false
     * @example `1:20:03 -> 01:20:03`
     */
    padHours: boolean;
    /**
     * Whether to display the remaining time from the current type, until the duration is reached.
     *
     * @defaultValue false
     * @example 'duration-currentTime'
     */
    remainder: boolean;
    connectedCallback(): void;
    protected update(changedProperties: PropertyValues): void;
    disconnectedCallback(): void;
    protected render(): TemplateResult<1>;
    protected _handleTypeChange(): void;
    protected _getTypeStore(): WritableStore<number>;
    protected _createRemainderStore(secondsStore: ReadableStore<number>): ReadableStore<number>;
    protected _getFormattedTime(): string;
}

/**
 * A slider that lets the user control the current media playback time.
 *
 * @tagname vds-time-slider
 * @example
 * ```html
 * <vds-time-slider>
 *   <div class="thumb"></div>
 * </vds-time-slider>
 * ```
 */
export declare class TimeSliderElement extends SliderElement {
    static get styles(): CSSResultGroup;
    constructor();
    connectedCallback(): void;
    protected _step: number;
    /* Excluded from this release type: value */
    /* Excluded from this release type: min */
    /* Excluded from this release type: min */
    /* Excluded from this release type: max */
    /* Excluded from this release type: max */
    /**
     * â™¿ **ARIA:** Human-readable text alternative for the current slider value. If you pass
     * in a string containing `{currentTime}` or `{duration}` templates they'll be replaced with
     * the spoken form such as `1 hour 30 minutes`.
     */
    valueText: string;
    /**
     * Whether it should request playback to pause while the user is dragging the
     * thumb. If the media was playing before the dragging starts, the state will be restored by
     * dispatching a user play request once the dragging ends.
     */
    pauseWhileDragging: boolean;
    /**
     * The amount of milliseconds to throttle media seeking request events being dispatched.
     */
    seekingRequestThrottle: number;
    protected __mediaDuration: number;
    protected __mediaPaused: boolean;
    protected update(changedProperties: PropertyValues): void;
    disconnectedCallback(): void;
    protected _getValueMin(): string;
    protected _getValueNow(): string;
    protected _getValueText(): string;
    protected _getValueMax(): string;
    protected readonly _handleSliderDragStart: void;
    protected readonly _handleSliderValueChange: void;
    protected readonly _handleSliderDragValueChange: void;
    protected readonly _handleSliderDragEnd: void;
    protected readonly _dispatchSeekingRequest: ((event: Event) => void) & {
        cancel: () => void;
        flush: () => void;
    };
    protected _wasPlayingBeforeDragStart: boolean;
    protected _togglePlaybackWhileDragging(event: Event): void;
}

/**
 * The foundation for any toggle button such as a `play-button` or `mute-button`.
 *
 * @tagname vds-toggle-button
 * @slot - Used to pass content into the toggle for showing pressed and not pressed states.
 * @example
 * ```html
 * <vds-toggle-button aria-label="Some action">
 *   <div class="pressed">Pressed</div>
 *   <div class="not-pressed">Not Pressed</div>
 * </vds-toggle-button>
 * ```
 * @example
 * ```css
 * vds-toggle-button[pressed] .pressed {
 *   display: none;
 * }
 *
 * vds-toggle-button:not([pressed]) .not-pressed {
 *  display: none;
 * }
 * ```
 */
export declare class ToggleButtonElement extends LitElement {
    static get styles(): CSSResultGroup;
    static get parts(): string[];
    constructor();
    connectedCallback(): void;
    protected updated(changedProperties: PropertyValues): void;
    protected _updateAriaPressedAttr(): void;
    /**
     * Whether the toggle is currently in a `pressed` state.
     */
    pressed: boolean;
    /**
     * Whether the underlying button should be disabled (non-interactive).
     *
     * @defaultValue false
     */
    disabled: boolean;
    protected render(): TemplateResult;
    protected _renderDefaultSlot(): TemplateResult;
    protected _handleButtonClick(event: Event): void;
    protected readonly _handleButtonClickCapture: void;
}

/**
 * Fired when requesting the media to be unmuted.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type UnmuteRequestEvent = VdsEvent<void>;

/**
 * Fired when the user idle state changes. The user is idle when playback is progressing (playing),
 * and there is no user activity for a set period of time (default is 2.5s). The event
 * detail contains whether the user is idle (`true`), or not (`false`).
 *
 * @event
 */
export declare type UserIdleChangeEvent = VdsMediaEvent<boolean> & {
    requestEvent?: ResumeUserIdleRequestEvent | PauseUserIdleRequestEvent;
};

export declare class UserIdleController implements ReactiveController {
    protected readonly _host: ReactiveControllerHost & EventTarget;
    protected readonly _mediaStore: {
        paused: ReadableStore<boolean>;
    };
    protected _idle: boolean;
    protected _idleTimeout?: any;
    protected _mediaPaused: boolean;
    protected _idlingPaused: boolean;
    protected _disposal: DisposalBin;
    /**
     * The amount of delay in milliseconds while media playback is progressing without user
     * activity to indicate an idle state.
     *
     * @defaultValue 2000
     */
    delay: number;
    /**
     * Whether media idle state tracking has been paused.
     */
    get paused(): boolean;
    set paused(paused: boolean);
    constructor(_host: ReactiveControllerHost & EventTarget, _mediaStore: {
        paused: ReadableStore<boolean>;
    });
    hostConnected(): void;
    hostDisconnected(): void;
    protected _handleIdleChange(): void;
    protected _startIdleTimer(): void;
    protected _stopIdleTimer(): void;
    protected _dispatchIdleChange(isIdle: boolean): void;
}

export declare type VdsHlsEvent<DetailType = unknown> = VdsEvent<DetailType> & {
    target: HlsElement;
};

export declare type VdsMediaEvent<DetailType = unknown> = VdsEvent<DetailType> & {
    target: MediaProviderElement;
    requestEvent?: VdsEvent<unknown>;
};

export declare type VdsSliderEvent<DetailType = unknown> = VdsEvent<DetailType> & {
    target: SliderElement;
};

export declare const VIDEO_EXTENSIONS: RegExp;

/**
 * The `<vds-video>` element adapts the underlying `<video>` element to satisfy the media provider
 * contract, which generally involves providing a consistent API for loading, managing, and
 * tracking media state.
 *
 * Most the logic for this element is contained in the `Html5MediaElement` class because both the
 * `<audio>` and `<video>` elements implement the native `HTMLMediaElement` interface.
 *
 * @tagname vds-video
 * @slot - Used to pass in the `<video>` element.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video}
 * @events ./presentation/events.ts
 * @cssprop --vds-video-width - The width of the video element.
 * @cssprop --vds-video-height - The height of the video element.
 * @cssprop --vds-video-bg-color - The background color of the video content.
 * @example
 * ```html
 * <vds-video poster="https://media-files.vidstack.io/poster.png">
 *   <video
 *     controls
 *     preload="none"
 *     src="https://media-files.vidstack.io/720p.mp4"
 *     poster="https://media-files.vidstack.io/poster-seo.png"
 *   ></video>
 * </vds-video>
 * ```
 * @example
 * ```html
 * <vds-video poster="https://media-files.vidstack.io/poster.png">
 *   <video
 *     controls
 *     preload="none"
 *     poster="https://media-files.vidstack.io/poster-seo.png"
 *   >
 *     <source
 *       src="https://media-files.vidstack.io/720p.mp4"
 *       type="video/mp4"
 *     />
 *     <track
 *       default
 *       kind="subtitles"
 *       srclang="en"
 *       label="English"
 *       src="https://media-files.vidstack.io/subs/english.vtt"
 *     />
 *   </video>
 * </vds-video>
 * ```
 */
export declare class VideoElement extends Html5MediaElement {
    static get styles(): CSSResultGroup;
    connectedCallback(): void;
    get videoElement(): HTMLVideoElement;
    readonly presentationController: VideoPresentationController;
    readonly fullscreenController: VideoFullscreenController;
}

/**
 * Extends the base `FullscreenController` with additional logic for handling fullscreen
 * on iOS Safari where the native Fullscreen API is not available (in this case it falls back to
 * using the `VideoPresentationController`).
 *
 * @example
 * ```ts
 * import { LitElement } from 'lit';
 * import {
 *   FullscreenController,
 *   ScreenOrientationController,
 *   VideoPresentationController
 * } from '@vidstack/elements';
 *
 * class MyElement extends LitElement {
 *   get videoElement() {
 *     return this.videoEl;
 *   }
 *
 *   fullscreenController = new VideoFullscreenController(
 *     this,
 *     new ScreenOrientationController(this),
 *     new VideoPresentationController(this),
 *   );
 *
 *   enterFullscreen() {
 *     return this.fullscreenController.enterFullscreen();
 *   }
 *
 *   exitFullscreen() {
 *     return this.fullscreenController.exitFullscreen();
 *   }
 * }
 * ```
 */
export declare class VideoFullscreenController extends FullscreenController {
    protected readonly _presentationController: VideoPresentationController;
    constructor(host: FullscreenControllerHost, screenOrientationController: ScreenOrientationController, _presentationController: VideoPresentationController);
    get isFullscreen(): boolean;
    get isSupported(): boolean;
    /**
     * Whether a fallback fullscreen API is available on Safari using presentation modes. This
     * is only used on iOS where the native fullscreen API is not available.
     *
     * @see {@link https://developer.apple.com/documentation/webkitjs/htmlvideoelement/1631913-webkitpresentationmode}
     */
    get isSupportedOnSafari(): boolean;
    protected _makeEnterFullscreenRequest(): Promise<void>;
    protected _makeFullscreenRequestOnSafari(): Promise<void>;
    protected _makeExitFullscreenRequest(): Promise<void>;
    protected _makeExitFullscreenRequestOnSafari(): Promise<void>;
    protected _addFullscreenChangeEventListener(handler: (this: HTMLElement, event: Event) => void): () => void;
    protected _handlePresentationModeChange(event: VideoPresentationChangeEvent): void;
    protected _addFullscreenErrorEventListener(handler: (this: HTMLElement, event: Event) => void): () => void;
}

/**
 * Fired when the video presentation mode changes. Only available in Safari.
 *
 * @event
 */
export declare type VideoPresentationChangeEvent = VdsEvent<WebKitPresentationMode>;

/**
 * Contains the logic for handling presentation modes on Safari. This class is used by
 * the `VideoFullscreenController` as a fallback when the native Fullscreen API is not
 * available (ie: iOS Safari).
 *
 * @example
 * ```ts
 * import { LitElement } from 'lit';
 * import { VideoPresentationController } from '@vidstack/player';
 *
 * class MyElement extends LitElement {
 *   get videoElement(): HTMLVideoElement | undefined {
 *     return this.videoEl;
 *   }
 *
 *   presentationController = new VideoPresentationController(this);
 * }
 * ```
 */
export declare class VideoPresentationController {
    protected readonly _host: VideoPresentationControllerHost;
    protected readonly _listenerDisposal: DisposalBin;
    protected readonly _logger: LogDispatcher | undefined;
    constructor(_host: VideoPresentationControllerHost);
    protected _handleHostDisconnected(): void;
    /**
     * The current presentation mode, possible values include `inline`, `picture-in-picture` and
     * `fullscreen`. Only available in Safari.
     *
     * @defaultValue undefined
     * @see {@link https://developer.apple.com/documentation/webkitjs/htmlvideoelement/1631913-webkitpresentationmode}
     */
    get presentationMode(): WebKitPresentationMode | undefined;
    /**
     * Whether the current `presentationMode` is `inline`.
     */
    get isInlineMode(): boolean;
    /**
     * Whether the current `presentationMode` is `picture-in-picture`.
     */
    get isPictureInPictureMode(): boolean;
    /**
     * Whether the current `presentationMode` is `fullscreen`.
     */
    get isFullscreenMode(): boolean;
    /**
     * Whether the presentation mode API is available.
     *
     * @see {@link https://developer.apple.com/documentation/webkitjs/htmlvideoelement/1628805-webkitsupportsfullscreen}
     */
    get isSupported(): boolean;
    setPresentationMode(mode: WebKitPresentationMode): void;
    /**
     * @returns Stop listening function.
     */
    protected _addPresentationModeChangeEventListener(): () => void;
    protected _handlePresentationModeChange(event: Event): void;
}

export declare type VideoPresentationControllerHost = ReactiveElement & {
    readonly videoElement: HTMLVideoElement | undefined;
};

export declare type VideoPresentationEvents = {
    'vds-video-presentation-change': VideoPresentationChangeEvent;
};

/**
 * Indicates the current view type which determines how the media will be presented.
 */
export declare enum ViewType {
    Unknown = "unknown",
    Audio = "audio",
    Video = "video"
}

/**
 * Fired when requesting the media volume to be set to a new level.
 *
 * @event
 * @bubbles
 * @composed
 */
export declare type VolumeChangeRequestEvent = VdsEvent<number>;

/**
 * A slider control that lets the user specify their desired volume level.
 *
 * @tagname vds-volume-slider
 *  @example
 * ```html
 * <vds-volume-slider>
 *   <div class="thumb"></div>
 * </vds-volume-slider>
 * ```
 */
export declare class VolumeSliderElement extends SliderElement {
    constructor();
    connectedCallback(): void;
    /* Excluded from this release type: min */
    /* Excluded from this release type: min */
    /* Excluded from this release type: max */
    /* Excluded from this release type: max */
    /* Excluded from this release type: value */
    protected readonly _handleSliderValueChange: void;
    protected readonly _handleSliderDragValueChange: void;
    protected _changeVolume(event: VdsEvent<number>): void;
}

export { walkTriggerEventChain }

export declare type WritableMediaStoreRecord = {
    [Prop in keyof MediaContext]: WritableStore<MediaContext[Prop]>;
};

export { }
